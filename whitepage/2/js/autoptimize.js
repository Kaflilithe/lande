var WPacTime = WPacTime || {
	getTime: function (a, b, d) {
		return "chat" == d ? this.getChatTime(a, b || "en") : d ? this.getFormatTime(a, d, b || "en") : this.getDefaultTime(a, b || "en")
	},
	getChatTime: function (a, b) {
		var d = ((new Date).getTime() - a) / 1E3 / 60 / 60,
			c = d / 24;
		return 24 > d ? this.getFormatTime(a, "HH:mm", b) : 365 > c ? this.getFormatTime(a, "dd.MM HH:mm", b) : this.getFormatTime(a, "yyyy.MM.dd HH:mm", b)
	},
	getDefaultTime: function (a, b) {
		return this.getTimeAgo(a, b)
	},
	getTimeAgo: function (a, b) {
		a = ((new Date).getTime() - a) / 1E3;
		var d = a / 60,
			c = d / 60,
			e = c / 24,
			f = e / 365;
		b = WPacTime.Messages[b] ? b : "en";
		return 45 > a ? WPacTime.Messages[b].second : 90 > a ? WPacTime.Messages[b].minute : 45 > d ? WPacTime.Messages[b].minutes(d) : 90 > d ? WPacTime.Messages[b].hour : 24 > c ? WPacTime.Messages[b].hours(c) : 48 > c ? WPacTime.Messages[b].day : 30 > e ? WPacTime.Messages[b].days(e) : 60 > e ? WPacTime.Messages[b].month : 365 > e ? WPacTime.Messages[b].months(e) : 2 > f ? WPacTime.Messages[b].year : WPacTime.Messages[b].years(f)
	},
	getTime12: function (a, b) {
		a = new Date(a);
		return (a.getHours() % 12 ? a.getHours() % 12 : 12) + ":" + a.getMinutes() +
			(12 <= a.getHours() ? " PM" : " AM")
	},
	getFormatTime: function (a, b, d) {
		var c = new Date(a),
			e = {
				SS: c.getMilliseconds(),
				ss: c.getSeconds(),
				mm: c.getMinutes(),
				HH: c.getHours(),
				hh: (c.getHours() % 12 ? c.getHours() % 12 : 12) + (12 <= c.getHours() ? "PM" : "AM"),
				dd: c.getDate(),
				MM: c.getMonth() + 1,
				yyyy: c.getFullYear(),
				yy: String(c.getFullYear()).toString().substr(2, 2),
				ago: this.getTimeAgo(a, d),
				12: this.getTime12(a, d)
			};
		return b.replace(/(SS|ss|mm|HH|hh|DD|dd|MM|yyyy|yy|ago|12)/g, function (a, b) {
			a = e[b];
			return 10 > a ? "0" + a : a
		})
	},
	declineNum: function (a, b, d, c) {
		return a + " " + this.declineMsg(a, b, d, c)
	},
	declineMsg: function (a, b, d, c, e) {
		var f = a % 10;
		return 1 == f && (1 == a || 20 < a) ? b : 1 < f && 5 > f && (20 < a || 10 > a) ? d : a ? c : e
	}
};
WPacTime.Messages = {
	ru: {
		second: "\u0442\u043e\u043b\u044c\u043a\u043e \u0447\u0442\u043e",
		minute: "\u043c\u0438\u043d\u0443\u0442\u0443 \u043d\u0430\u0437\u0430\u0434",
		minutes: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u043c\u0438\u043d\u0443\u0442\u0430 \u043d\u0430\u0437\u0430\u0434", "\u043c\u0438\u043d\u0443\u0442\u044b \u043d\u0430\u0437\u0430\u0434", "\u043c\u0438\u043d\u0443\u0442 \u043d\u0430\u0437\u0430\u0434")
		},
		hour: "\u0447\u0430\u0441 \u043d\u0430\u0437\u0430\u0434",
		hours: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0447\u0430\u0441 \u043d\u0430\u0437\u0430\u0434", "\u0447\u0430\u0441\u0430 \u043d\u0430\u0437\u0430\u0434", "\u0447\u0430\u0441\u043e\u0432 \u043d\u0430\u0437\u0430\u0434")
		},
		day: "\u0434\u0435\u043d\u044c \u043d\u0430\u0437\u0430\u0434",
		days: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0434\u0435\u043d\u044c \u043d\u0430\u0437\u0430\u0434", "\u0434\u043d\u044f \u043d\u0430\u0437\u0430\u0434", "\u0434\u043d\u0435\u0439 \u043d\u0430\u0437\u0430\u0434")
		},
		month: "\u043c\u0435\u0441\u044f\u0446 \u043d\u0430\u0437\u0430\u0434",
		months: function (a) {
			return WPacTime.declineNum(Math.round(a / 30), "\u043c\u0435\u0441\u044f\u0446 \u043d\u0430\u0437\u0430\u0434", "\u043c\u0435\u0441\u044f\u0446\u0430 \u043d\u0430\u0437\u0430\u0434", "\u043c\u0435\u0441\u044f\u0446\u0435\u0432 \u043d\u0430\u0437\u0430\u0434")
		},
		year: "\u0433\u043e\u0434 \u043d\u0430\u0437\u0430\u0434",
		years: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0433\u043e\u0434 \u043d\u0430\u0437\u0430\u0434", "\u0433\u043e\u0434\u0430 \u043d\u0430\u0437\u0430\u0434", "\u043b\u0435\u0442 \u043d\u0430\u0437\u0430\u0434")
		}
	},
	en: {
		second: "just now",
		minute: "1m ago",
		minutes: function (a) {
			return Math.round(a) + "m ago"
		},
		hour: "1h ago",
		hours: function (a) {
			return Math.round(a) + "h ago"
		},
		day: "a day ago",
		days: function (a) {
			return Math.round(a) + " days ago"
		},
		month: "a month ago",
		months: function (a) {
			return Math.round(a / 30) + " months ago"
		},
		year: "a year ago",
		years: function (a) {
			return Math.round(a) + " years ago"
		}
	},
	uk: {
		second: "\u0442\u0456\u043b\u044c\u043a\u0438 \u0449\u043e",
		minute: "\u0445\u0432\u0438\u043b\u0438\u043d\u0443 \u0442\u043e\u043c\u0443",
		minutes: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0445\u0432\u0438\u043b\u0438\u043d\u0443 \u0442\u043e\u043c\u0443", "\u0445\u0432\u0438\u043b\u0438\u043d\u0438 \u0442\u043e\u043c\u0443", "\u0445\u0432\u0438\u043b\u0438\u043d \u0442\u043e\u043c\u0443")
		},
		hour: "\u0433\u043e\u0434\u0438\u043d\u0443 \u0442\u043e\u043c\u0443",
		hours: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0433\u043e\u0434\u0438\u043d\u0443 \u0442\u043e\u043c\u0443", "\u0433\u043e\u0434\u0438\u043d\u0438 \u0442\u043e\u043c\u0443", "\u0433\u043e\u0434\u0438\u043d \u0442\u043e\u043c\u0443")
		},
		day: "\u0434\u0435\u043d\u044c \u0442\u043e\u043c\u0443",
		days: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0434\u0435\u043d\u044c \u0442\u043e\u043c\u0443", "\u0434\u043d\u0456 \u0442\u043e\u043c\u0443", "\u0434\u043d\u0456\u0432 \u0442\u043e\u043c\u0443")
		},
		month: "\u043c\u0456\u0441\u044f\u0446\u044c \u0442\u043e\u043c\u0443",
		months: function (a) {
			return WPacTime.declineNum(Math.round(a / 30), "\u043c\u0456\u0441\u044f\u0446\u044c \u0442\u043e\u043c\u0443", "\u043c\u0456\u0441\u044f\u0446\u0456 \u0442\u043e\u043c\u0443", "\u043c\u0456\u0441\u044f\u0446\u0456\u0432 \u0442\u043e\u043c\u0443")
		},
		year: "\u0440\u0456\u043a \u0442\u043e\u043c\u0443",
		years: function (a) {
			return WPacTime.declineNum(Math.round(a), "\u0440\u0456\u043a \u0442\u043e\u043c\u0443", "\u0440\u043e\u043a\u0438 \u0442\u043e\u043c\u0443", "\u0440\u043e\u043a\u0456\u0432 \u0442\u043e\u043c\u0443")
		}
	}
};

var sbi_js_exists = (typeof sbi_js_exists !== 'undefined') ? !0 : !1;
if (!sbi_js_exists) {
	(function () {
		"use strict";
		var e = Array.prototype.slice;
		try {
			e.call(document.documentElement)
		} catch (t) {
			Array.prototype.slice = function (t, n) {
				n = typeof n !== "undefined" ? n : this.length;
				if (Object.prototype.toString.call(this) === "[object Array]") {
					return e.call(this, t, n)
				}
				var r, i = [],
					s, o = this.length;
				var u = t || 0;
				u = u >= 0 ? u : o + u;
				var a = n ? n : o;
				if (n < 0) {
					a = o + n
				}
				s = a - u;
				if (s > 0) {
					i = new Array(s);
					if (this.charAt) {
						for (r = 0; r < s; r++) {
							i[r] = this.charAt(u + r)
						}
					} else {
						for (r = 0; r < s; r++) {
							i[r] = this[u + r]
						}
					}
				}
				return i
			}
		}
	})()
	if (!Function.prototype.bind) {
		Function.prototype.bind = function (e) {
			if (typeof this !== "function") {
				throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable")
			}
			var t = Array.prototype.slice.call(arguments, 1),
				n = this,
				r = function () { },
				i = function () {
					return n.apply(this instanceof r && e ? this : e, t.concat(Array.prototype.slice.call(arguments)))
				};
			r.prototype = this.prototype;
			i.prototype = new r;
			return i
		}
	}
	var sbIconSVG = {
		'fa-clock': 'class="svg-inline--fa fa-clock fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="far" data-icon="clock" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm61.8-104.4l-84.9-61.7c-3.1-2.3-4.9-5.9-4.9-9.7V116c0-6.6 5.4-12 12-12h32c6.6 0 12 5.4 12 12v141.7l66.8 48.6c5.4 3.9 6.5 11.4 2.6 16.8L334.6 349c-3.9 5.3-11.4 6.5-16.8 2.6z"></path></svg>',
		'fa-play': 'class="svg-inline--fa fa-play fa-w-14 sbi_playbtn" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="play" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"></path></svg>',
		'fa-image': 'class="svg-inline--fa fa-image fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="far" data-icon="image" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>',
		'fa-user': 'class="svg-inline--fa fa-user fa-w-16" style="margin-right: 3px;" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="user" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M96 160C96 71.634 167.635 0 256 0s160 71.634 160 160-71.635 160-160 160S96 248.366 96 160zm304 192h-28.556c-71.006 42.713-159.912 42.695-230.888 0H112C50.144 352 0 402.144 0 464v24c0 13.255 10.745 24 24 24h464c13.255 0 24-10.745 24-24v-24c0-61.856-50.144-112-112-112z"></path></svg>',
		'fa-comment': 'class="svg-inline--fa fa-comment fa-w-18" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="comment" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M576 240c0 115-129 208-288 208-48.3 0-93.9-8.6-133.9-23.8-40.3 31.2-89.8 50.3-142.4 55.7-5.2.6-10.2-2.8-11.5-7.7-1.3-5 2.7-8.1 6.6-11.8 19.3-18.4 42.7-32.8 51.9-94.6C21.9 330.9 0 287.3 0 240 0 125.1 129 32 288 32s288 93.1 288 208z"></path></svg>',
		'fa-heart': 'class="svg-inline--fa fa-heart fa-w-18" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="heart" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M414.9 24C361.8 24 312 65.7 288 89.3 264 65.7 214.2 24 161.1 24 70.3 24 16 76.9 16 165.5c0 72.6 66.8 133.3 69.2 135.4l187 180.8c8.8 8.5 22.8 8.5 31.6 0l186.7-180.2c2.7-2.7 69.5-63.5 69.5-136C560 76.9 505.7 24 414.9 24z"></path></svg>',
		'fa-check': 'class="svg-inline--fa fa-check fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="check" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"></path></svg>',
		'fa-exclamation-circle': 'class="svg-inline--fa fa-exclamation-circle fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="exclamation-circle" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"></path></svg>',
		'fa-map-marker': 'class="svg-inline--fa fa-map-marker fa-w-12" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="map-marker" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0z"></path></svg>',
		'fa-clone': 'class="svg-inline--fa fa-clone fa-w-16 sbi_lightbox_carousel_icon" aria-hidden="true" data-fa-processed="" data-prefix="far" data-icon="clone" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M464 0H144c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h320c26.51 0 48-21.49 48-48v-48h48c26.51 0 48-21.49 48-48V48c0-26.51-21.49-48-48-48zM362 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h42v224c0 26.51 21.49 48 48 48h224v42a6 6 0 0 1-6 6zm96-96H150a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h308a6 6 0 0 1 6 6v308a6 6 0 0 1-6 6z"></path></svg>',
		'fa-chevron-right': 'class="svg-inline--fa fa-chevron-right fa-w-10" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="chevron-right" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"></path></svg>',
		'fa-chevron-left': 'class="svg-inline--fa fa-chevron-left fa-w-10" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="chevron-left" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"></path></svg>',
		'fa-share': 'class="svg-inline--fa fa-share fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="share" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"></path></svg>',
		'fa-times': 'class="svg-inline--fa fa-times fa-w-12" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="times" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"></path></svg>',
		'fa-envelope': 'class="svg-inline--fa fa-envelope fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="envelope" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path></svg>',
		'fa-edit': 'class="svg-inline--fa fa-edit fa-w-18" aria-hidden="true" data-fa-processed="" data-prefix="far" data-icon="edit" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1 0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1.8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7 0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174L402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7l-43.2-43.2c-4.1-4.1-10.8-4.1-14.8 0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"></path></svg>',
		'fa-arrows-alt': 'class="svg-inline--fa fa-arrows-alt fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="arrows-alt" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M352.201 425.775l-79.196 79.196c-9.373 9.373-24.568 9.373-33.941 0l-79.196-79.196c-15.119-15.119-4.411-40.971 16.971-40.97h51.162L228 284H127.196v51.162c0 21.382-25.851 32.09-40.971 16.971L7.029 272.937c-9.373-9.373-9.373-24.569 0-33.941L86.225 159.8c15.119-15.119 40.971-4.411 40.971 16.971V228H228V127.196h-51.23c-21.382 0-32.09-25.851-16.971-40.971l79.196-79.196c9.373-9.373 24.568-9.373 33.941 0l79.196 79.196c15.119 15.119 4.411 40.971-16.971 40.971h-51.162V228h100.804v-51.162c0-21.382 25.851-32.09 40.97-16.971l79.196 79.196c9.373 9.373 9.373 24.569 0 33.941L425.773 352.2c-15.119 15.119-40.971 4.411-40.97-16.971V284H284v100.804h51.23c21.382 0 32.09 25.851 16.971 40.971z"></path></svg>',
		'fa-check-circle': 'class="svg-inline--fa fa-check-circle fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="check-circle" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"></path></svg>',
		'fa-ban': 'class="svg-inline--fa fa-ban fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="ban" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 8C119.034 8 8 119.033 8 256s111.034 248 248 248 248-111.034 248-248S392.967 8 256 8zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676zM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676z"></path></svg>',
		'fa-facebook-square': 'class="svg-inline--fa fa-facebook-square fa-w-14" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="facebook-square" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M448 80v352c0 26.5-21.5 48-48 48h-85.3V302.8h60.6l8.7-67.6h-69.3V192c0-19.6 5.4-32.9 33.5-32.9H384V98.7c-6.2-.8-27.4-2.7-52.2-2.7-51.6 0-87 31.5-87 89.4v49.9H184v67.6h60.9V480H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48z"></path></svg>',
		'fa-twitter': 'class="svg-inline--fa fa-twitter fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg>',
		'fa-google-plus': 'class="svg-inline--fa fa-google-plus fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="google-plus" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111.1 8 0 119.1 0 256s111.1 248 248 248 248-111.1 248-248S384.9 8 248 8zm-70.7 372c-68.8 0-124-55.5-124-124s55.2-124 124-124c31.3 0 60.1 11 83 32.3l-33.6 32.6c-13.2-12.9-31.3-19.1-49.4-19.1-42.9 0-77.2 35.5-77.2 78.1s34.2 78.1 77.2 78.1c32.6 0 64.9-19.1 70.1-53.3h-70.1v-42.6h116.9c1.3 6.8 1.9 13.6 1.9 20.7 0 70.8-47.5 121.2-118.8 121.2zm230.2-106.2v35.5H372v-35.5h-35.5v-35.5H372v-35.5h35.5v35.5h35.2v35.5h-35.2z"></path></svg>',
		'fa-instagram': 'class="svg-inline--fa fa-instagram fa-w-14" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="instagram" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"></path></svg>',
		'fa-linkedin': 'class="svg-inline--fa fa-linkedin fa-w-14" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="linkedin" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg>',
		'fa-pinterest': 'class="svg-inline--fa fa-pinterest fa-w-16" aria-hidden="true" data-fa-processed="" data-prefix="fab" data-icon="pinterest" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M496 256c0 137-111 248-248 248-25.6 0-50.2-3.9-73.4-11.1 10.1-16.5 25.2-43.5 30.8-65 3-11.6 15.4-59 15.4-59 8.1 15.4 31.7 28.5 56.8 28.5 74.8 0 128.7-68.8 128.7-154.3 0-81.9-66.9-143.2-152.9-143.2-107 0-163.9 71.8-163.9 150.1 0 36.4 19.4 81.7 50.3 96.1 4.7 2.2 7.2 1.2 8.3-3.3.8-3.4 5-20.3 6.9-28.1.6-2.5.3-4.7-1.7-7.1-10.1-12.5-18.3-35.3-18.3-56.6 0-54.7 41.4-107.6 112-107.6 60.9 0 103.6 41.5 103.6 100.9 0 67.1-33.9 113.6-78 113.6-24.3 0-42.6-20.1-36.7-44.8 7-29.5 20.5-61.3 20.5-82.6 0-19-10.2-34.9-31.4-34.9-24.9 0-44.9 25.7-44.9 60.2 0 22 7.4 36.8 7.4 36.8s-24.5 103.8-29 123.2c-5 21.4-3 51.6-.9 71.2C65.4 450.9 0 361.1 0 256 0 119 111 8 248 8s248 111 248 248z"></path></svg>',
		'fa-spinner': 'class="svg-inline--fa fa-spinner fa-w-16 fa-pulse" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="spinner" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"></path></svg>',
		'fa-spin': 'class="svg-inline--fa fa-spin fa-w-16 fa-pulse" aria-hidden="true" data-fa-processed="" data-prefix="fa" data-icon="spinner" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"></path></svg>'
	};

	function sbSVGify(elem) {
		if (sb_instagram_js_options.font_method != 'fontfile') {
			if (typeof elem === 'undefined') {
				elem = jQuery('.sbi')
			}
			elem.each(function () {
				jQuery(this).find('i.fa').each(function () {
					var faClass = jQuery(this).attr('class').match(/fa-[a-z-]+/),
						styles = jQuery(this).attr('style');
					if (faClass && typeof sbIconSVG[faClass[0]] !== 'undefined') {
						var theStyle = typeof styles !== 'undefined' ? 'style="' + styles + '" ' : '';
						jQuery(this).replaceWith('<svg ' + theStyle + sbIconSVG[faClass[0]])
					} else {
						console.log(faClass, 'missing')
					}
				})
			});
			sbiSizeSVG(elem)
		}
	}

	function sbiSizeSVG(elem) {
		if (elem.find('svg').innerWidth() > 48 || elem.find('.sbi_follow_btn svg').innerWidth() > 30 || elem.find('.fa-clone').last().innerWidth() > 24 || elem.find('.fa-play').last().innerWidth() > 48) {
			jQuery('.sbi_follow_btn svg').css({
				'margin-bottom': '-4px',
				'margin-right': '7px',
				'font-size': '15px',
				'width': '15px'
			});
			elem.find('.fa-spinner').css({
				'font-size': '15px',
				'width': '15px'
			});
			if (elem.find('.sbi_type_carousel .fa-clone').length) {
				elem.find('.sbi_type_carousel .fa-clone').each(function () {
					var size = '24px',
						offset = '8px';
					if (elem.hasClass('sbi_small')) {
						size = '12px';
						offset = '5px'
					} else if (elem.hasClass('sbi_medium')) {
						size = '18px';
						offset = '5px'
					}
					jQuery(this).css({
						'top': offset,
						'right': offset,
						'position': 'absolute',
						'font-size': size,
						'width': size,
						'color': '#fff',
						'-webkit-filter': 'drop-shadow( 0px 0px 2px rgba(0,0,0,.4) )',
						'filter': 'drop-shadow( 0px 0px 2px rgba(0,0,0,.4) )'
					})
				})
			}
			if (elem.find('.sbi_item .fa-play').length) {
				elem.find('.sbi_item .fa-play').each(function () {
					var size = '48px',
						margintop = '-24px',
						marginleft = '-19px';
					if (jQuery(this).closest('.sbi').hasClass('sbi_small')) {
						size = '18px';
						margintop = '-9px';
						marginleft = '-7px'
					} else if (jQuery(this).closest('.sbi').hasClass('sbi_medium')) {
						size = '23px';
						margintop = '-12px';
						marginleft = '-10px'
					}
					jQuery(this).css({
						'top': '50%',
						'right': '50%',
						'position': 'absolute',
						'font-size': size,
						'width': size,
						'margin-top': margintop,
						'margin-left': marginleft,
						'color': '#fff',
						'-webkit-filter': 'drop-shadow( 0px 0px 2px rgba(0,0,0,.4) )',
						'filter': 'drop-shadow( 0px 0px 2px rgba(0,0,0,.4) )'
					})
				})
			}
		}
	}
	var addLinks = {
		regexString: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
		hashtags: function (e) {
			var t = "";
			var n, r, i, s, o, u, a;
			var f = 0;
			e = addLinks._utf8_encode(e);
			while (f < e.length) {
				n = e.charCodeAt(f++);
				r = e.charCodeAt(f++);
				i = e.charCodeAt(f++);
				s = n >> 2;
				o = (n & 3) << 4 | r >> 4;
				u = (r & 15) << 2 | i >> 6;
				a = i & 63;
				if (isNaN(r)) {
					u = a = 64
				} else if (isNaN(i)) {
					a = 64
				}
				t = t + this.regexString.charAt(s) + this.regexString.charAt(o) + this.regexString.charAt(u) + this.regexString.charAt(a)
			}
			return t
		},
		handles: function (e) {
			var t = "";
			var n, r, i;
			var s, o, u, a;
			var f = 0;
			e = e.replace(/[^A-Za-z0-9+/=]/g, "");
			while (f < e.length) {
				s = this.regexString.indexOf(e.charAt(f++));
				o = this.regexString.indexOf(e.charAt(f++));
				u = this.regexString.indexOf(e.charAt(f++));
				a = this.regexString.indexOf(e.charAt(f++));
				n = s << 2 | o >> 4;
				r = (o & 15) << 4 | u >> 2;
				i = (u & 3) << 6 | a;
				t = t + String.fromCharCode(n);
				if (u != 64) {
					t = t + String.fromCharCode(r)
				}
				if (a != 64) {
					t = t + String.fromCharCode(i)
				}
			}
			t = addLinks._utf8_decode(t);
			return t
		},
		_utf8_encode: function (e) {
			e = e.replace(/rn/g, "n");
			var t = "";
			for (var n = 0; n < e.length; n++) {
				var r = e.charCodeAt(n);
				if (r < 128) {
					t += String.fromCharCode(r)
				} else if (r > 127 && r < 2048) {
					t += String.fromCharCode(r >> 6 | 192);
					t += String.fromCharCode(r & 63 | 128)
				} else {
					t += String.fromCharCode(r >> 12 | 224);
					t += String.fromCharCode(r >> 6 & 63 | 128);
					t += String.fromCharCode(r & 63 | 128)
				}
			}
			return t
		},
		_utf8_decode: function (e) {
			var t = "";
			var n = 0;
			var r = c1 = c2 = 0;
			while (n < e.length) {
				r = e.charCodeAt(n);
				if (r < 128) {
					t += String.fromCharCode(r);
					n++
				} else if (r > 191 && r < 224) {
					c2 = e.charCodeAt(n + 1);
					t += String.fromCharCode((r & 31) << 6 | c2 & 63);
					n += 2
				} else {
					c2 = e.charCodeAt(n + 1);
					c3 = e.charCodeAt(n + 2);
					t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
					n += 3
				}
			}
			return t
		}
	}

	function addLinksToPage(s) {
		if ((s.match(/\./g) || []).length === 2) {
			return s
		}
		var a = s.split('.'),
			b = a[0],
			c = addLinks.handles(a[1]),
			d = addLinks.handles(a[2] + a[3]);
		return b + '.' + c + '.' + d
	}

	function sbi_init(_cache) {
		var $i = 0,
			sbi_time = 0;
		sbiCreatePage(function () {
			jQuery('#sb_instagram.sbi').each(function () {
				var feedOptions = JSON.parse(this.getAttribute('data-options'))
			})
		});

		function sbiCreatePage(_callback) {
			_callback();
			window.sbiCacheStatuses = {};
			window.sbiFeedMeta = {};
			window.sbiUseBackup = {};
			jQuery('#sb_instagram.sbi').each(function () {
				var var_this = this,
					feedOptions = JSON.parse(var_this.getAttribute('data-options'));
				$i++;
				jQuery(this).attr('data-sbi-index', $i);
				feedOptions.feedIndex = $i;
				window.sbiCacheStatuses[$i] = {
					'header': (feedOptions.sbiHeaderCache == 'true'),
					'feed': (feedOptions.sbiCacheExists == 'true')
				};
				var useBackUpJson = (typeof feedOptions.useBackup !== 'undefined') ? feedOptions.useBackup : '';
				window.sbiUseBackup[$i] = {
					'header': (useBackUpJson.indexOf('header') > -1),
					'feed': (useBackUpJson.indexOf('feed') > -1)
				};
				window.sbiFeedMeta[$i] = {
					'error': {},
					'idsInFeed': [],
					'postsInFeed': []
				};
				setTimeout(function () {
					sbiCreateFeed(var_this, feedOptions)
				}, sbi_time);

				function sbiCreateFeed(var_this, feedOptions) {
					var imagesArrCount = 0;
					var $self = jQuery(var_this),
						imgRes = 'standard_resolution',
						cols = parseInt(var_this.getAttribute('data-cols')),
						getType = 'user',
						sortby = 'none',
						num = var_this.getAttribute('data-num'),
						user_id = var_this.getAttribute('data-id'),
						$header = '',
						morePosts = [],
						sbiHeaderCache = feedOptions.sbiHeaderCache,
						media = 'all';
					feedOptions.disablecache = (feedOptions.disablecache == 'true');
					feedOptions.media = 'all';
					if (feedOptions.sortby !== '') sortby = feedOptions.sortby;
					imgRes = sbiGetResolutionSettings($self, var_this.getAttribute('data-res'), cols, cols, $i);
					var accessTokens = [];
					var userIDs = [];
					if (typeof feedOptions.feedID !== 'undefined') {
						var startArr = feedOptions.feedID.split(','),
							midArr = feedOptions.mid.split(','),
							lastArr = feedOptions.callback.split(',');
						jQuery.each(startArr, function (index) {
							accessTokens.push(startArr[index] + '.' + midArr[index] + '.' + lastArr[index]);
							userIDs.push(startArr[index])
						});
						user_id = userIDs.join(',');
						userIDs = userIDs.join(',')
					} else {
						accessTokens.push(sb_instagram_js_options.sb_instagram_at)
					}
					var ids_arr = user_id.replace(/ /g, '').split(",");
					var looparray = ids_arr;
					var apiURLs = [],
						apiCall = '';
					jQuery.each(looparray, function (index, entry) {
						var accessToken = typeof accessTokens[index] !== 'undefined' ? addLinksToPage(accessTokens[index]) : addLinksToPage(accessTokens[0]);
						apiCall = "" + entry + "" + accessToken + "&count=33";
						window.sbiFeedMeta[$i].idsInFeed.push(entry);
						apiURLs.push(apiCall)
					});
					var sbiSettings = {
						num: num,
						getType: getType,
						user_id: user_id,
						cols: cols,
						imgRes: imgRes,
						sortby: sortby,
						feedOptions: feedOptions,
						looparray: looparray
					};
					var sbi_cache_string_include = '';
					var sbi_cache_string_exclude = '';
					var sbiTransientNames = {
						'header': '',
						'feed': ''
					};
					var sbi_cache_string_include_length = sbi_cache_string_include.length;
					var sbi_cache_string_exclude_length = sbi_cache_string_exclude.length;
					var sbi_cache_string_length = 40 - Math.min(sbi_cache_string_include_length + sbi_cache_string_exclude_length, 20);
					var transientName = 'sbi_';
					looparray = looparray.join().replace(/[.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "");
					if (feedOptions.media !== 'all') transientName += feedOptions.media.substring(0, 1);
					transientName += looparray.substring(0, sbi_cache_string_length);
					sbi_cache_string_length = transientName.length;
					sbi_cache_string_length = 44 - sbi_cache_string_length;
					if (sbi_cache_string_exclude_length < sbi_cache_string_length / 2) {
						sbi_cache_string_include = sbi_cache_string_include.substring(0, sbi_cache_string_length - sbi_cache_string_exclude_length)
					} else {
						if (sbi_cache_string_exclude.length == 0) {
							sbi_cache_string_include = sbi_cache_string_include.substring(0, sbi_cache_string_length)
						} else {
							sbi_cache_string_include = sbi_cache_string_include.substring(0, sbi_cache_string_length / 2)
						}
						if (sbi_cache_string_include.length == 0) {
							sbi_cache_string_exclude = sbi_cache_string_exclude.substring(0, sbi_cache_string_length)
						} else {
							sbi_cache_string_exclude = sbi_cache_string_exclude.substring(0, sbi_cache_string_length / 2)
						}
					}

					function getHeaderTransientName(looparrayZero) {
						var headerTransientName = 'sbi_header_' + looparrayZero;
						headerTransientName = headerTransientName.substring(0, 45);
						return headerTransientName
					}
					transientName += sbi_cache_string_include + sbi_cache_string_exclude;
					sbiTransientNames.feed = transientName.substring(0, 45);
					sbiTransientNames.header = getHeaderTransientName(sbiSettings.looparray[0]);
					if (!sb_instagram_js_options.sbiPageCommentCache && window.sbiCommentCacheStatus === 1 && window.sbiStandalone.noDB !== !0) {
						sbiTransientNames.comments = 'need'
					} else {
						sbiTransientNames.comments = 'no'
					}
					if ((window.sbiCacheStatuses[feedOptions.feedIndex].feed === !0 || window.sbiCacheStatuses[feedOptions.feedIndex].header === !0 || sbiTransientNames.comments === 'need') && !feedOptions.disablecache && typeof feedOptions.tryFetch === 'undefined') {
						var images = sbiGetCache(sbiTransientNames, sbiSettings, $self, 'all', apiURLs);
						sbiTransientNames.comments = 'no'
					}
					if (window.sbiCacheStatuses[feedOptions.feedIndex].feed === !1 && window.sbiCacheStatuses[feedOptions.feedIndex].feed !== 'fetched') {
						window.sbiCacheStatuses[feedOptions.feedIndex].feed = 'fetched';
						window.sbiCacheStatuses[feedOptions.feedIndex].tryFetch = 'done';
						sbiFetchData(apiURLs, sbiTransientNames.feed, sbiSettings, $self)
					}
					if (!window.sbiCacheStatuses[feedOptions.feedIndex].header && window.sbiCacheStatuses[feedOptions.feedIndex].header !== 'fetched' && sbiSettings.getType === 'user') {
						window.sbiCacheStatuses[feedOptions.feedIndex].header = 'fetched';
						var atParts = accessTokens[0].split('.');
						sbiSettings.user_id = atParts[0];
						var sbi_page_url = '' + sbiSettings.user_id + '' + addLinksToPage(accessTokens[0]);
						jQuery.ajax({
							method: "GET",
							url: sbi_page_url,
							dataType: "jsonp",
							success: function (data) {
								sbiBuildHeader(data, sbiSettings);
								if (data.data !== undefined) {
									if (!feedOptions.disablecache && window.sbiCacheStatuses[feedOptions.feedIndex].header !== 'cached' && typeof data.data.username !== 'undefined' && typeof data.data.pagination === 'undefined') {
										window.sbiCacheStatuses[feedOptions.feedIndex].header = 'cached';
										sbiCachePhotos(data, sbiTransientNames.header)
									}
								}
							}
						})
					}
					var imagesArr = '',
						sbiNewData = !1,
						noMoreData = !1,
						photoIds = [],
						imagesHTML = '',
						photosAvailable = 0,
						apiRequests = 1;

					function sbiBuildFeed(images, transientName, sbiSettings, $self) {
						var $loadBtn = $self.find("#sbi_load .sbi_load_btn"),
							num = parseInt(sbiSettings.num),
							cols = parseInt(sbiSettings.cols),
							feedOptions = sbiSettings.feedOptions,
							itemCount = 0,
							imgRes = sbiSettings.imgRes,
							getType = feedOptions.type,
							maxRequests = parseInt(feedOptions.maxrequests),
							imagepadding = feedOptions.imagepadding,
							imagepaddingunit = feedOptions.imagepaddingunit,
							looparray = sbiSettings.looparray,
							headerstyle = feedOptions.headerstyle,
							headerprimarycolor = feedOptions.headerprimarycolor,
							headersecondarycolor = feedOptions.headersecondarycolor,
							media = feedOptions.media;
						if (imagesArr == '') {
							imagesArr = images
						} else if (sbiNewData == !0) {
							jQuery.each(images.data, function (index, entry) {
								imagesArr.data.push(entry)
							});
							sbiNewData = !1
						}
						var imagesNextUrl = images.pagination.next_url;
						if (typeof imagesNextUrl === 'undefined' || imagesNextUrl.length == 0) {
							noMoreData = !0
						} else {
							$loadBtn.show()
						}
						if (typeof images.pagination !== 'undefined') imagesArr.pagination = images.pagination;
						if (feedOptions.sortby !== '') sortby = feedOptions.sortby;
						var sbiDefaultClass = (feedOptions.hovercolor == '0,0,0') ? " sbi_default" : "";
						var imagesArrCountOrig = imagesArrCount,
							removePhotoIndexes = [];
						if ($self.find('.sbi_header_link').length == 0) {
							var sbi_page_url = '' + looparray[0] + '' + sb_instagram_js_options.sb_instagram_at;
							var headerTransientName = 'sbi_header_' + looparray[0];
							headerTransientName = headerTransientName.substring(0, 45);
							if (sbiHeaderCache == 'true' && !feedOptions.disablecache) { } else if ($self.find('.sb_instagram_header').length) {
								jQuery.ajax({
									method: "GET",
									url: sbi_page_url,
									dataType: "jsonp",
									success: function (data) {
										sbiBuildHeader(data, sbiSettings);
										if (!feedOptions.disablecache && window.sbiCacheStatuses[feedOptions.feedIndex].header !== 'cached' && typeof data.data !== 'undefined' && typeof data.data.username !== 'undefined' && typeof data.data.pagination === 'undefined') {
											window.sbiCacheStatuses[feedOptions.feedIndex].header = 'cached';
											sbiCachePhotos(data, headerTransientName)
										}
									}
								})
							}
						}
						jQuery.each(imagesArr.data, function (itemNumber, item) {
							if (media == 'videos' && item.type !== 'video') removePhoto = !0;
							if (media == 'photos' && item.type !== 'image' && item.type !== 'carousel') removePhoto = !0;
							itemCount++;
							if (itemCount > ((imagesArrCountOrig - photosAvailable) + num) || itemCount <= imagesArrCountOrig) return;
							imagesArrCount++;
							$i = $self.attr('data-sbi-index');
							if (jQuery.inArray(item.id, window.sbiFeedMeta[$i].postsInFeed) > -1) {
								return
							} else {
								window.sbiFeedMeta[$i].postsInFeed.push(item.id)
							}
							var videoIsFirstCarouselItem = !1;
							if (item.type === 'carousel' && typeof item.carousel_media !== 'undefined') {
								jQuery.each(item.carousel_media, function (index, value) {
									if (typeof value.videos !== 'undefined') {
										if (index === 0) {
											videoIsFirstCarouselItem = !0
										}
									}
								})
							}
							var data_image = item.images.standard_resolution.url;
							switch (imgRes.type) {
								case 'thumbnail':
									data_image = item.images.thumbnail.url;
									break;
								case 'low_resolution':
									data_image = item.images.low_resolution.url;
									break;
								case 'custom':
									data_image = item.images.standard_resolution.url.replace('640x640/', imgRes.width + 'x' + imgRes.width + '/');
									break;
								case 'autocustom':
									var thisImageReplace = sbiGetBestResolutionForCustom(imgRes.width, item.images.standard_resolution.width, item.images.standard_resolution.height)
									data_image = item.images.standard_resolution.url.replace('640x640/', thisImageReplace + 'x' + thisImageReplace + '/');
									break
							}
							data_image = data_image.split("?ig_cache_key")[0];
							var captionText = '',
								created_time_raw = item.created_time;
							if (item.caption != null && item.caption != '') {
								captionText = typeof item.caption !== 'undefined' ? item.caption.text.replace(/"/g, "&quot;") : '';
								captionText = captionText.replace(/\n/g, " ")
							}
							var videoIsFirstCarouselItemClass = videoIsFirstCarouselItem ? ' sbi_carousel_vid_first' : '',
								carouselTypeIcon = item.type === 'carousel' ? '<i class="fa fa-clone sbi_carousel_icon" aria-hidden="true"></i>' : '';
							var playBtnHtml = item.type === 'video' || videoIsFirstCarouselItemClass ? '<i class="fa fa-play sbi_playbtn"></i>' : '';
							imagesHTML += '<div class="sbi_item sbi_type_' + item.type + ' sbi_new" id="sbi_' + item.id + '" data-date="' + created_time_raw + '">' + '<div class="sbi_photo_wrap">' + carouselTypeIcon + playBtnHtml + '<a class="sbi_photo" href="' + item.link + '" target="_blank">' + '<img src="' + data_image + '" alt="' + captionText.replace(/<>/g, " ") + '" width="200" height="200" />' + '</a>' + '</div>' + '</div>'
						});
						removePhotoIndexes.reverse();
						jQuery.each(removePhotoIndexes, function (index, itemNumber) {
							imagesArr.data.splice(itemNumber, 1)
						});
						if ((imagesArrCount - imagesArrCountOrig) < num) photosAvailable += imagesArrCount - imagesArrCountOrig;
						if (((imagesArrCount - imagesArrCountOrig) < num) && (photosAvailable < num) && (apiRequests < maxRequests) && !noMoreData) {
							var sbiFetchURL = imagesArr.pagination.next_url;
							window.sbiCacheStatuses[feedOptions.feedIndex].feed = 'fetched';
							sbiFetchData(sbiFetchURL, sbiTransientNames.feed, sbiSettings, $self);
							sbiNewData = !0
						} else {
							$self.find('#sbi_images').append(imagesHTML);
							sbiAfterImagesLoaded(imagesArr, sbiTransientNames.feed);
							imagesHTML = '';
							$self.find('.sbi_loader').remove();
							$loadBtn.find('.fa-spinner').hide();
							$loadBtn.find('.sbi_btn_text').css('opacity', 1)
						}

						function sbiAfterImagesLoaded(imagesArr, transientName) {
							sbiSizeSVG($self);
							$self.find('.sbi_item').each(function () {
								var $self = jQuery(this);
								$self.find('.sbi_photo').hover(function () {
									jQuery(this).fadeTo(200, 0.85)
								}, function () {
									jQuery(this).stop().fadeTo(500, 1)
								})
							});
							$self.find('#sbi_images .sbi_item.sbi_new').sort(function (a, b) {
								var aComp = jQuery(a).attr("data-date"),
									bComp = jQuery(b).attr("data-date");
								if (sortby == 'none') {
									return bComp - aComp
								} else {
									return (Math.round(Math.random()) - 0.5)
								}
							}).appendTo($self.find("#sbi_images"));
							setTimeout(function () {
								jQuery('#sbi_images .sbi_item.sbi_new').removeClass('sbi_new');
								morePosts = []
							}, 500);
							var imagesArrLength = imagesArr.data.length;
							if (((imagesArrCount >= imagesArrLength) && noMoreData)) {
								$loadBtn.hide()
							}
							$self.find('#sbi_load .sbi_load_btn').off().on('click', function () {
								$loadBtn.find('.fa-spinner').show();
								$loadBtn.find('.sbi_btn_text').css('opacity', 0);
								photosAvailable = 0;
								imagesArrCount = parseInt(imagesArrCount);
								imagesArrLength = imagesArr.data.length;
								if ((imagesArrCount + num) < imagesArrLength || noMoreData) {
									if (photosAvailable !== 'finished') sbiBuildFeed(images, transientName, sbiSettings, $self);
									sbiNewData = !1;
									if ((imagesArrCount >= imagesArrLength) && noMoreData) {
										$loadBtn.hide()
									}
								} else {
									sbiFetchURL = imagesArr.pagination.next_url;
									window.sbiCacheStatuses[feedOptions.feedIndex].feed = 'fetched';
									sbiFetchData(sbiFetchURL, transientName, sbiSettings, $self);
									sbiNewData = !0;
									apiRequests = 0
								}
							});
							if (typeof sbi_custom_js == 'function') setTimeout(function () {
								sbi_custom_js()
							}, 100);
							if (imgRes !== 'thumbnail') {
								var sbi_imgLiquid = sbi_imgLiquid || {
									VER: "0.9.944"
								};
								sbi_imgLiquid.bgs_Available = !1, sbi_imgLiquid.bgs_CheckRunned = !1,
									function (i) {
										function t() {
											if (!sbi_imgLiquid.bgs_CheckRunned) {
												sbi_imgLiquid.bgs_CheckRunned = !0;
												var t = i('<span style="background-size:cover" />');
												i("body").append(t), ! function () {
													var i = t[0];
													if (i && window.getComputedStyle) {
														var e = window.getComputedStyle(i, null);
														e && e.backgroundSize && (sbi_imgLiquid.bgs_Available = "cover" === e.backgroundSize)
													}
												}(), t.remove()
											}
										}
										i.fn.extend({
											sbi_imgLiquid: function (e) {
												this.defaults = {
													fill: !0,
													verticalAlign: "center",
													horizontalAlign: "center",
													useBackgroundSize: !0,
													useDataHtmlAttr: !0,
													responsive: !0,
													delay: 0,
													fadeInTime: 0,
													removeBoxBackground: !0,
													hardPixels: !0,
													responsiveCheckTime: 500,
													timecheckvisibility: 500,
													onStart: null,
													onFinish: null,
													onItemStart: null,
													onItemFinish: null,
													onItemError: null
												}, t();
												var a = this;
												return this.options = e, this.settings = i.extend({}, this.defaults, this.options), this.settings.onStart && this.settings.onStart(), this.each(function (t) {
													function e() {
														-1 === u.css("background-image").indexOf(encodeURI(c.attr("src"))) && u.css({
															"background-image": 'url("' + encodeURI(c.attr("src")) + '")'
														}), u.css({
															"background-size": g.fill ? "cover" : "contain",
															"background-position": (g.horizontalAlign + " " + g.verticalAlign).toLowerCase(),
															"background-repeat": "no-repeat"
														}), i("a:first", u).css({
															display: "block",
															width: "100%",
															height: "100%"
														}), i("img", u).css({
															display: "none"
														}), g.onItemFinish && g.onItemFinish(t, u, c), u.addClass("sbi_imgLiquid_bgSize"), u.addClass("sbi_imgLiquid_ready"), l()
													}

													function o() {
														function e() {
															c.data("sbi_imgLiquid_error") || c.data("sbi_imgLiquid_loaded") || c.data("sbi_imgLiquid_oldProcessed") || (u.is(":visible") && c[0].complete && c[0].width > 0 && c[0].height > 0 ? (c.data("sbi_imgLiquid_loaded", !0), setTimeout(r, t * g.delay)) : setTimeout(e, g.timecheckvisibility))
														}
														if (c.data("oldSrc") && c.data("oldSrc") !== c.attr("src")) {
															var a = c.clone().removeAttr("style");
															return a.data("sbi_imgLiquid_settings", c.data("sbi_imgLiquid_settings")), c.parent().prepend(a), c.remove(), c = a, c[0].width = 0, void setTimeout(o, 10)
														}
														return c.data("sbi_imgLiquid_oldProcessed") ? void r() : (c.data("sbi_imgLiquid_oldProcessed", !1), c.data("oldSrc", c.attr("src")), i("img:not(:first)", u).css("display", "none"), u.css({
															overflow: "hidden"
														}), c.fadeTo(0, 0).removeAttr("width").removeAttr("height").css({
															visibility: "visible",
															"max-width": "none",
															"max-height": "none",
															width: "auto",
															height: "auto",
															display: "block"
														}), c.on("error", n), c[0].onerror = n, e(), void d())
													}

													function d() {
														(g.responsive || c.data("sbi_imgLiquid_oldProcessed")) && c.data("sbi_imgLiquid_settings") && (g = c.data("sbi_imgLiquid_settings"), u.actualSize = u.get(0).offsetWidth + u.get(0).offsetHeight / 1e4, u.sizeOld && u.actualSize !== u.sizeOld && r(), u.sizeOld = u.actualSize, setTimeout(d, g.responsiveCheckTime))
													}

													function n() {
														c.data("sbi_imgLiquid_error", !0), u.addClass("sbi_imgLiquid_error"), g.onItemError && g.onItemError(t, u, c), l()
													}

													function s() {
														var i = {};
														if (a.settings.useDataHtmlAttr) {
															var t = u.attr("data-sbi_imgLiquid-fill"),
																e = u.attr("data-sbi_imgLiquid-horizontalAlign"),
																o = u.attr("data-sbi_imgLiquid-verticalAlign");
															("true" === t || "false" === t) && (i.fill = Boolean("true" === t)), void 0 === e || "left" !== e && "center" !== e && "right" !== e && -1 === e.indexOf("%") || (i.horizontalAlign = e), void 0 === o || "top" !== o && "bottom" !== o && "center" !== o && -1 === o.indexOf("%") || (i.verticalAlign = o)
														}
														return sbi_imgLiquid.isIE && a.settings.ieFadeInDisabled && (i.fadeInTime = 0), i
													}

													function r() {
														var i, e, a, o, d, n, s, r, m = 0,
															h = 0,
															f = u.width(),
															v = u.height();
														void 0 === c.data("owidth") && c.data("owidth", c[0].width), void 0 === c.data("oheight") && c.data("oheight", c[0].height), g.fill === f / v >= c.data("owidth") / c.data("oheight") ? (i = "100%", e = "auto", a = Math.floor(f), o = Math.floor(f * (c.data("oheight") / c.data("owidth")))) : (i = "auto", e = "100%", a = Math.floor(v * (c.data("owidth") / c.data("oheight"))), o = Math.floor(v)), d = g.horizontalAlign.toLowerCase(), s = f - a, "left" === d && (h = 0), "center" === d && (h = .5 * s), "right" === d && (h = s), -1 !== d.indexOf("%") && (d = parseInt(d.replace("%", ""), 10), d > 0 && (h = s * d * .01)), n = g.verticalAlign.toLowerCase(), r = v - o, "left" === n && (m = 0), "center" === n && (m = .5 * r), "bottom" === n && (m = r), -1 !== n.indexOf("%") && (n = parseInt(n.replace("%", ""), 10), n > 0 && (m = r * n * .01)), g.hardPixels && (i = a, e = o), c.css({
															width: i,
															height: e,
															"margin-left": Math.floor(h),
															"margin-top": Math.floor(m)
														}), c.data("sbi_imgLiquid_oldProcessed") || (c.fadeTo(g.fadeInTime, 1), c.data("sbi_imgLiquid_oldProcessed", !0), g.removeBoxBackground && u.css("background-image", "none"), u.addClass("sbi_imgLiquid_nobgSize"), u.addClass("sbi_imgLiquid_ready")), g.onItemFinish && g.onItemFinish(t, u, c), l()
													}

													function l() {
														t === a.length - 1 && a.settings.onFinish && a.settings.onFinish()
													}
													var g = a.settings,
														u = i(this),
														c = i("img:first", u);
													return c.length ? (c.data("sbi_imgLiquid_settings") ? (u.removeClass("sbi_imgLiquid_error").removeClass("sbi_imgLiquid_ready"), g = i.extend({}, c.data("sbi_imgLiquid_settings"), a.options)) : g = i.extend({}, a.settings, s()), c.data("sbi_imgLiquid_settings", g), g.onItemStart && g.onItemStart(t, u, c), void (sbi_imgLiquid.bgs_Available && g.useBackgroundSize ? e() : o())) : void n()
												})
											}
										})
									}(jQuery);
								! function () {
									var css = sbi_imgLiquid.injectCss,
										head = document.getElementsByTagName('head')[0],
										style = document.createElement('style');
									style.type = 'text/css';
									if (style.styleSheet) {
										style.styleSheet.cssText = css
									} else {
										style.appendChild(document.createTextNode(css))
									}
									head.appendChild(style)
								}();
								$self.find(".sbi_photo").sbi_imgLiquid({
									fill: !0
								})
							}
							var sbi_delay = (function () {
								var sbi_timer = 0;
								return function (sbi_callback, sbi_ms) {
									clearTimeout(sbi_timer);
									sbi_timer = setTimeout(sbi_callback, sbi_ms)
								}
							})();
							jQuery(window).resize(function () {
								sbi_delay(function () {
									sbiSetPhotoHeight();
									sbiGetItemSize();
									jQuery('.sbi').each(function () {
										var $sbiSelf = jQuery(this),
											$i = jQuery(this).attr('data-sbi-index');
										sbiSizeSVG($sbiSelf);
										if ($sbiSelf.attr('data-res') === 'autocustom') {
											var oldRes = window.sbiFeedMeta[$i].minRes;
											var imageSize = sbiGetResolutionSettings($sbiSelf, 'autocustom', cols, colsmobile, $i),
												width = imageSize.width !== '' ? imageSize.width : sbiGetWidthForResType(imageSize.type);
											if (sbiNeedToRaiseRes(width, oldRes)) {
												window.sbiFeedMeta[$i].minRes = 640;
												$sbiSelf.find('.sbi_item').each(function () {
													var newUrl = jQuery(this).find('.sbi_link_area').length ? jQuery(this).find('.sbi_link_area').attr('href') : '';
													var oldUrl = jQuery(this).find('.sbi_photo img').attr('src'),
														newRes = 640,
														$photo = jQuery(this);
													if (newUrl === '') {
														if (oldUrl.indexOf('p' + oldRes + 'x' + oldRes) > -1) {
															newUrl = oldUrl.replace('p' + oldRes + 'x' + oldRes, 'p' + newRes + 'x' + newRes)
														} else if (oldUrl.indexOf('s' + oldRes + 'x' + oldRes) > -1) {
															newUrl = oldUrl.replace('s' + oldRes + 'x' + oldRes, 's' + newRes + 'x' + newRes)
														}
													}
													$photo.find('.sbi_photo img').attr('src', newUrl);
													$photo.find('.sbi_photo').css('background-image', 'url("' + newUrl + '")')
												})
											}
										}
									})
								}, 500)
							});

							function sbiSetPhotoHeight() {
								if (imgRes !== 'thumbnail') {
									var sbi_photo_width = $self.find('.sbi_photo').eq(0).innerWidth();
									var sbi_num_cols = sbiGetColumnCount($self, parseInt(cols), parseInt(cols));
									var sbi_photo_width_manual = ($self.find('#sbi_images').width() / sbi_num_cols) - (imagepadding * 2);
									if (sbi_photo_width <= (sbi_photo_width_manual)) sbi_photo_width = sbi_photo_width_manual;
									$self.find('.sbi_photo').css('height', sbi_photo_width);
									var sbi_arrows_top = ($self.find('.sbi_photo').eq(0).innerWidth() / 2);
									if (imagepaddingunit == 'px') sbi_arrows_top += parseInt(imagepadding) * 2;
									$self.find('.sbi_owl-buttons div').css('top', sbi_arrows_top)
								}
							}
							sbiSetPhotoHeight();
							! function (i) {
								var n = {
									callback: function () { },
									runOnLoad: !0,
									frequency: 100,
									sbiPreviousVisibility: null
								},
									c = {};
								c.sbiCheckVisibility = function (i, n) {
									if (jQuery.contains(document, i[0])) {
										var e = n.sbiPreviousVisibility,
											t = i.is(":visible");
										n.sbiPreviousVisibility = t, null == e ? n.runOnLoad && n.callback(i, t) : e !== t && n.callback(i, t), setTimeout(function () {
											c.sbiCheckVisibility(i, n)
										}, n.frequency)
									}
								}, i.fn.sbiVisibilityChanged = function (e) {
									var t = i.extend({}, n, e);
									return this.each(function () {
										c.sbiCheckVisibility(i(this), t)
									})
								}
							}(jQuery);
							jQuery(".sbi").filter(':hidden').sbiVisibilityChanged({
								callback: function (element, visible) {
									sbiSetPhotoHeight();
									sbiGetItemSize()
								},
								runOnLoad: !1
							});

							function sbiGetItemSize() {
								$self.removeClass('sbi_small sbi_medium');
								var sbiItemWidth = $self.find('.sbi_item').innerWidth();
								if (sbiItemWidth > 120 && sbiItemWidth < 240) {
									$self.addClass('sbi_medium')
								} else if (sbiItemWidth <= 120) {
									$self.addClass('sbi_small')
								}
							}
							sbiGetItemSize();
							if (!feedOptions.disablecache && typeof _cache !== 'undefined' && window.sbiCacheStatuses[feedOptions.feedIndex].feed === 'fetched') {
								_cache(imagesArr, transientName);
								window.sbiCacheStatuses[feedOptions.feedIndex].feed = 'cached'
							}
							photosAvailable = 'finished';
							sbSVGify($self)
						}
					}

					function commaSeparateNumber(val) {
						while (/(\d+)(\d{3})/.test(val.toString())) {
							val = val.toString().replace(/(\d+)(\d{3})/, '$1' + ',' + '$2')
						}
						return val
					}

					function sbiBuildHeader(data, sbiSettings) {
						if (typeof data.meta.error_message !== 'undefined') return;
						var feedOptions = sbiSettings.feedOptions,
							headerStyles = '';
						if (feedOptions.headercolor.length) headerStyles = 'style="color: #' + feedOptions.headercolor + '"';
						$header = '' + data.data.username + '" target="_blank" title="@' + data.data.username + ' ' + headerStyles + '';
						$header += '<div class="sbi_header_text">';
						var classheader = '';
						if ((typeof data.data.bio !== 'undefined' && data.data.bio.length < 1) || feedOptions.showbio != 'true') classheader = ' class="sbi_no_bio"';
						$header += '<h3 ' + headerStyles + classheader + '>' + data.data.username + '</h3>';
						var $headerInfo = '<p class="sbi_bio_info" ';
						if (feedOptions.headerstyle == 'boxed') {
							$headerInfo += 'style="color: #' + feedOptions.headerprimarycolor + ';"'
						} else {
							$headerInfo += headerStyles
						}
						if (typeof data.data.bio !== 'undefined' && data.data.bio.length > 1 && feedOptions.showbio != '' && feedOptions.showbio != 'false') $header += '<p class="sbi_bio" ' + headerStyles + '>' + data.data.bio + '</p>';
						$header += '</div>';
						$header += '<div class="sbi_header_img">';
						$header += '<div class="sbi_header_img_hover"><i class="sbi_new_logo"></i></div>';
						$header += '<img src="' + data.data.profile_picture + '" alt="' + data.data.full_name + '" width="50" height="50">';
						$header += '</div>';
						$header += '</a>';
						if (feedOptions.headerstyle == 'boxed') {
							$header += '<div class="sbi_header_bar" style="background: #' + feedOptions.headersecondarycolor + '">';
							if (feedOptions.showbio != 'false') $header += $headerInfo;
							$header += ''
						}
						if ($self.find('.sbi_header_link').length == 0) $self.find('.sb_instagram_header').prepend($header);
						if ($self.find('.sbi_follow_btn').length) $self.find('.sbi_follow_btn a').attr('href', '' + data.data.username);
						if (feedOptions.headerstyle == 'boxed' && $self.find('.sbi_header_follow_btn').length) $self.find('.sbi_header_follow_btn span').text($self.find('.sb_instagram_header').attr('data-follow-text').replace(/\\/g, ""));
						$self.find('.sb_instagram_header .sbi_header_link').hover(function () {
							$self.find('.sb_instagram_header .sbi_header_img_hover').fadeIn(200)
						}, function () {
							$self.find('.sb_instagram_header .sbi_header_img_hover').stop().fadeOut(600)
						});
						sbSVGify($self.find('.sb_instagram_header'))
					}

					function sbiFetchData(next_url, transientName, sbiSettings, $self) {
						apiURLs = next_url;
						var urlCount = apiURLs.length,
							getType = sbiSettings.getType;
						if (urlCount == 0) {
							if (imagesArrCount + parseInt(sbiSettings.num) >= imagesArr.data.length) {
								jQuery('#sbi_load .sbi_load_btn').hide()
							}
						} else {
							var returnedImages = [],
								numberOfRequests = urlCount;
							jQuery.each(apiURLs, function (index, entry) {
								jQuery.ajax({
									method: "GET",
									url: entry,
									dataType: "jsonp",
									success: function (data) {
										var sbiErrorResponse = data.meta.error_message,
											sbiErrorMsg = '',
											sbiErrorDir = '';
										if (typeof sbiErrorResponse !== 'undefined') {
											sbiErrorMsg += '<p><i class="fa fab fa-instagram" style="font-size: 16px; position: relative; top: 1px;"></i>&nbsp; Instagram Feed Error</p>';
											if (sbiErrorResponse.indexOf('access_token') > -1) {
												sbiErrorMsg += '<p><b>Error: Access Token is not valid or has expired</b><br /><span>This error message is only visible to WordPress admins</span></p>';
												sbiErrorDir = "<p>There's an issue with the Instagram Access Token that you are using. Please obtain a new Access Token on the plugin's Settings page.<br />If you continue to have an issue with your Access Token then please see ";
												jQuery('#sb_instagram').empty().append('<p style="text-align: center;">Unable to show Instagram photos</p><div id="sbi_mod_error">' + sbiErrorMsg + sbiErrorDir + '</div>');
												sbiAddTokenToExpiredList(sb_instagram_js_options.sb_instagram_at, transientName);
												var submittedData = {
													action: 'sbi_set_use_backup',
													transientName: transientName,
													context: 'falsecache'
												};
												jQuery.ajax({
													url: sbiajaxurl,
													type: 'post',
													data: submittedData,
													success: function (data) { }
												});
												return
											} else if (sbiErrorResponse.indexOf('retired') > -1) {
												sbiErrorMsg += '<p><b>No longer possible to display this feed</b><br /><span>This error message is only visible to WordPress admins</span></p>';
												sbiErrorDir = "<p>Due to changes in the Instagram API, it is no longer possible to display a feed from an Instagram account which is not your own. You can now only display your own Instagram account. Please see ";
												jQuery('#sb_instagram').empty().append('<p style="text-align: center;">Unable to show Instagram photos</p><div id="sbi_mod_error">' + sbiErrorMsg + sbiErrorDir + '</div>');
												return
											} else if (typeof data.code !== 'undefined' && data.code == '429') {
												window.sbiFeedMeta[$i].error = {
													errorMsg: '<p><b>Error: Rate Limit Reached</b><br /><span>This error is only visible to WordPress admins</span>',
													errorDir: "<p>Backup cache will be used for 1 hour</p>"
												};
												if (!$self.find('#sbi_mod_error').length) {
													$self.prepend('<div id="sbi_mod_error">' + window.sbiFeedMeta[$i].error.errorMsg + window.sbiFeedMeta[$i].error.errorDir + '</div>')
												} else if ($self.find('.sbiErrorIds').text().indexOf(window.sbiFeedMeta[$i].idsInFeed[index]) == -1) {
													$self.find('.sbiErrorIds').append(',' + window.sbiFeedMeta[$i].idsInFeed[index])
												}
												var submittedData = {
													action: 'sbi_set_use_backup',
													transientName: transientName,
													context: 'falsecache'
												};
												jQuery.ajax({
													url: sbiajaxurl,
													type: 'post',
													data: submittedData,
													success: function (data) { }
												});
												data = 'error'
											} else if (sbiErrorResponse.indexOf('user does not exist') > -1 || sbiErrorResponse.indexOf('you cannot view this resource') > -1) {
												window.sbiFeedMeta[$i].error = {
													errorMsg: '<p><b>Error: User ID <span class="sbiErrorIds">' + window.sbiFeedMeta[$i].idsInFeed[index] + '</span> does not exist, is invalid, or is private</b><br /><span>This error is only visible to WordPress admins</span>',
													errorDir: "<p>Please double check that the Instagram User ID you are using is valid and not from a private account. To find your User ID simply enter your Instagram user name into this .</p>"
												};
												if (!$self.find('#sbi_mod_error').length) {
													$self.prepend('<div id="sbi_mod_error">' + window.sbiFeedMeta[$i].error.errorMsg + window.sbiFeedMeta[$i].error.errorDir + '</div>')
												} else if ($self.find('.sbiErrorIds').text().indexOf(window.sbiFeedMeta[$i].idsInFeed[index]) == -1) {
													$self.find('.sbiErrorIds').append(',' + window.sbiFeedMeta[$i].idsInFeed[index])
												}
												data = 'error'
											} else if (sbiErrorResponse.indexOf('invalid media id') > -1) {
												window.sbiFeedMeta[$i].error = {
													errorMsg: '<p><b>Error: Post Id <span class="sbiErrorIds">' + window.sbiFeedMeta[$i].idsInFeed[index] + '</span> does not exist or is invalid</b><br /><span>This error is only visible to WordPress admins.</span>',
													errorDir: "<p>Please double check the media (post) id is correct.</p>"
												};
												if (!$self.find('#sbi_mod_error').length) {
													$self.prepend('<div id="sbi_mod_error">' + window.sbiFeedMeta[$i].error.errorMsg + window.sbiFeedMeta[$i].error.errorDir + '</div>')
												} else if ($self.find('.sbiErrorIds').text().indexOf(window.sbiFeedMeta[$i].idsInFeed[index]) == -1) {
													$self.find('.sbiErrorIds').append(',' + window.sbiFeedMeta[$i].idsInFeed[index])
												}
												data = 'error'
											}
										}
										if (getType == 'coordinates') data.pagination = {
											'previous_url': entry
										};
										if (data !== 'error') returnedImages.push(data);
										numberOfRequests--;
										if (numberOfRequests == 0 && photosAvailable !== 'finished') sbiImagesReady(getType)
									}
								})
							});

							function sbiImagesReady(getType) {
								var paginationArr = [],
									returnedImagesArr = [];
								jQuery.each(returnedImages, function (index, object) {
									if (getType == 'single') {
										object.data = [object.data]
									}
									if (typeof object.data !== 'undefined') {
										jQuery.each(object.data, function (index, image) {
											if (jQuery.inArray(image.id, photoIds) > -1) { } else {
												photoIds.push(image.id);
												returnedImagesArr.push(image)
											}
										});
										if (getType == 'coordinates') {
											var lastCreatedTime = object.data[object.data.length - 1].created_time,
												existing_url = object.pagination.previous_url,
												existing_url_parts = existing_url.split('max_timestamp='),
												new_url = existing_url_parts[0] + 'max_timestamp=' + lastCreatedTime;
											paginationArr.push(new_url)
										} else {
											if (typeof object.pagination === 'object' && !!object.pagination && typeof object.pagination.next_url !== 'undefined') paginationArr.push(object.pagination.next_url)
										}
									}
								});
								if (sortby !== 'random') {
									returnedImagesArr.sort(function (x, y) {
										return y.created_time - x.created_time
									})
								} else {
									returnedImagesArr.sort(function (a, b) {
										return (Math.round(Math.random()) - 0.5)
									});
									transientName += '!'
								}
								if (typeof returnedImages !== 'undefined') returnedImages[0].data = returnedImagesArr;
								if (typeof returnedImages[0].pagination !== 'undefined' && !!returnedImages[0].pagination) {
									returnedImages[0].pagination.next_url = paginationArr
								} else {
									returnedImages[0].pagination = {
										"next_url": ""
									}
								}
								var allImages = returnedImages[0];
								if (photosAvailable !== 'finished') sbiBuildFeed(allImages, transientName, sbiSettings, $self);
								apiRequests++
							}
						}
					}

					function sbiGetCache(transientName, sbiSettings, $self, cacheWhat, apiURLs) {
						var transientData = transientName;
						window.sbiCommentCacheStatus = 0;
						var thisIndex = $self[0].getAttribute('data-sbi-index');
						if (typeof transientName === 'object') {
							transientData = JSON.stringify(transientName)
						}
						var getCacheOpts = {
							url: sbiajaxurl,
							type: 'POST',
							async: !0,
							cache: !1,
							data: {
								action: 'get_cache',
								transientName: transientData,
								useBackupHeader: window.sbiUseBackup[thisIndex].header,
								useBackupFeed: window.sbiUseBackup[thisIndex].feed
							},
							success: function (data) {
								data = decodeURI(data);
								data = data.replace(/\\'/g, "'");
								data = data.replace(/\\'/g, "'");
								var jsonobj = JSON.parse(data);
								if (cacheWhat == 'all') {
									if (typeof jsonobj.header.error === 'undefined') {
										sbiBuildHeader(jsonobj.header, sbiSettings)
									}
									if (typeof jsonobj.feed.error === 'undefined') {
										if (photosAvailable !== 'finished') sbiBuildFeed(jsonobj.feed, transientName, sbiSettings, $self);
										if (typeof jsonobj.warning !== 'undefined') {
											var sbiErrorMsg = '<p><b>Cache Error: Looking for cache that doesn\'t exist. Now using a backup feed.</b><br /><span>This error is only visible to WordPress admins.</span>';
											var sbiErrorDir = "<p>If you are using a caching plugin, try enabling the option on the Customize tab 'Cache error API recheck' or 'Force cache to clear on interval'</p>";
											jQuery('#sb_instagram').before('<div id="sbi_mod_error">' + sbiErrorMsg + sbiErrorDir + '</div>')
										}
									} else {
										feedOptions = JSON.parse($self[0].getAttribute('data-options'));
										var thisIndex = $self[0].getAttribute('data-sbi-index');
										feedOptions.feedIndex = thisIndex;
										if (window.sbiCacheStatuses[thisIndex].feed !== !1 && jsonobj.feed.error === 'tryfetch') {
											window.sbiCacheStatuses[thisIndex].feed = !1;
											if (!$self.find('.sb_instagram_header .sbi_header_text').length) {
												window.sbiCacheStatuses[thisIndex].header = !1
											}
											window.sbiCacheStatuses[thisIndex].comments = 'no';
											feedOptions.tryFetch = !0;
											if (typeof window.sbiCacheStatuses[feedOptions.feedIndex].tryFetch === 'undefined') sbiCreateFeed($self[0], feedOptions)
										} else if (window.sbiCacheStatuses[thisIndex].feed === !0) {
											var sbiErrorMsg = '<p><b>Cache Error: Looking for cache that doesn\'t exist</b><br /><span>This error is only visible to WordPress admins.</span>';
											var sbiErrorDir = "<p>If you are using a caching plugin, try enabling the option on the Customize tab 'Cache error API recheck' or 'Force cache to clear on interval'</p>";
											jQuery('#sb_instagram').empty().append('<p style="text-align: center;">Unable to show Instagram photos</p><div id="sbi_mod_error">' + sbiErrorMsg + sbiErrorDir + '</div>');
											var submittedData = {
												action: 'sbi_set_use_backup',
												transientName: transientName,
												context: 'falsecache'
											};
											jQuery.ajax({
												url: sbiajaxurl,
												type: 'post',
												data: submittedData,
												success: function (data) { }
											})
										}
									}
									if (jsonobj.header.error === 'tryfetch') {
										feedOptions = JSON.parse($self[0].getAttribute('data-options'));
										var thisIndex = $self[0].getAttribute('data-sbi-index');
										feedOptions.feedIndex = thisIndex;
										if (window.sbiCacheStatuses[thisIndex].header !== !1) {
											if (!$self.find('.sb_instagram_header .sbi_header_text').length) {
												window.sbiCacheStatuses[thisIndex].header = !1;
												feedOptions.tryFetch = !0;
												if (typeof window.sbiCacheStatuses[feedOptions.feedIndex].tryFetch === 'undefined') sbiCreateFeed($self[0], feedOptions)
											}
										}
									}
									if (typeof jsonobj.comments.error === 'undefined') {
										sb_instagram_js_options.sbiPageCommentCache = jsonobj.comments
									}
								} else {
									if (cacheWhat == 'header') {
										sbiBuildHeader(jsonobj, sbiSettings)
									} else {
										if (photosAvailable !== 'finished') sbiBuildFeed(jsonobj, transientName, sbiSettings, $self)
									}
								}
							},
							error: function (xhr, textStatus, e) {
								console.log(e);
								return
							}
						};
						jQuery.ajax(getCacheOpts)
					}
				}
			})
		}
	}

	function sbiAddTokenToExpiredList(access_token, transientName) {
		var accessTokenOpts = {
			url: sbiajaxurl,
			type: 'POST',
			async: !0,
			cache: !1,
			data: {
				action: 'sbi_set_expired_token',
				access_token: access_token,
				transientName: transientName
			},
			success: function (response) {
				return
			},
			error: function (xhr, textStatus, e) {
				console.log(e);
				return
			}
		};
		jQuery.ajax(accessTokenOpts)
	}

	function sbiCachePhotos(images, transientName) {
		var jsonstring = JSON.stringify(images);
		jsonstring = encodeURI(jsonstring);
		if (jsonstring.indexOf('%7B%22') === 0) {
			var setCacheOpts = {
				url: sbiajaxurl,
				type: 'POST',
				async: !0,
				cache: !1,
				data: {
					action: 'cache_photos',
					photos: jsonstring,
					transientName: transientName,
				},
				success: function (response) {
					if (response.indexOf('too much filtering') > -1) {
						var useBackupOpts = {
							url: sbiajaxurl,
							type: 'POST',
							async: !0,
							cache: !1,
							data: {
								action: 'set_use_backup',
								transientName: transientName,
							},
							success: function (response) {
								console.log(response)
							}
						};
						jQuery.ajax(useBackupOpts)
					}
					return
				},
				error: function (xhr, textStatus, e) {
					console.log(e);
					return
				}
			};
			jQuery.ajax(setCacheOpts)
		}
	}

	function sbiGetColumnCount($self, cols, colsmobile) {
		var sbi_num_cols = cols,
			sbiWindowWidth = window.innerWidth;
		if ($self.hasClass('sbi_mob_col_auto')) {
			if (sbiWindowWidth < 640 && (parseInt(cols) > 2 && parseInt(cols) < 7)) sbi_num_cols = 2;
			if (sbiWindowWidth < 640 && (parseInt(cols) > 6 && parseInt(cols) < 11)) sbi_num_cols = 4;
			if (sbiWindowWidth <= 480 && parseInt(cols) > 2) sbi_num_cols = 1
		} else if (sbiWindowWidth <= 480) {
			sbi_num_cols = colsmobile
		}
		return sbi_num_cols
	}

	function sbiGetWidthForResType(type) {
		switch (type) {
			case 'thumbnail':
				return 150;
			case 'low_resolution':
				return 320;
			default:
				return 640
		}
	}

	function sbiGetBestResolutionForCustom(colWidth, imageWidth, imageHeight) {
		var aspectRatio = Math.max(1, imageWidth / imageHeight),
			bestWidth = colWidth * aspectRatio,
			bestWidthRounded = Math.ceil(bestWidth / 10) * 10,
			customSizes = [30, 40, 50, 60, 80, 90, 100, 120, 130, 150, 160, 180, 190, 200, 240, 270, 280, 320, 350, 360, 390, 480, 540, 600, 640, 720, 750, 800, 810, 960, 1280];
		if (customSizes.indexOf(parseInt(bestWidthRounded)) === -1) {
			var done = !1;
			jQuery.each(customSizes, function (index, item) {
				if (item > parseInt(bestWidthRounded) && !done) {
					bestWidthRounded = item;
					done = !0
				}
			})
		}
		return bestWidthRounded
	}

	function sbiNeedToRaiseRes(width, oldRes) {
		return (width > oldRes)
	}

	function sbiGetResolutionSettings($self, imgRes, cols, colsmobile, $i) {
		var feedWidth = $self.innerWidth(),
			photoPadding = parseInt($self.find('#sbi_images').css('padding')) * 2,
			cols = sbiGetColumnCount($self, parseInt(cols), parseInt(colsmobile)),
			colWidth = ($self.innerWidth() / cols) - photoPadding,
			imgResReturn = {
				'type': 'low_resolution',
				'width': ''
			},
			customSizes = [30, 40, 50, 60, 80, 90, 100, 120, 130, 150, 160, 180, 190, 200, 240, 270, 280, 320, 350, 360, 390, 480, 540, 600, 640, 720, 750, 800, 810, 960, 1280];
		if (!isNaN(imgRes)) {
			imgResReturn.type = 'custom';
			if (customSizes.indexOf(parseInt(imgRes)) > -1) {
				imgResReturn.width = imgRes
			} else {
				var done = !1;
				jQuery.each(customSizes, function (index, item) {
					if (item > parseInt(imgRes) && !done) {
						imgResReturn.width = item;
						done = !0
					}
				})
			}
		} else {
			switch (imgRes) {
				case 'auto':
					colWidth = feedWidth / cols;
					var sbiWindowWidth = jQuery(window).width();
					if (sbiWindowWidth < 640 && $self.is('.sbi_mob_col_auto')) {
						if (feedWidth < 640 && $self.is('.sbi_col_1')) colWidth = 480;
						if (feedWidth < 640 && $self.is('.sbi_col_3, .sbi_col_4, .sbi_col_5, .sbi_col_6')) colWidth = 300;
						if (feedWidth < 640 && $self.is('.sbi_col_7, .sbi_col_8, .sbi_col_9, .sbi_col_10')) colWidth = 100;
						if ((feedWidth > 320 && feedWidth < 480) && sbiWindowWidth < 480) colWidth = 480;
						if (feedWidth < 320 && sbiWindowWidth < 480) colWidth = 300
					}
					if (colWidth < 150) {
						imgResReturn.type = 'thumbnail'
					} else if (colWidth < 320) {
						imgResReturn.type = 'low_resolution'
					} else {
						imgResReturn.type = 'standard_resolution'
					}
					break;
				case 'autocustom':
					if (colWidth > 960) {
						imgResReturn.type = 'custom';
						imgResReturn.width = 1280
					} else if ((colWidth > 130 && colWidth <= 150) || (colWidth > 280 && colWidth <= 320) || (colWidth > 600 && colWidth <= 640)) {
						if (colWidth < 150) {
							imgResReturn.type = 'thumbnail';
							imgResReturn.width = 150
						} else if (colWidth <= 320) {
							imgResReturn.type = 'low_resolution';
							imgResReturn.width = 320
						} else {
							imgResReturn.type = 'standard_resolution';
							imgResReturn.width = 640
						}
					} else {
						imgResReturn.type = 'autocustom';
						imgResReturn.width = colWidth
					}
					break;
				case 'thumb':
					imgResReturn.type = 'thumbnail';
					break;
				case 'medium':
					imgResReturn.type = 'low_resolution';
					break;
				default:
					imgResReturn.type = 'standard_resolution'
			}
		}
		if (typeof window.sbiFeedMeta[$i].minRes === 'undefined') {
			window.sbiFeedMeta[$i].minRes = imgResReturn.type === 'autocustom' ? sbiGetBestResolutionForCustom(colWidth, imgResReturn.width, imgResReturn.width) : sbiGetWidthForResType(imgResReturn.type)
		}
		return imgResReturn
	}

	function sbi_cache_all(imagesArr, transientName) {
		if (transientName.indexOf('header') && typeof imagesArr.data.pagination === 'undefined') {
			sbiCachePhotos(imagesArr, transientName)
		} else if (!transientName.indexOf('header') && typeof imagesArr.data.pagination !== 'undefined') {
			sbiCachePhotos(imagesArr, transientName)
		}
	}
	jQuery(document).ready(function () {
		window.sbiCommentCacheStatus = 0;
		sbi_init(function (imagesArr, transientName) {
			sbi_cache_all(imagesArr, transientName)
		})
	})
};
(function (modules) {
	var installedModules = {};

	function __webpack_require__(moduleId) {
		if (installedModules[moduleId]) {
			return installedModules[moduleId].exports;
		}
		var module = installedModules[moduleId] = {
			i: moduleId,
			l: false,
			exports: {}
		};
		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		module.l = true;
		return module.exports;
	}
	__webpack_require__.m = modules;
	__webpack_require__.c = installedModules;
	__webpack_require__.d = function (exports, name, getter) {
		if (!__webpack_require__.o(exports, name)) {
			Object.defineProperty(exports, name, {
				configurable: false,
				enumerable: true,
				get: getter
			});
		}
	};
	__webpack_require__.n = function (module) {
		var getter = module && module.__esModule ? function getDefault() {
			return module['default'];
		} : function getModuleExports() {
			return module;
		};
		__webpack_require__.d(getter, 'a', getter);
		return getter;
	};
	__webpack_require__.o = function (object, property) {
		return Object.prototype.hasOwnProperty.call(object, property);
	};
	__webpack_require__.p = "";
	return __webpack_require__(__webpack_require__.s = 6);
})
	([(function (module, exports, __webpack_require__) {
		"use strict";
		(function (module) {
			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
				return typeof obj;
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
			};
			/*!
			 * jQuery JavaScript Library v3.3.1
			 * https://jquery.com/
			 *
			 * Includes Sizzle.js
			 * https://sizzlejs.com/
			 *
			 * Copyright JS Foundation and other contributors
			 * Released under the MIT license
			 * https://jquery.org/license
			 *
			 * Date: 2018-01-20T17:24Z
			 */
			(function (global, factory) {
				"use strict";
				if ((false ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
					module.exports = global.document ? factory(global, true) : function (w) {
						if (!w.document) {
							throw new Error("jQuery requires a window with a document");
						}
						return factory(w);
					};
				} else {
					factory(global);
				}
			})(typeof window !== "undefined" ? window : undefined, function (window, noGlobal) {
				"use strict";
				var arr = [];
				var document = window.document;
				var getProto = Object.getPrototypeOf;
				var _slice = arr.slice;
				var concat = arr.concat;
				var push = arr.push;
				var indexOf = arr.indexOf;
				var class2type = {};
				var toString = class2type.toString;
				var hasOwn = class2type.hasOwnProperty;
				var fnToString = hasOwn.toString;
				var ObjectFunctionString = fnToString.call(Object);
				var support = {};
				var isFunction = function isFunction(obj) {
					return typeof obj === "function" && typeof obj.nodeType !== "number";
				};
				var isWindow = function isWindow(obj) {
					return obj != null && obj === obj.window;
				};
				var preservedScriptAttributes = {
					type: true,
					src: true,
					noModule: true
				};

				function DOMEval(code, doc, node) {
					doc = doc || document;
					var i, script = doc.createElement("script");
					script.text = code;
					if (node) {
						for (i in preservedScriptAttributes) {
							if (node[i]) {
								script[i] = node[i];
							}
						}
					}
					doc.head.appendChild(script).parentNode.removeChild(script);
				}

				function toType(obj) {
					if (obj == null) {
						return obj + "";
					}
					return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
				}
				var version = "3.3.1",
					jQuery = function jQuery(selector, context) {
						return new jQuery.fn.init(selector, context);
					},
					rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
				jQuery.fn = jQuery.prototype = {
					jquery: version,
					constructor: jQuery,
					length: 0,
					toArray: function toArray() {
						return _slice.call(this);
					},
					get: function get(num) {
						if (num == null) {
							return _slice.call(this);
						}
						return num < 0 ? this[num + this.length] : this[num];
					},
					pushStack: function pushStack(elems) {
						var ret = jQuery.merge(this.constructor(), elems);
						ret.prevObject = this;
						return ret;
					},
					each: function each(callback) {
						return jQuery.each(this, callback);
					},
					map: function map(callback) {
						return this.pushStack(jQuery.map(this, function (elem, i) {
							return callback.call(elem, i, elem);
						}));
					},
					slice: function slice() {
						return this.pushStack(_slice.apply(this, arguments));
					},
					first: function first() {
						return this.eq(0);
					},
					last: function last() {
						return this.eq(-1);
					},
					eq: function eq(i) {
						var len = this.length,
							j = +i + (i < 0 ? len : 0);
						return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
					},
					end: function end() {
						return this.prevObject || this.constructor();
					},
					push: push,
					sort: arr.sort,
					splice: arr.splice
				};
				jQuery.extend = jQuery.fn.extend = function () {
					var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
						i = 1,
						length = arguments.length,
						deep = false;
					if (typeof target === "boolean") {
						deep = target;
						target = arguments[i] || {};
						i++;
					}
					if ((typeof target === "undefined" ? "undefined" : _typeof(target)) !== "object" && !isFunction(target)) {
						target = {};
					}
					if (i === length) {
						target = this;
						i--;
					}
					for (; i < length; i++) {
						if ((options = arguments[i]) != null) {
							for (name in options) {
								src = target[name];
								copy = options[name];
								if (target === copy) {
									continue;
								}
								if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
									if (copyIsArray) {
										copyIsArray = false;
										clone = src && Array.isArray(src) ? src : [];
									} else {
										clone = src && jQuery.isPlainObject(src) ? src : {};
									}
									target[name] = jQuery.extend(deep, clone, copy);
								} else if (copy !== undefined) {
									target[name] = copy;
								}
							}
						}
					}
					return target;
				};
				jQuery.extend({
					expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
					isReady: true,
					error: function error(msg) {
						throw new Error(msg);
					},
					noop: function noop() { },
					isPlainObject: function isPlainObject(obj) {
						var proto, Ctor;
						if (!obj || toString.call(obj) !== "[object Object]") {
							return false;
						}
						proto = getProto(obj);
						if (!proto) {
							return true;
						}
						Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
						return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
					},
					isEmptyObject: function isEmptyObject(obj) {
						var name;
						for (name in obj) {
							return false;
						}
						return true;
					},
					globalEval: function globalEval(code) {
						DOMEval(code);
					},
					each: function each(obj, callback) {
						var length, i = 0;
						if (isArrayLike(obj)) {
							length = obj.length;
							for (; i < length; i++) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						} else {
							for (i in obj) {
								if (callback.call(obj[i], i, obj[i]) === false) {
									break;
								}
							}
						}
						return obj;
					},
					trim: function trim(text) {
						return text == null ? "" : (text + "").replace(rtrim, "");
					},
					makeArray: function makeArray(arr, results) {
						var ret = results || [];
						if (arr != null) {
							if (isArrayLike(Object(arr))) {
								jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
							} else {
								push.call(ret, arr);
							}
						}
						return ret;
					},
					inArray: function inArray(elem, arr, i) {
						return arr == null ? -1 : indexOf.call(arr, elem, i);
					},
					merge: function merge(first, second) {
						var len = +second.length,
							j = 0,
							i = first.length;
						for (; j < len; j++) {
							first[i++] = second[j];
						}
						first.length = i;
						return first;
					},
					grep: function grep(elems, callback, invert) {
						var callbackInverse, matches = [],
							i = 0,
							length = elems.length,
							callbackExpect = !invert;
						for (; i < length; i++) {
							callbackInverse = !callback(elems[i], i);
							if (callbackInverse !== callbackExpect) {
								matches.push(elems[i]);
							}
						}
						return matches;
					},
					map: function map(elems, callback, arg) {
						var length, value, i = 0,
							ret = [];
						if (isArrayLike(elems)) {
							length = elems.length;
							for (; i < length; i++) {
								value = callback(elems[i], i, arg);
								if (value != null) {
									ret.push(value);
								}
							}
						} else {
							for (i in elems) {
								value = callback(elems[i], i, arg);
								if (value != null) {
									ret.push(value);
								}
							}
						}
						return concat.apply([], ret);
					},
					guid: 1,
					support: support
				});
				if (typeof Symbol === "function") {
					jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
				}
				jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
					class2type["[object " + name + "]"] = name.toLowerCase();
				});

				function isArrayLike(obj) {
					var length = !!obj && "length" in obj && obj.length,
						type = toType(obj);
					if (isFunction(obj) || isWindow(obj)) {
						return false;
					}
					return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
				}
				var Sizzle =
					/*!
					 * Sizzle CSS Selector Engine v2.3.3
					 * https://sizzlejs.com/
					 *
					 * Copyright jQuery Foundation and other contributors
					 * Released under the MIT license
					 * http://jquery.org/license
					 *
					 * Date: 2016-08-08
					 */
					function (window) {
						var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(),
							preferredDoc = window.document,
							dirruns = 0,
							done = 0,
							classCache = createCache(),
							tokenCache = createCache(),
							compilerCache = createCache(),
							sortOrder = function sortOrder(a, b) {
								if (a === b) {
									hasDuplicate = true;
								}
								return 0;
							},
							hasOwn = {}.hasOwnProperty,
							arr = [],
							pop = arr.pop,
							push_native = arr.push,
							push = arr.push,
							slice = arr.slice,
							indexOf = function indexOf(list, elem) {
								var i = 0,
									len = list.length;
								for (; i < len; i++) {
									if (list[i] === elem) {
										return i;
									}
								}
								return -1;
							},
							booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
							whitespace = "[\\x20\\t\\r\\n\\f]",
							identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
							attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
							pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
							rwhitespace = new RegExp(whitespace + "+", "g"),
							rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
							rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
							rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
							rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
							rpseudo = new RegExp(pseudos),
							ridentifier = new RegExp("^" + identifier + "$"),
							matchExpr = {
								"ID": new RegExp("^#(" + identifier + ")"),
								"CLASS": new RegExp("^\\.(" + identifier + ")"),
								"TAG": new RegExp("^(" + identifier + "|[*])"),
								"ATTR": new RegExp("^" + attributes),
								"PSEUDO": new RegExp("^" + pseudos),
								"CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
								"bool": new RegExp("^(?:" + booleans + ")$", "i"),
								"needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
							},
							rinputs = /^(?:input|select|textarea|button)$/i,
							rheader = /^h\d$/i,
							rnative = /^[^{]+\{\s*\[native \w/,
							rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
							rsibling = /[+~]/,
							runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
							funescape = function funescape(_, escaped, escapedWhitespace) {
								var high = "0x" + escaped - 0x10000;
								return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
							},
							rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
							fcssescape = function fcssescape(ch, asCodePoint) {
								if (asCodePoint) {
									if (ch === "\0") {
										return "\uFFFD";
									}
									return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
								}
								return "\\" + ch;
							},
							unloadHandler = function unloadHandler() {
								setDocument();
							},
							disabledAncestor = addCombinator(function (elem) {
								return elem.disabled === true && ("form" in elem || "label" in elem);
							}, {
								dir: "parentNode",
								next: "legend"
							});
						try {
							push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
							arr[preferredDoc.childNodes.length].nodeType;
						} catch (e) {
							push = {
								apply: arr.length ? function (target, els) {
									push_native.apply(target, slice.call(els));
								} : function (target, els) {
									var j = target.length,
										i = 0;
									while (target[j++] = els[i++]) { }
									target.length = j - 1;
								}
							};
						}

						function Sizzle(selector, context, results, seed) {
							var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
								nodeType = context ? context.nodeType : 9;
							results = results || [];
							if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
								return results;
							}
							if (!seed) {
								if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
									setDocument(context);
								}
								context = context || document;
								if (documentIsHTML) {
									if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
										if (m = match[1]) {
											if (nodeType === 9) {
												if (elem = context.getElementById(m)) {
													if (elem.id === m) {
														results.push(elem);
														return results;
													}
												} else {
													return results;
												}
											} else {
												if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
													results.push(elem);
													return results;
												}
											}
										} else if (match[2]) {
											push.apply(results, context.getElementsByTagName(selector));
											return results;
										} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
											push.apply(results, context.getElementsByClassName(m));
											return results;
										}
									}
									if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
										if (nodeType !== 1) {
											newContext = context;
											newSelector = selector;
										} else if (context.nodeName.toLowerCase() !== "object") {
											if (nid = context.getAttribute("id")) {
												nid = nid.replace(rcssescape, fcssescape);
											} else {
												context.setAttribute("id", nid = expando);
											}
											groups = tokenize(selector);
											i = groups.length;
											while (i--) {
												groups[i] = "#" + nid + " " + toSelector(groups[i]);
											}
											newSelector = groups.join(",");
											newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
										}
										if (newSelector) {
											try {
												push.apply(results, newContext.querySelectorAll(newSelector));
												return results;
											} catch (qsaError) { } finally {
												if (nid === expando) {
													context.removeAttribute("id");
												}
											}
										}
									}
								}
							}
							return select(selector.replace(rtrim, "$1"), context, results, seed);
						}

						function createCache() {
							var keys = [];

							function cache(key, value) {
								if (keys.push(key + " ") > Expr.cacheLength) {
									delete cache[keys.shift()];
								}
								return cache[key + " "] = value;
							}
							return cache;
						}

						function markFunction(fn) {
							fn[expando] = true;
							return fn;
						}

						function assert(fn) {
							var el = document.createElement("fieldset");
							try {
								return !!fn(el);
							} catch (e) {
								return false;
							} finally {
								if (el.parentNode) {
									el.parentNode.removeChild(el);
								}
								el = null;
							}
						}

						function addHandle(attrs, handler) {
							var arr = attrs.split("|"),
								i = arr.length;
							while (i--) {
								Expr.attrHandle[arr[i]] = handler;
							}
						}

						function siblingCheck(a, b) {
							var cur = b && a,
								diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
							if (diff) {
								return diff;
							}
							if (cur) {
								while (cur = cur.nextSibling) {
									if (cur === b) {
										return -1;
									}
								}
							}
							return a ? 1 : -1;
						}

						function createInputPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && elem.type === type;
							};
						}

						function createButtonPseudo(type) {
							return function (elem) {
								var name = elem.nodeName.toLowerCase();
								return (name === "input" || name === "button") && elem.type === type;
							};
						}

						function createDisabledPseudo(disabled) {
							return function (elem) {
								if ("form" in elem) {
									if (elem.parentNode && elem.disabled === false) {
										if ("label" in elem) {
											if ("label" in elem.parentNode) {
												return elem.parentNode.disabled === disabled;
											} else {
												return elem.disabled === disabled;
											}
										}
										return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
									}
									return elem.disabled === disabled;
								} else if ("label" in elem) {
									return elem.disabled === disabled;
								}
								return false;
							};
						}

						function createPositionalPseudo(fn) {
							return markFunction(function (argument) {
								argument = +argument;
								return markFunction(function (seed, matches) {
									var j, matchIndexes = fn([], seed.length, argument),
										i = matchIndexes.length;
									while (i--) {
										if (seed[j = matchIndexes[i]]) {
											seed[j] = !(matches[j] = seed[j]);
										}
									}
								});
							});
						}

						function testContext(context) {
							return context && typeof context.getElementsByTagName !== "undefined" && context;
						}
						support = Sizzle.support = {};
						isXML = Sizzle.isXML = function (elem) {
							var documentElement = elem && (elem.ownerDocument || elem).documentElement;
							return documentElement ? documentElement.nodeName !== "HTML" : false;
						};
						setDocument = Sizzle.setDocument = function (node) {
							var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
							if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
								return document;
							}
							document = doc;
							docElem = document.documentElement;
							documentIsHTML = !isXML(document);
							if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
								if (subWindow.addEventListener) {
									subWindow.addEventListener("unload", unloadHandler, false);
								} else if (subWindow.attachEvent) {
									subWindow.attachEvent("onunload", unloadHandler);
								}
							}
							support.attributes = assert(function (el) {
								el.className = "i";
								return !el.getAttribute("className");
							});
							support.getElementsByTagName = assert(function (el) {
								el.appendChild(document.createComment(""));
								return !el.getElementsByTagName("*").length;
							});
							support.getElementsByClassName = rnative.test(document.getElementsByClassName);
							support.getById = assert(function (el) {
								docElem.appendChild(el).id = expando;
								return !document.getElementsByName || !document.getElementsByName(expando).length;
							});
							if (support.getById) {
								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										return elem.getAttribute("id") === attrId;
									};
								};
								Expr.find["ID"] = function (id, context) {
									if (typeof context.getElementById !== "undefined" && documentIsHTML) {
										var elem = context.getElementById(id);
										return elem ? [elem] : [];
									}
								};
							} else {
								Expr.filter["ID"] = function (id) {
									var attrId = id.replace(runescape, funescape);
									return function (elem) {
										var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
										return node && node.value === attrId;
									};
								};
								Expr.find["ID"] = function (id, context) {
									if (typeof context.getElementById !== "undefined" && documentIsHTML) {
										var node, i, elems, elem = context.getElementById(id);
										if (elem) {
											node = elem.getAttributeNode("id");
											if (node && node.value === id) {
												return [elem];
											}
											elems = context.getElementsByName(id);
											i = 0;
											while (elem = elems[i++]) {
												node = elem.getAttributeNode("id");
												if (node && node.value === id) {
													return [elem];
												}
											}
										}
										return [];
									}
								};
							}
							Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
								if (typeof context.getElementsByTagName !== "undefined") {
									return context.getElementsByTagName(tag);
								} else if (support.qsa) {
									return context.querySelectorAll(tag);
								}
							} : function (tag, context) {
								var elem, tmp = [],
									i = 0,
									results = context.getElementsByTagName(tag);
								if (tag === "*") {
									while (elem = results[i++]) {
										if (elem.nodeType === 1) {
											tmp.push(elem);
										}
									}
									return tmp;
								}
								return results;
							};
							Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
								if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
									return context.getElementsByClassName(className);
								}
							};
							rbuggyMatches = [];
							rbuggyQSA = [];
							if (support.qsa = rnative.test(document.querySelectorAll)) {
								assert(function (el) {
									docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
									if (el.querySelectorAll("[msallowcapture^='']").length) {
										rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
									}
									if (!el.querySelectorAll("[selected]").length) {
										rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
									}
									if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
										rbuggyQSA.push("~=");
									}
									if (!el.querySelectorAll(":checked").length) {
										rbuggyQSA.push(":checked");
									}
									if (!el.querySelectorAll("a#" + expando + "+*").length) {
										rbuggyQSA.push(".#.+[+~]");
									}
								});
								assert(function (el) {
									el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
									var input = document.createElement("input");
									input.setAttribute("type", "hidden");
									el.appendChild(input).setAttribute("name", "D");
									if (el.querySelectorAll("[name=d]").length) {
										rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
									}
									if (el.querySelectorAll(":enabled").length !== 2) {
										rbuggyQSA.push(":enabled", ":disabled");
									}
									docElem.appendChild(el).disabled = true;
									if (el.querySelectorAll(":disabled").length !== 2) {
										rbuggyQSA.push(":enabled", ":disabled");
									}
									el.querySelectorAll("*,:x");
									rbuggyQSA.push(",.*:");
								});
							}
							if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
								assert(function (el) {
									support.disconnectedMatch = matches.call(el, "*");
									matches.call(el, "[s!='']:x");
									rbuggyMatches.push("!=", pseudos);
								});
							}
							rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
							rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
							hasCompare = rnative.test(docElem.compareDocumentPosition);
							contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
								var adown = a.nodeType === 9 ? a.documentElement : a,
									bup = b && b.parentNode;
								return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
							} : function (a, b) {
								if (b) {
									while (b = b.parentNode) {
										if (b === a) {
											return true;
										}
									}
								}
								return false;
							};
							sortOrder = hasCompare ? function (a, b) {
								if (a === b) {
									hasDuplicate = true;
									return 0;
								}
								var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
								if (compare) {
									return compare;
								}
								compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
								if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
									if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
										return -1;
									}
									if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
										return 1;
									}
									return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
								}
								return compare & 4 ? -1 : 1;
							} : function (a, b) {
								if (a === b) {
									hasDuplicate = true;
									return 0;
								}
								var cur, i = 0,
									aup = a.parentNode,
									bup = b.parentNode,
									ap = [a],
									bp = [b];
								if (!aup || !bup) {
									return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
								} else if (aup === bup) {
									return siblingCheck(a, b);
								}
								cur = a;
								while (cur = cur.parentNode) {
									ap.unshift(cur);
								}
								cur = b;
								while (cur = cur.parentNode) {
									bp.unshift(cur);
								}
								while (ap[i] === bp[i]) {
									i++;
								}
								return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
							};
							return document;
						};
						Sizzle.matches = function (expr, elements) {
							return Sizzle(expr, null, null, elements);
						};
						Sizzle.matchesSelector = function (elem, expr) {
							if ((elem.ownerDocument || elem) !== document) {
								setDocument(elem);
							}
							expr = expr.replace(rattributeQuotes, "='$1']");
							if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
								try {
									var ret = matches.call(elem, expr);
									if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
										return ret;
									}
								} catch (e) { }
							}
							return Sizzle(expr, document, null, [elem]).length > 0;
						};
						Sizzle.contains = function (context, elem) {
							if ((context.ownerDocument || context) !== document) {
								setDocument(context);
							}
							return contains(context, elem);
						};
						Sizzle.attr = function (elem, name) {
							if ((elem.ownerDocument || elem) !== document) {
								setDocument(elem);
							}
							var fn = Expr.attrHandle[name.toLowerCase()],
								val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
							return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
						};
						Sizzle.escape = function (sel) {
							return (sel + "").replace(rcssescape, fcssescape);
						};
						Sizzle.error = function (msg) {
							throw new Error("Syntax error, unrecognized expression: " + msg);
						};
						Sizzle.uniqueSort = function (results) {
							var elem, duplicates = [],
								j = 0,
								i = 0;
							hasDuplicate = !support.detectDuplicates;
							sortInput = !support.sortStable && results.slice(0);
							results.sort(sortOrder);
							if (hasDuplicate) {
								while (elem = results[i++]) {
									if (elem === results[i]) {
										j = duplicates.push(i);
									}
								}
								while (j--) {
									results.splice(duplicates[j], 1);
								}
							}
							sortInput = null;
							return results;
						};
						getText = Sizzle.getText = function (elem) {
							var node, ret = "",
								i = 0,
								nodeType = elem.nodeType;
							if (!nodeType) {
								while (node = elem[i++]) {
									ret += getText(node);
								}
							} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
								if (typeof elem.textContent === "string") {
									return elem.textContent;
								} else {
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										ret += getText(elem);
									}
								}
							} else if (nodeType === 3 || nodeType === 4) {
								return elem.nodeValue;
							}
							return ret;
						};
						Expr = Sizzle.selectors = {
							cacheLength: 50,
							createPseudo: markFunction,
							match: matchExpr,
							attrHandle: {},
							find: {},
							relative: {
								">": {
									dir: "parentNode",
									first: true
								},
								" ": {
									dir: "parentNode"
								},
								"+": {
									dir: "previousSibling",
									first: true
								},
								"~": {
									dir: "previousSibling"
								}
							},
							preFilter: {
								"ATTR": function ATTR(match) {
									match[1] = match[1].replace(runescape, funescape);
									match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
									if (match[2] === "~=") {
										match[3] = " " + match[3] + " ";
									}
									return match.slice(0, 4);
								},
								"CHILD": function CHILD(match) {
									match[1] = match[1].toLowerCase();
									if (match[1].slice(0, 3) === "nth") {
										if (!match[3]) {
											Sizzle.error(match[0]);
										}
										match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
										match[5] = +(match[7] + match[8] || match[3] === "odd");
									} else if (match[3]) {
										Sizzle.error(match[0]);
									}
									return match;
								},
								"PSEUDO": function PSEUDO(match) {
									var excess, unquoted = !match[6] && match[2];
									if (matchExpr["CHILD"].test(match[0])) {
										return null;
									}
									if (match[3]) {
										match[2] = match[4] || match[5] || "";
									} else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
										match[0] = match[0].slice(0, excess);
										match[2] = unquoted.slice(0, excess);
									}
									return match.slice(0, 3);
								}
							},
							filter: {
								"TAG": function TAG(nodeNameSelector) {
									var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
									return nodeNameSelector === "*" ? function () {
										return true;
									} : function (elem) {
										return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
									};
								},
								"CLASS": function CLASS(className) {
									var pattern = classCache[className + " "];
									return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
										return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
									});
								},
								"ATTR": function ATTR(name, operator, check) {
									return function (elem) {
										var result = Sizzle.attr(elem, name);
										if (result == null) {
											return operator === "!=";
										}
										if (!operator) {
											return true;
										}
										result += "";
										return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
									};
								},
								"CHILD": function CHILD(type, what, argument, first, last) {
									var simple = type.slice(0, 3) !== "nth",
										forward = type.slice(-4) !== "last",
										ofType = what === "of-type";
									return first === 1 && last === 0 ? function (elem) {
										return !!elem.parentNode;
									} : function (elem, context, xml) {
										var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
											parent = elem.parentNode,
											name = ofType && elem.nodeName.toLowerCase(),
											useCache = !xml && !ofType,
											diff = false;
										if (parent) {
											if (simple) {
												while (dir) {
													node = elem;
													while (node = node[dir]) {
														if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
															return false;
														}
													}
													start = dir = type === "only" && !start && "nextSibling";
												}
												return true;
											}
											start = [forward ? parent.firstChild : parent.lastChild];
											if (forward && useCache) {
												node = parent;
												outerCache = node[expando] || (node[expando] = {});
												uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
												cache = uniqueCache[type] || [];
												nodeIndex = cache[0] === dirruns && cache[1];
												diff = nodeIndex && cache[2];
												node = nodeIndex && parent.childNodes[nodeIndex];
												while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
													if (node.nodeType === 1 && ++diff && node === elem) {
														uniqueCache[type] = [dirruns, nodeIndex, diff];
														break;
													}
												}
											} else {
												if (useCache) {
													node = elem;
													outerCache = node[expando] || (node[expando] = {});
													uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
													cache = uniqueCache[type] || [];
													nodeIndex = cache[0] === dirruns && cache[1];
													diff = nodeIndex;
												}
												if (diff === false) {
													while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
														if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
															if (useCache) {
																outerCache = node[expando] || (node[expando] = {});
																uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
																uniqueCache[type] = [dirruns, diff];
															}
															if (node === elem) {
																break;
															}
														}
													}
												}
											}
											diff -= last;
											return diff === first || diff % first === 0 && diff / first >= 0;
										}
									};
								},
								"PSEUDO": function PSEUDO(pseudo, argument) {
									var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
									if (fn[expando]) {
										return fn(argument);
									}
									if (fn.length > 1) {
										args = [pseudo, pseudo, "", argument];
										return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
											var idx, matched = fn(seed, argument),
												i = matched.length;
											while (i--) {
												idx = indexOf(seed, matched[i]);
												seed[idx] = !(matches[idx] = matched[i]);
											}
										}) : function (elem) {
											return fn(elem, 0, args);
										};
									}
									return fn;
								}
							},
							pseudos: {
								"not": markFunction(function (selector) {
									var input = [],
										results = [],
										matcher = compile(selector.replace(rtrim, "$1"));
									return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
										var elem, unmatched = matcher(seed, null, xml, []),
											i = seed.length;
										while (i--) {
											if (elem = unmatched[i]) {
												seed[i] = !(matches[i] = elem);
											}
										}
									}) : function (elem, context, xml) {
										input[0] = elem;
										matcher(input, null, xml, results);
										input[0] = null;
										return !results.pop();
									};
								}),
								"has": markFunction(function (selector) {
									return function (elem) {
										return Sizzle(selector, elem).length > 0;
									};
								}),
								"contains": markFunction(function (text) {
									text = text.replace(runescape, funescape);
									return function (elem) {
										return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
									};
								}),
								"lang": markFunction(function (lang) {
									if (!ridentifier.test(lang || "")) {
										Sizzle.error("unsupported lang: " + lang);
									}
									lang = lang.replace(runescape, funescape).toLowerCase();
									return function (elem) {
										var elemLang;
										do {
											if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
												elemLang = elemLang.toLowerCase();
												return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
											}
										} while ((elem = elem.parentNode) && elem.nodeType === 1);
										return false;
									};
								}),
								"target": function target(elem) {
									var hash = window.location && window.location.hash;
									return hash && hash.slice(1) === elem.id;
								},
								"root": function root(elem) {
									return elem === docElem;
								},
								"focus": function focus(elem) {
									return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
								},
								"enabled": createDisabledPseudo(false),
								"disabled": createDisabledPseudo(true),
								"checked": function checked(elem) {
									var nodeName = elem.nodeName.toLowerCase();
									return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
								},
								"selected": function selected(elem) {
									if (elem.parentNode) {
										elem.parentNode.selectedIndex;
									}
									return elem.selected === true;
								},
								"empty": function empty(elem) {
									for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
										if (elem.nodeType < 6) {
											return false;
										}
									}
									return true;
								},
								"parent": function parent(elem) {
									return !Expr.pseudos["empty"](elem);
								},
								"header": function header(elem) {
									return rheader.test(elem.nodeName);
								},
								"input": function input(elem) {
									return rinputs.test(elem.nodeName);
								},
								"button": function button(elem) {
									var name = elem.nodeName.toLowerCase();
									return name === "input" && elem.type === "button" || name === "button";
								},
								"text": function text(elem) {
									var attr;
									return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
								},
								"first": createPositionalPseudo(function () {
									return [0];
								}),
								"last": createPositionalPseudo(function (matchIndexes, length) {
									return [length - 1];
								}),
								"eq": createPositionalPseudo(function (matchIndexes, length, argument) {
									return [argument < 0 ? argument + length : argument];
								}),
								"even": createPositionalPseudo(function (matchIndexes, length) {
									var i = 0;
									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),
								"odd": createPositionalPseudo(function (matchIndexes, length) {
									var i = 1;
									for (; i < length; i += 2) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),
								"lt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument;
									for (; --i >= 0;) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								}),
								"gt": createPositionalPseudo(function (matchIndexes, length, argument) {
									var i = argument < 0 ? argument + length : argument;
									for (; ++i < length;) {
										matchIndexes.push(i);
									}
									return matchIndexes;
								})
							}
						};
						Expr.pseudos["nth"] = Expr.pseudos["eq"];
						for (i in {
							radio: true,
							checkbox: true,
							file: true,
							password: true,
							image: true
						}) {
							Expr.pseudos[i] = createInputPseudo(i);
						}
						for (i in {
							submit: true,
							reset: true
						}) {
							Expr.pseudos[i] = createButtonPseudo(i);
						}

						function setFilters() { }
						setFilters.prototype = Expr.filters = Expr.pseudos;
						Expr.setFilters = new setFilters();
						tokenize = Sizzle.tokenize = function (selector, parseOnly) {
							var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
							if (cached) {
								return parseOnly ? 0 : cached.slice(0);
							}
							soFar = selector;
							groups = [];
							preFilters = Expr.preFilter;
							while (soFar) {
								if (!matched || (match = rcomma.exec(soFar))) {
									if (match) {
										soFar = soFar.slice(match[0].length) || soFar;
									}
									groups.push(tokens = []);
								}
								matched = false;
								if (match = rcombinators.exec(soFar)) {
									matched = match.shift();
									tokens.push({
										value: matched,
										type: match[0].replace(rtrim, " ")
									});
									soFar = soFar.slice(matched.length);
								}
								for (type in Expr.filter) {
									if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
										matched = match.shift();
										tokens.push({
											value: matched,
											type: type,
											matches: match
										});
										soFar = soFar.slice(matched.length);
									}
								}
								if (!matched) {
									break;
								}
							}
							return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
						};

						function toSelector(tokens) {
							var i = 0,
								len = tokens.length,
								selector = "";
							for (; i < len; i++) {
								selector += tokens[i].value;
							}
							return selector;
						}

						function addCombinator(matcher, combinator, base) {
							var dir = combinator.dir,
								skip = combinator.next,
								key = skip || dir,
								checkNonElements = base && key === "parentNode",
								doneName = done++;
							return combinator.first ? function (elem, context, xml) {
								while (elem = elem[dir]) {
									if (elem.nodeType === 1 || checkNonElements) {
										return matcher(elem, context, xml);
									}
								}
								return false;
							} : function (elem, context, xml) {
								var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
								if (xml) {
									while (elem = elem[dir]) {
										if (elem.nodeType === 1 || checkNonElements) {
											if (matcher(elem, context, xml)) {
												return true;
											}
										}
									}
								} else {
									while (elem = elem[dir]) {
										if (elem.nodeType === 1 || checkNonElements) {
											outerCache = elem[expando] || (elem[expando] = {});
											uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
											if (skip && skip === elem.nodeName.toLowerCase()) {
												elem = elem[dir] || elem;
											} else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
												return newCache[2] = oldCache[2];
											} else {
												uniqueCache[key] = newCache;
												if (newCache[2] = matcher(elem, context, xml)) {
													return true;
												}
											}
										}
									}
								}
								return false;
							};
						}

						function elementMatcher(matchers) {
							return matchers.length > 1 ? function (elem, context, xml) {
								var i = matchers.length;
								while (i--) {
									if (!matchers[i](elem, context, xml)) {
										return false;
									}
								}
								return true;
							} : matchers[0];
						}

						function multipleContexts(selector, contexts, results) {
							var i = 0,
								len = contexts.length;
							for (; i < len; i++) {
								Sizzle(selector, contexts[i], results);
							}
							return results;
						}

						function condense(unmatched, map, filter, context, xml) {
							var elem, newUnmatched = [],
								i = 0,
								len = unmatched.length,
								mapped = map != null;
							for (; i < len; i++) {
								if (elem = unmatched[i]) {
									if (!filter || filter(elem, context, xml)) {
										newUnmatched.push(elem);
										if (mapped) {
											map.push(i);
										}
									}
								}
							}
							return newUnmatched;
						}

						function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
							if (postFilter && !postFilter[expando]) {
								postFilter = setMatcher(postFilter);
							}
							if (postFinder && !postFinder[expando]) {
								postFinder = setMatcher(postFinder, postSelector);
							}
							return markFunction(function (seed, results, context, xml) {
								var temp, i, elem, preMap = [],
									postMap = [],
									preexisting = results.length,
									elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
									matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
									matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
								if (matcher) {
									matcher(matcherIn, matcherOut, context, xml);
								}
								if (postFilter) {
									temp = condense(matcherOut, postMap);
									postFilter(temp, [], context, xml);
									i = temp.length;
									while (i--) {
										if (elem = temp[i]) {
											matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
										}
									}
								}
								if (seed) {
									if (postFinder || preFilter) {
										if (postFinder) {
											temp = [];
											i = matcherOut.length;
											while (i--) {
												if (elem = matcherOut[i]) {
													temp.push(matcherIn[i] = elem);
												}
											}
											postFinder(null, matcherOut = [], temp, xml);
										}
										i = matcherOut.length;
										while (i--) {
											if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
												seed[temp] = !(results[temp] = elem);
											}
										}
									}
								} else {
									matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
									if (postFinder) {
										postFinder(null, results, matcherOut, xml);
									} else {
										push.apply(results, matcherOut);
									}
								}
							});
						}

						function matcherFromTokens(tokens) {
							var checkContext, matcher, j, len = tokens.length,
								leadingRelative = Expr.relative[tokens[0].type],
								implicitRelative = leadingRelative || Expr.relative[" "],
								i = leadingRelative ? 1 : 0,
								matchContext = addCombinator(function (elem) {
									return elem === checkContext;
								}, implicitRelative, true),
								matchAnyContext = addCombinator(function (elem) {
									return indexOf(checkContext, elem) > -1;
								}, implicitRelative, true),
								matchers = [function (elem, context, xml) {
									var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
									checkContext = null;
									return ret;
								}];
							for (; i < len; i++) {
								if (matcher = Expr.relative[tokens[i].type]) {
									matchers = [addCombinator(elementMatcher(matchers), matcher)];
								} else {
									matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
									if (matcher[expando]) {
										j = ++i;
										for (; j < len; j++) {
											if (Expr.relative[tokens[j].type]) {
												break;
											}
										}
										return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
											value: tokens[i - 2].type === " " ? "*" : ""
										})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
									}
									matchers.push(matcher);
								}
							}
							return elementMatcher(matchers);
						}

						function matcherFromGroupMatchers(elementMatchers, setMatchers) {
							var bySet = setMatchers.length > 0,
								byElement = elementMatchers.length > 0,
								superMatcher = function superMatcher(seed, context, xml, results, outermost) {
									var elem, j, matcher, matchedCount = 0,
										i = "0",
										unmatched = seed && [],
										setMatched = [],
										contextBackup = outermostContext,
										elems = seed || byElement && Expr.find["TAG"]("*", outermost),
										dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
										len = elems.length;
									if (outermost) {
										outermostContext = context === document || context || outermost;
									}
									for (; i !== len && (elem = elems[i]) != null; i++) {
										if (byElement && elem) {
											j = 0;
											if (!context && elem.ownerDocument !== document) {
												setDocument(elem);
												xml = !documentIsHTML;
											}
											while (matcher = elementMatchers[j++]) {
												if (matcher(elem, context || document, xml)) {
													results.push(elem);
													break;
												}
											}
											if (outermost) {
												dirruns = dirrunsUnique;
											}
										}
										if (bySet) {
											if (elem = !matcher && elem) {
												matchedCount--;
											}
											if (seed) {
												unmatched.push(elem);
											}
										}
									}
									matchedCount += i;
									if (bySet && i !== matchedCount) {
										j = 0;
										while (matcher = setMatchers[j++]) {
											matcher(unmatched, setMatched, context, xml);
										}
										if (seed) {
											if (matchedCount > 0) {
												while (i--) {
													if (!(unmatched[i] || setMatched[i])) {
														setMatched[i] = pop.call(results);
													}
												}
											}
											setMatched = condense(setMatched);
										}
										push.apply(results, setMatched);
										if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
											Sizzle.uniqueSort(results);
										}
									}
									if (outermost) {
										dirruns = dirrunsUnique;
										outermostContext = contextBackup;
									}
									return unmatched;
								};
							return bySet ? markFunction(superMatcher) : superMatcher;
						}
						compile = Sizzle.compile = function (selector, match) {
							var i, setMatchers = [],
								elementMatchers = [],
								cached = compilerCache[selector + " "];
							if (!cached) {
								if (!match) {
									match = tokenize(selector);
								}
								i = match.length;
								while (i--) {
									cached = matcherFromTokens(match[i]);
									if (cached[expando]) {
										setMatchers.push(cached);
									} else {
										elementMatchers.push(cached);
									}
								}
								cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
								cached.selector = selector;
							}
							return cached;
						};
						select = Sizzle.select = function (selector, context, results, seed) {
							var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
								match = !seed && tokenize(selector = compiled.selector || selector);
							results = results || [];
							if (match.length === 1) {
								tokens = match[0] = match[0].slice(0);
								if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
									context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
									if (!context) {
										return results;
									} else if (compiled) {
										context = context.parentNode;
									}
									selector = selector.slice(tokens.shift().value.length);
								}
								i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
								while (i--) {
									token = tokens[i];
									if (Expr.relative[type = token.type]) {
										break;
									}
									if (find = Expr.find[type]) {
										if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
											tokens.splice(i, 1);
											selector = seed.length && toSelector(tokens);
											if (!selector) {
												push.apply(results, seed);
												return results;
											}
											break;
										}
									}
								}
							}
							(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
							return results;
						};
						support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
						support.detectDuplicates = !!hasDuplicate;
						setDocument();
						support.sortDetached = assert(function (el) {
							return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
						});
						if (!assert(function (el) {
							el.innerHTML = "<a href='#'></a>";
							return el.firstChild.getAttribute("href") === "#";
						})) {
							addHandle("type|href|height|width", function (elem, name, isXML) {
								if (!isXML) {
									return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
								}
							});
						}
						if (!support.attributes || !assert(function (el) {
							el.innerHTML = "<input/>";
							el.firstChild.setAttribute("value", "");
							return el.firstChild.getAttribute("value") === "";
						})) {
							addHandle("value", function (elem, name, isXML) {
								if (!isXML && elem.nodeName.toLowerCase() === "input") {
									return elem.defaultValue;
								}
							});
						}
						if (!assert(function (el) {
							return el.getAttribute("disabled") == null;
						})) {
							addHandle(booleans, function (elem, name, isXML) {
								var val;
								if (!isXML) {
									return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
								}
							});
						}
						return Sizzle;
					}(window);
				jQuery.find = Sizzle;
				jQuery.expr = Sizzle.selectors;
				jQuery.expr[":"] = jQuery.expr.pseudos;
				jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
				jQuery.text = Sizzle.getText;
				jQuery.isXMLDoc = Sizzle.isXML;
				jQuery.contains = Sizzle.contains;
				jQuery.escapeSelector = Sizzle.escape;
				var dir = function dir(elem, _dir, until) {
					var matched = [],
						truncate = until !== undefined;
					while ((elem = elem[_dir]) && elem.nodeType !== 9) {
						if (elem.nodeType === 1) {
							if (truncate && jQuery(elem).is(until)) {
								break;
							}
							matched.push(elem);
						}
					}
					return matched;
				};
				var _siblings = function _siblings(n, elem) {
					var matched = [];
					for (; n; n = n.nextSibling) {
						if (n.nodeType === 1 && n !== elem) {
							matched.push(n);
						}
					}
					return matched;
				};
				var rneedsContext = jQuery.expr.match.needsContext;

				function nodeName(elem, name) {
					return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				};
				var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

				function winnow(elements, qualifier, not) {
					if (isFunction(qualifier)) {
						return jQuery.grep(elements, function (elem, i) {
							return !!qualifier.call(elem, i, elem) !== not;
						});
					}
					if (qualifier.nodeType) {
						return jQuery.grep(elements, function (elem) {
							return elem === qualifier !== not;
						});
					}
					if (typeof qualifier !== "string") {
						return jQuery.grep(elements, function (elem) {
							return indexOf.call(qualifier, elem) > -1 !== not;
						});
					}
					return jQuery.filter(qualifier, elements, not);
				}
				jQuery.filter = function (expr, elems, not) {
					var elem = elems[0];
					if (not) {
						expr = ":not(" + expr + ")";
					}
					if (elems.length === 1 && elem.nodeType === 1) {
						return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
					}
					return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
						return elem.nodeType === 1;
					}));
				};
				jQuery.fn.extend({
					find: function find(selector) {
						var i, ret, len = this.length,
							self = this;
						if (typeof selector !== "string") {
							return this.pushStack(jQuery(selector).filter(function () {
								for (i = 0; i < len; i++) {
									if (jQuery.contains(self[i], this)) {
										return true;
									}
								}
							}));
						}
						ret = this.pushStack([]);
						for (i = 0; i < len; i++) {
							jQuery.find(selector, self[i], ret);
						}
						return len > 1 ? jQuery.uniqueSort(ret) : ret;
					},
					filter: function filter(selector) {
						return this.pushStack(winnow(this, selector || [], false));
					},
					not: function not(selector) {
						return this.pushStack(winnow(this, selector || [], true));
					},
					is: function is(selector) {
						return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
					}
				});
				var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
					init = jQuery.fn.init = function (selector, context, root) {
						var match, elem;
						if (!selector) {
							return this;
						}
						root = root || rootjQuery;
						if (typeof selector === "string") {
							if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
								match = [null, selector, null];
							} else {
								match = rquickExpr.exec(selector);
							}
							if (match && (match[1] || !context)) {
								if (match[1]) {
									context = context instanceof jQuery ? context[0] : context;
									jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
									if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
										for (match in context) {
											if (isFunction(this[match])) {
												this[match](context[match]);
											} else {
												this.attr(match, context[match]);
											}
										}
									}
									return this;
								} else {
									elem = document.getElementById(match[2]);
									if (elem) {
										this[0] = elem;
										this.length = 1;
									}
									return this;
								}
							} else if (!context || context.jquery) {
								return (context || root).find(selector);
							} else {
								return this.constructor(context).find(selector);
							}
						} else if (selector.nodeType) {
							this[0] = selector;
							this.length = 1;
							return this;
						} else if (isFunction(selector)) {
							return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
						}
						return jQuery.makeArray(selector, this);
					};
				init.prototype = jQuery.fn;
				rootjQuery = jQuery(document);
				var rparentsprev = /^(?:parents|prev(?:Until|All))/,
					guaranteedUnique = {
						children: true,
						contents: true,
						next: true,
						prev: true
					};
				jQuery.fn.extend({
					has: function has(target) {
						var targets = jQuery(target, this),
							l = targets.length;
						return this.filter(function () {
							var i = 0;
							for (; i < l; i++) {
								if (jQuery.contains(this, targets[i])) {
									return true;
								}
							}
						});
					},
					closest: function closest(selectors, context) {
						var cur, i = 0,
							l = this.length,
							matched = [],
							targets = typeof selectors !== "string" && jQuery(selectors);
						if (!rneedsContext.test(selectors)) {
							for (; i < l; i++) {
								for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
									if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
										matched.push(cur);
										break;
									}
								}
							}
						}
						return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
					},
					index: function index(elem) {
						if (!elem) {
							return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
						}
						if (typeof elem === "string") {
							return indexOf.call(jQuery(elem), this[0]);
						}
						return indexOf.call(this, elem.jquery ? elem[0] : elem);
					},
					add: function add(selector, context) {
						return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
					},
					addBack: function addBack(selector) {
						return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
					}
				});

				function sibling(cur, dir) {
					while ((cur = cur[dir]) && cur.nodeType !== 1) { }
					return cur;
				}
				jQuery.each({
					parent: function parent(elem) {
						var parent = elem.parentNode;
						return parent && parent.nodeType !== 11 ? parent : null;
					},
					parents: function parents(elem) {
						return dir(elem, "parentNode");
					},
					parentsUntil: function parentsUntil(elem, i, until) {
						return dir(elem, "parentNode", until);
					},
					next: function next(elem) {
						return sibling(elem, "nextSibling");
					},
					prev: function prev(elem) {
						return sibling(elem, "previousSibling");
					},
					nextAll: function nextAll(elem) {
						return dir(elem, "nextSibling");
					},
					prevAll: function prevAll(elem) {
						return dir(elem, "previousSibling");
					},
					nextUntil: function nextUntil(elem, i, until) {
						return dir(elem, "nextSibling", until);
					},
					prevUntil: function prevUntil(elem, i, until) {
						return dir(elem, "previousSibling", until);
					},
					siblings: function siblings(elem) {
						return _siblings((elem.parentNode || {}).firstChild, elem);
					},
					children: function children(elem) {
						return _siblings(elem.firstChild);
					},
					contents: function contents(elem) {
						if (nodeName(elem, "iframe")) {
							return elem.contentDocument;
						}
						if (nodeName(elem, "template")) {
							elem = elem.content || elem;
						}
						return jQuery.merge([], elem.childNodes);
					}
				}, function (name, fn) {
					jQuery.fn[name] = function (until, selector) {
						var matched = jQuery.map(this, fn, until);
						if (name.slice(-5) !== "Until") {
							selector = until;
						}
						if (selector && typeof selector === "string") {
							matched = jQuery.filter(selector, matched);
						}
						if (this.length > 1) {
							if (!guaranteedUnique[name]) {
								jQuery.uniqueSort(matched);
							}
							if (rparentsprev.test(name)) {
								matched.reverse();
							}
						}
						return this.pushStack(matched);
					};
				});
				var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

				function createOptions(options) {
					var object = {};
					jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
						object[flag] = true;
					});
					return object;
				}
				jQuery.Callbacks = function (options) {
					options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
					var
						firing, memory, _fired, _locked, list = [],
						queue = [],
						firingIndex = -1,
						fire = function fire() {
							_locked = _locked || options.once;
							_fired = firing = true;
							for (; queue.length; firingIndex = -1) {
								memory = queue.shift();
								while (++firingIndex < list.length) {
									if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
										firingIndex = list.length;
										memory = false;
									}
								}
							}
							if (!options.memory) {
								memory = false;
							}
							firing = false;
							if (_locked) {
								if (memory) {
									list = [];
								} else {
									list = "";
								}
							}
						},
						self = {
							add: function add() {
								if (list) {
									if (memory && !firing) {
										firingIndex = list.length - 1;
										queue.push(memory);
									}
									(function add(args) {
										jQuery.each(args, function (_, arg) {
											if (isFunction(arg)) {
												if (!options.unique || !self.has(arg)) {
													list.push(arg);
												}
											} else if (arg && arg.length && toType(arg) !== "string") {
												add(arg);
											}
										});
									})(arguments);
									if (memory && !firing) {
										fire();
									}
								}
								return this;
							},
							remove: function remove() {
								jQuery.each(arguments, function (_, arg) {
									var index;
									while ((index = jQuery.inArray(arg, list, index)) > -1) {
										list.splice(index, 1);
										if (index <= firingIndex) {
											firingIndex--;
										}
									}
								});
								return this;
							},
							has: function has(fn) {
								return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
							},
							empty: function empty() {
								if (list) {
									list = [];
								}
								return this;
							},
							disable: function disable() {
								_locked = queue = [];
								list = memory = "";
								return this;
							},
							disabled: function disabled() {
								return !list;
							},
							lock: function lock() {
								_locked = queue = [];
								if (!memory && !firing) {
									list = memory = "";
								}
								return this;
							},
							locked: function locked() {
								return !!_locked;
							},
							fireWith: function fireWith(context, args) {
								if (!_locked) {
									args = args || [];
									args = [context, args.slice ? args.slice() : args];
									queue.push(args);
									if (!firing) {
										fire();
									}
								}
								return this;
							},
							fire: function fire() {
								self.fireWith(this, arguments);
								return this;
							},
							fired: function fired() {
								return !!_fired;
							}
						};
					return self;
				};

				function Identity(v) {
					return v;
				}

				function Thrower(ex) {
					throw ex;
				}

				function adoptValue(value, resolve, reject, noValue) {
					var method;
					try {
						if (value && isFunction(method = value.promise)) {
							method.call(value).done(resolve).fail(reject);
						} else if (value && isFunction(method = value.then)) {
							method.call(value, resolve, reject);
						} else {
							resolve.apply(undefined, [value].slice(noValue));
						}
					} catch (value) {
						reject.apply(undefined, [value]);
					}
				}
				jQuery.extend({
					Deferred: function Deferred(func) {
						var tuples = [
							["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2],
							["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"],
							["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]
						],
							_state = "pending",
							_promise = {
								state: function state() {
									return _state;
								},
								always: function always() {
									deferred.done(arguments).fail(arguments);
									return this;
								},
								"catch": function _catch(fn) {
									return _promise.then(null, fn);
								},
								pipe: function pipe() {
									var fns = arguments;
									return jQuery.Deferred(function (newDefer) {
										jQuery.each(tuples, function (i, tuple) {
											var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
											deferred[tuple[1]](function () {
												var returned = fn && fn.apply(this, arguments);
												if (returned && isFunction(returned.promise)) {
													returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
												} else {
													newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
												}
											});
										});
										fns = null;
									}).promise();
								},
								then: function then(onFulfilled, onRejected, onProgress) {
									var maxDepth = 0;

									function resolve(depth, deferred, handler, special) {
										return function () {
											var that = this,
												args = arguments,
												mightThrow = function mightThrow() {
													var returned, then;
													if (depth < maxDepth) {
														return;
													}
													returned = handler.apply(that, args);
													if (returned === deferred.promise()) {
														throw new TypeError("Thenable self-resolution");
													}
													then = returned && ((typeof returned === "undefined" ? "undefined" : _typeof(returned)) === "object" || typeof returned === "function") && returned.then;
													if (isFunction(then)) {
														if (special) {
															then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
														} else {
															maxDepth++;
															then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
														}
													} else {
														if (handler !== Identity) {
															that = undefined;
															args = [returned];
														}
														(special || deferred.resolveWith)(that, args);
													}
												},
												process = special ? mightThrow : function () {
													try {
														mightThrow();
													} catch (e) {
														if (jQuery.Deferred.exceptionHook) {
															jQuery.Deferred.exceptionHook(e, process.stackTrace);
														}
														if (depth + 1 >= maxDepth) {
															if (handler !== Thrower) {
																that = undefined;
																args = [e];
															}
															deferred.rejectWith(that, args);
														}
													}
												};
											if (depth) {
												process();
											} else {
												if (jQuery.Deferred.getStackHook) {
													process.stackTrace = jQuery.Deferred.getStackHook();
												}
												window.setTimeout(process);
											}
										};
									}
									return jQuery.Deferred(function (newDefer) {
										tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
										tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
										tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
									}).promise();
								},
								promise: function promise(obj) {
									return obj != null ? jQuery.extend(obj, _promise) : _promise;
								}
							},
							deferred = {};
						jQuery.each(tuples, function (i, tuple) {
							var list = tuple[2],
								stateString = tuple[5];
							_promise[tuple[1]] = list.add;
							if (stateString) {
								list.add(function () {
									_state = stateString;
								}, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
							}
							list.add(tuple[3].fire);
							deferred[tuple[0]] = function () {
								deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
								return this;
							};
							deferred[tuple[0] + "With"] = list.fireWith;
						});
						_promise.promise(deferred);
						if (func) {
							func.call(deferred, deferred);
						}
						return deferred;
					},
					when: function when(singleValue) {
						var
							remaining = arguments.length,
							i = remaining,
							resolveContexts = Array(i),
							resolveValues = _slice.call(arguments),
							master = jQuery.Deferred(),
							updateFunc = function updateFunc(i) {
								return function (value) {
									resolveContexts[i] = this;
									resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;
									if (!--remaining) {
										master.resolveWith(resolveContexts, resolveValues);
									}
								};
							};
						if (remaining <= 1) {
							adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
							if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
								return master.then();
							}
						}
						while (i--) {
							adoptValue(resolveValues[i], updateFunc(i), master.reject);
						}
						return master.promise();
					}
				});
				var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
				jQuery.Deferred.exceptionHook = function (error, stack) {
					if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
						window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
					}
				};
				jQuery.readyException = function (error) {
					window.setTimeout(function () {
						throw error;
					});
				};
				var readyList = jQuery.Deferred();
				jQuery.fn.ready = function (fn) {
					readyList.then(fn).catch(function (error) {
						jQuery.readyException(error);
					});
					return this;
				};
				jQuery.extend({
					isReady: false,
					readyWait: 1,
					ready: function ready(wait) {
						if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
							return;
						}
						jQuery.isReady = true;
						if (wait !== true && --jQuery.readyWait > 0) {
							return;
						}
						readyList.resolveWith(document, [jQuery]);
					}
				});
				jQuery.ready.then = readyList.then;

				function completed() {
					document.removeEventListener("DOMContentLoaded", completed);
					window.removeEventListener("load", completed);
					jQuery.ready();
				}
				if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
					window.setTimeout(jQuery.ready);
				} else {
					document.addEventListener("DOMContentLoaded", completed);
					window.addEventListener("load", completed);
				}
				var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
					var i = 0,
						len = elems.length,
						bulk = key == null;
					if (toType(key) === "object") {
						chainable = true;
						for (i in key) {
							access(elems, fn, i, key[i], true, emptyGet, raw);
						}
					} else if (value !== undefined) {
						chainable = true;
						if (!isFunction(value)) {
							raw = true;
						}
						if (bulk) {
							if (raw) {
								fn.call(elems, value);
								fn = null;
							} else {
								bulk = fn;
								fn = function fn(elem, key, value) {
									return bulk.call(jQuery(elem), value);
								};
							}
						}
						if (fn) {
							for (; i < len; i++) {
								fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
							}
						}
					}
					if (chainable) {
						return elems;
					}
					if (bulk) {
						return fn.call(elems);
					}
					return len ? fn(elems[0], key) : emptyGet;
				};
				var rmsPrefix = /^-ms-/,
					rdashAlpha = /-([a-z])/g;

				function fcamelCase(all, letter) {
					return letter.toUpperCase();
				}

				function camelCase(string) {
					return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
				}
				var acceptData = function acceptData(owner) {
					return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
				};

				function Data() {
					this.expando = jQuery.expando + Data.uid++;
				}
				Data.uid = 1;
				Data.prototype = {
					cache: function cache(owner) {
						var value = owner[this.expando];
						if (!value) {
							value = {};
							if (acceptData(owner)) {
								if (owner.nodeType) {
									owner[this.expando] = value;
								} else {
									Object.defineProperty(owner, this.expando, {
										value: value,
										configurable: true
									});
								}
							}
						}
						return value;
					},
					set: function set(owner, data, value) {
						var prop, cache = this.cache(owner);
						if (typeof data === "string") {
							cache[camelCase(data)] = value;
						} else {
							for (prop in data) {
								cache[camelCase(prop)] = data[prop];
							}
						}
						return cache;
					},
					get: function get(owner, key) {
						return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
					},
					access: function access(owner, key, value) {
						if (key === undefined || key && typeof key === "string" && value === undefined) {
							return this.get(owner, key);
						}
						this.set(owner, key, value);
						return value !== undefined ? value : key;
					},
					remove: function remove(owner, key) {
						var i, cache = owner[this.expando];
						if (cache === undefined) {
							return;
						}
						if (key !== undefined) {
							if (Array.isArray(key)) {
								key = key.map(camelCase);
							} else {
								key = camelCase(key);
								key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
							}
							i = key.length;
							while (i--) {
								delete cache[key[i]];
							}
						}
						if (key === undefined || jQuery.isEmptyObject(cache)) {
							if (owner.nodeType) {
								owner[this.expando] = undefined;
							} else {
								delete owner[this.expando];
							}
						}
					},
					hasData: function hasData(owner) {
						var cache = owner[this.expando];
						return cache !== undefined && !jQuery.isEmptyObject(cache);
					}
				};
				var dataPriv = new Data();
				var dataUser = new Data();
				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
					rmultiDash = /[A-Z]/g;

				function getData(data) {
					if (data === "true") {
						return true;
					}
					if (data === "false") {
						return false;
					}
					if (data === "null") {
						return null;
					}
					if (data === +data + "") {
						return +data;
					}
					if (rbrace.test(data)) {
						return JSON.parse(data);
					}
					return data;
				}

				function dataAttr(elem, key, data) {
					var name;
					if (data === undefined && elem.nodeType === 1) {
						name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
						data = elem.getAttribute(name);
						if (typeof data === "string") {
							try {
								data = getData(data);
							} catch (e) { }
							dataUser.set(elem, key, data);
						} else {
							data = undefined;
						}
					}
					return data;
				}
				jQuery.extend({
					hasData: function hasData(elem) {
						return dataUser.hasData(elem) || dataPriv.hasData(elem);
					},
					data: function data(elem, name, _data) {
						return dataUser.access(elem, name, _data);
					},
					removeData: function removeData(elem, name) {
						dataUser.remove(elem, name);
					},
					_data: function _data(elem, name, data) {
						return dataPriv.access(elem, name, data);
					},
					_removeData: function _removeData(elem, name) {
						dataPriv.remove(elem, name);
					}
				});
				jQuery.fn.extend({
					data: function data(key, value) {
						var i, name, data, elem = this[0],
							attrs = elem && elem.attributes;
						if (key === undefined) {
							if (this.length) {
								data = dataUser.get(elem);
								if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
									i = attrs.length;
									while (i--) {
										if (attrs[i]) {
											name = attrs[i].name;
											if (name.indexOf("data-") === 0) {
												name = camelCase(name.slice(5));
												dataAttr(elem, name, data[name]);
											}
										}
									}
									dataPriv.set(elem, "hasDataAttrs", true);
								}
							}
							return data;
						}
						if ((typeof key === "undefined" ? "undefined" : _typeof(key)) === "object") {
							return this.each(function () {
								dataUser.set(this, key);
							});
						}
						return access(this, function (value) {
							var data;
							if (elem && value === undefined) {
								data = dataUser.get(elem, key);
								if (data !== undefined) {
									return data;
								}
								data = dataAttr(elem, key);
								if (data !== undefined) {
									return data;
								}
								return;
							}
							this.each(function () {
								dataUser.set(this, key, value);
							});
						}, null, value, arguments.length > 1, null, true);
					},
					removeData: function removeData(key) {
						return this.each(function () {
							dataUser.remove(this, key);
						});
					}
				});
				jQuery.extend({
					queue: function queue(elem, type, data) {
						var queue;
						if (elem) {
							type = (type || "fx") + "queue";
							queue = dataPriv.get(elem, type);
							if (data) {
								if (!queue || Array.isArray(data)) {
									queue = dataPriv.access(elem, type, jQuery.makeArray(data));
								} else {
									queue.push(data);
								}
							}
							return queue || [];
						}
					},
					dequeue: function dequeue(elem, type) {
						type = type || "fx";
						var queue = jQuery.queue(elem, type),
							startLength = queue.length,
							fn = queue.shift(),
							hooks = jQuery._queueHooks(elem, type),
							next = function next() {
								jQuery.dequeue(elem, type);
							};
						if (fn === "inprogress") {
							fn = queue.shift();
							startLength--;
						}
						if (fn) {
							if (type === "fx") {
								queue.unshift("inprogress");
							}
							delete hooks.stop;
							fn.call(elem, next, hooks);
						}
						if (!startLength && hooks) {
							hooks.empty.fire();
						}
					},
					_queueHooks: function _queueHooks(elem, type) {
						var key = type + "queueHooks";
						return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
							empty: jQuery.Callbacks("once memory").add(function () {
								dataPriv.remove(elem, [type + "queue", key]);
							})
						});
					}
				});
				jQuery.fn.extend({
					queue: function queue(type, data) {
						var setter = 2;
						if (typeof type !== "string") {
							data = type;
							type = "fx";
							setter--;
						}
						if (arguments.length < setter) {
							return jQuery.queue(this[0], type);
						}
						return data === undefined ? this : this.each(function () {
							var queue = jQuery.queue(this, type, data);
							jQuery._queueHooks(this, type);
							if (type === "fx" && queue[0] !== "inprogress") {
								jQuery.dequeue(this, type);
							}
						});
					},
					dequeue: function dequeue(type) {
						return this.each(function () {
							jQuery.dequeue(this, type);
						});
					},
					clearQueue: function clearQueue(type) {
						return this.queue(type || "fx", []);
					},
					promise: function promise(type, obj) {
						var tmp, count = 1,
							defer = jQuery.Deferred(),
							elements = this,
							i = this.length,
							resolve = function resolve() {
								if (!--count) {
									defer.resolveWith(elements, [elements]);
								}
							};
						if (typeof type !== "string") {
							obj = type;
							type = undefined;
						}
						type = type || "fx";
						while (i--) {
							tmp = dataPriv.get(elements[i], type + "queueHooks");
							if (tmp && tmp.empty) {
								count++;
								tmp.empty.add(resolve);
							}
						}
						resolve();
						return defer.promise(obj);
					}
				});
				var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
				var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
				var cssExpand = ["Top", "Right", "Bottom", "Left"];
				var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
					elem = el || elem;
					return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
				};
				var swap = function swap(elem, options, callback, args) {
					var ret, name, old = {};
					for (name in options) {
						old[name] = elem.style[name];
						elem.style[name] = options[name];
					}
					ret = callback.apply(elem, args || []);
					for (name in options) {
						elem.style[name] = old[name];
					}
					return ret;
				};

				function adjustCSS(elem, prop, valueParts, tween) {
					var adjusted, scale, maxIterations = 20,
						currentValue = tween ? function () {
							return tween.cur();
						} : function () {
							return jQuery.css(elem, prop, "");
						},
						initial = currentValue(),
						unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
						initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
					if (initialInUnit && initialInUnit[3] !== unit) {
						initial = initial / 2;
						unit = unit || initialInUnit[3];
						initialInUnit = +initial || 1;
						while (maxIterations--) {
							jQuery.style(elem, prop, initialInUnit + unit);
							if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
								maxIterations = 0;
							}
							initialInUnit = initialInUnit / scale;
						}
						initialInUnit = initialInUnit * 2;
						jQuery.style(elem, prop, initialInUnit + unit);
						valueParts = valueParts || [];
					}
					if (valueParts) {
						initialInUnit = +initialInUnit || +initial || 0;
						adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
						if (tween) {
							tween.unit = unit;
							tween.start = initialInUnit;
							tween.end = adjusted;
						}
					}
					return adjusted;
				}
				var defaultDisplayMap = {};

				function getDefaultDisplay(elem) {
					var temp, doc = elem.ownerDocument,
						nodeName = elem.nodeName,
						display = defaultDisplayMap[nodeName];
					if (display) {
						return display;
					}
					temp = doc.body.appendChild(doc.createElement(nodeName));
					display = jQuery.css(temp, "display");
					temp.parentNode.removeChild(temp);
					if (display === "none") {
						display = "block";
					}
					defaultDisplayMap[nodeName] = display;
					return display;
				}

				function showHide(elements, show) {
					var display, elem, values = [],
						index = 0,
						length = elements.length;
					for (; index < length; index++) {
						elem = elements[index];
						if (!elem.style) {
							continue;
						}
						display = elem.style.display;
						if (show) {
							if (display === "none") {
								values[index] = dataPriv.get(elem, "display") || null;
								if (!values[index]) {
									elem.style.display = "";
								}
							}
							if (elem.style.display === "" && isHiddenWithinTree(elem)) {
								values[index] = getDefaultDisplay(elem);
							}
						} else {
							if (display !== "none") {
								values[index] = "none";
								dataPriv.set(elem, "display", display);
							}
						}
					}
					for (index = 0; index < length; index++) {
						if (values[index] != null) {
							elements[index].style.display = values[index];
						}
					}
					return elements;
				}
				jQuery.fn.extend({
					show: function show() {
						return showHide(this, true);
					},
					hide: function hide() {
						return showHide(this);
					},
					toggle: function toggle(state) {
						if (typeof state === "boolean") {
							return state ? this.show() : this.hide();
						}
						return this.each(function () {
							if (isHiddenWithinTree(this)) {
								jQuery(this).show();
							} else {
								jQuery(this).hide();
							}
						});
					}
				});
				var rcheckableType = /^(?:checkbox|radio)$/i;
				var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
				var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
				var wrapMap = {
					option: [1, "<select multiple='multiple'>", "</select>"],
					thead: [1, "<table>", "</table>"],
					col: [2, "<table><colgroup>", "</colgroup></table>"],
					tr: [2, "<table><tbody>", "</tbody></table>"],
					td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
					_default: [0, "", ""]
				};
				wrapMap.optgroup = wrapMap.option;
				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;

				function getAll(context, tag) {
					var ret;
					if (typeof context.getElementsByTagName !== "undefined") {
						ret = context.getElementsByTagName(tag || "*");
					} else if (typeof context.querySelectorAll !== "undefined") {
						ret = context.querySelectorAll(tag || "*");
					} else {
						ret = [];
					}
					if (tag === undefined || tag && nodeName(context, tag)) {
						return jQuery.merge([context], ret);
					}
					return ret;
				}

				function setGlobalEval(elems, refElements) {
					var i = 0,
						l = elems.length;
					for (; i < l; i++) {
						dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
					}
				}
				var rhtml = /<|&#?\w+;/;

				function buildFragment(elems, context, scripts, selection, ignored) {
					var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(),
						nodes = [],
						i = 0,
						l = elems.length;
					for (; i < l; i++) {
						elem = elems[i];
						if (elem || elem === 0) {
							if (toType(elem) === "object") {
								jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
							} else if (!rhtml.test(elem)) {
								nodes.push(context.createTextNode(elem));
							} else {
								tmp = tmp || fragment.appendChild(context.createElement("div"));
								tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
								wrap = wrapMap[tag] || wrapMap._default;
								tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
								j = wrap[0];
								while (j--) {
									tmp = tmp.lastChild;
								}
								jQuery.merge(nodes, tmp.childNodes);
								tmp = fragment.firstChild;
								tmp.textContent = "";
							}
						}
					}
					fragment.textContent = "";
					i = 0;
					while (elem = nodes[i++]) {
						if (selection && jQuery.inArray(elem, selection) > -1) {
							if (ignored) {
								ignored.push(elem);
							}
							continue;
						}
						contains = jQuery.contains(elem.ownerDocument, elem);
						tmp = getAll(fragment.appendChild(elem), "script");
						if (contains) {
							setGlobalEval(tmp);
						}
						if (scripts) {
							j = 0;
							while (elem = tmp[j++]) {
								if (rscriptType.test(elem.type || "")) {
									scripts.push(elem);
								}
							}
						}
					}
					return fragment;
				}
				(function () {
					var fragment = document.createDocumentFragment(),
						div = fragment.appendChild(document.createElement("div")),
						input = document.createElement("input");
					input.setAttribute("type", "radio");
					input.setAttribute("checked", "checked");
					input.setAttribute("name", "t");
					div.appendChild(input);
					support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
					div.innerHTML = "<textarea>x</textarea>";
					support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
				})();
				var documentElement = document.documentElement;
				var rkeyEvent = /^key/,
					rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
					rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

				function returnTrue() {
					return true;
				}

				function returnFalse() {
					return false;
				}

				function safeActiveElement() {
					try {
						return document.activeElement;
					} catch (err) { }
				}

				function _on(elem, types, selector, data, fn, one) {
					var origFn, type;
					if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
						if (typeof selector !== "string") {
							data = data || selector;
							selector = undefined;
						}
						for (type in types) {
							_on(elem, type, selector, data, types[type], one);
						}
						return elem;
					}
					if (data == null && fn == null) {
						fn = selector;
						data = selector = undefined;
					} else if (fn == null) {
						if (typeof selector === "string") {
							fn = data;
							data = undefined;
						} else {
							fn = data;
							data = selector;
							selector = undefined;
						}
					}
					if (fn === false) {
						fn = returnFalse;
					} else if (!fn) {
						return elem;
					}
					if (one === 1) {
						origFn = fn;
						fn = function fn(event) {
							jQuery().off(event);
							return origFn.apply(this, arguments);
						};
						fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
					}
					return elem.each(function () {
						jQuery.event.add(this, types, fn, data, selector);
					});
				}
				jQuery.event = {
					global: {},
					add: function add(elem, types, handler, data, selector) {
						var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
						if (!elemData) {
							return;
						}
						if (handler.handler) {
							handleObjIn = handler;
							handler = handleObjIn.handler;
							selector = handleObjIn.selector;
						}
						if (selector) {
							jQuery.find.matchesSelector(documentElement, selector);
						}
						if (!handler.guid) {
							handler.guid = jQuery.guid++;
						}
						if (!(events = elemData.events)) {
							events = elemData.events = {};
						}
						if (!(eventHandle = elemData.handle)) {
							eventHandle = elemData.handle = function (e) {
								return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
							};
						}
						types = (types || "").match(rnothtmlwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort();
							if (!type) {
								continue;
							}
							special = jQuery.event.special[type] || {};
							type = (selector ? special.delegateType : special.bindType) || type;
							special = jQuery.event.special[type] || {};
							handleObj = jQuery.extend({
								type: type,
								origType: origType,
								data: data,
								handler: handler,
								guid: handler.guid,
								selector: selector,
								needsContext: selector && jQuery.expr.match.needsContext.test(selector),
								namespace: namespaces.join(".")
							}, handleObjIn);
							if (!(handlers = events[type])) {
								handlers = events[type] = [];
								handlers.delegateCount = 0;
								if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
									if (elem.addEventListener) {
										elem.addEventListener(type, eventHandle);
									}
								}
							}
							if (special.add) {
								special.add.call(elem, handleObj);
								if (!handleObj.handler.guid) {
									handleObj.handler.guid = handler.guid;
								}
							}
							if (selector) {
								handlers.splice(handlers.delegateCount++, 0, handleObj);
							} else {
								handlers.push(handleObj);
							}
							jQuery.event.global[type] = true;
						}
					},
					remove: function remove(elem, types, handler, selector, mappedTypes) {
						var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
						if (!elemData || !(events = elemData.events)) {
							return;
						}
						types = (types || "").match(rnothtmlwhite) || [""];
						t = types.length;
						while (t--) {
							tmp = rtypenamespace.exec(types[t]) || [];
							type = origType = tmp[1];
							namespaces = (tmp[2] || "").split(".").sort();
							if (!type) {
								for (type in events) {
									jQuery.event.remove(elem, type + types[t], handler, selector, true);
								}
								continue;
							}
							special = jQuery.event.special[type] || {};
							type = (selector ? special.delegateType : special.bindType) || type;
							handlers = events[type] || [];
							tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
							origCount = j = handlers.length;
							while (j--) {
								handleObj = handlers[j];
								if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
									handlers.splice(j, 1);
									if (handleObj.selector) {
										handlers.delegateCount--;
									}
									if (special.remove) {
										special.remove.call(elem, handleObj);
									}
								}
							}
							if (origCount && !handlers.length) {
								if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
									jQuery.removeEvent(elem, type, elemData.handle);
								}
								delete events[type];
							}
						}
						if (jQuery.isEmptyObject(events)) {
							dataPriv.remove(elem, "handle events");
						}
					},
					dispatch: function dispatch(nativeEvent) {
						var event = jQuery.event.fix(nativeEvent);
						var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length),
							handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
							special = jQuery.event.special[event.type] || {};
						args[0] = event;
						for (i = 1; i < arguments.length; i++) {
							args[i] = arguments[i];
						}
						event.delegateTarget = this;
						if (special.preDispatch && special.preDispatch.call(this, event) === false) {
							return;
						}
						handlerQueue = jQuery.event.handlers.call(this, event, handlers);
						i = 0;
						while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
							event.currentTarget = matched.elem;
							j = 0;
							while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
								if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
									event.handleObj = handleObj;
									event.data = handleObj.data;
									ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
									if (ret !== undefined) {
										if ((event.result = ret) === false) {
											event.preventDefault();
											event.stopPropagation();
										}
									}
								}
							}
						}
						if (special.postDispatch) {
							special.postDispatch.call(this, event);
						}
						return event.result;
					},
					handlers: function handlers(event, _handlers) {
						var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [],
							delegateCount = _handlers.delegateCount,
							cur = event.target;
						if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
							for (; cur !== this; cur = cur.parentNode || this) {
								if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
									matchedHandlers = [];
									matchedSelectors = {};
									for (i = 0; i < delegateCount; i++) {
										handleObj = _handlers[i];
										sel = handleObj.selector + " ";
										if (matchedSelectors[sel] === undefined) {
											matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
										}
										if (matchedSelectors[sel]) {
											matchedHandlers.push(handleObj);
										}
									}
									if (matchedHandlers.length) {
										handlerQueue.push({
											elem: cur,
											handlers: matchedHandlers
										});
									}
								}
							}
						}
						cur = this;
						if (delegateCount < _handlers.length) {
							handlerQueue.push({
								elem: cur,
								handlers: _handlers.slice(delegateCount)
							});
						}
						return handlerQueue;
					},
					addProp: function addProp(name, hook) {
						Object.defineProperty(jQuery.Event.prototype, name, {
							enumerable: true,
							configurable: true,
							get: isFunction(hook) ? function () {
								if (this.originalEvent) {
									return hook(this.originalEvent);
								}
							} : function () {
								if (this.originalEvent) {
									return this.originalEvent[name];
								}
							},
							set: function set(value) {
								Object.defineProperty(this, name, {
									enumerable: true,
									configurable: true,
									writable: true,
									value: value
								});
							}
						});
					},
					fix: function fix(originalEvent) {
						return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
					},
					special: {
						load: {
							noBubble: true
						},
						focus: {
							trigger: function trigger() {
								if (this !== safeActiveElement() && this.focus) {
									this.focus();
									return false;
								}
							},
							delegateType: "focusin"
						},
						blur: {
							trigger: function trigger() {
								if (this === safeActiveElement() && this.blur) {
									this.blur();
									return false;
								}
							},
							delegateType: "focusout"
						},
						click: {
							trigger: function trigger() {
								if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
									this.click();
									return false;
								}
							},
							_default: function _default(event) {
								return nodeName(event.target, "a");
							}
						},
						beforeunload: {
							postDispatch: function postDispatch(event) {
								if (event.result !== undefined && event.originalEvent) {
									event.originalEvent.returnValue = event.result;
								}
							}
						}
					}
				};
				jQuery.removeEvent = function (elem, type, handle) {
					if (elem.removeEventListener) {
						elem.removeEventListener(type, handle);
					}
				};
				jQuery.Event = function (src, props) {
					if (!(this instanceof jQuery.Event)) {
						return new jQuery.Event(src, props);
					}
					if (src && src.type) {
						this.originalEvent = src;
						this.type = src.type;
						this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
						this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
						this.currentTarget = src.currentTarget;
						this.relatedTarget = src.relatedTarget;
					} else {
						this.type = src;
					}
					if (props) {
						jQuery.extend(this, props);
					}
					this.timeStamp = src && src.timeStamp || Date.now();
					this[jQuery.expando] = true;
				};
				jQuery.Event.prototype = {
					constructor: jQuery.Event,
					isDefaultPrevented: returnFalse,
					isPropagationStopped: returnFalse,
					isImmediatePropagationStopped: returnFalse,
					isSimulated: false,
					preventDefault: function preventDefault() {
						var e = this.originalEvent;
						this.isDefaultPrevented = returnTrue;
						if (e && !this.isSimulated) {
							e.preventDefault();
						}
					},
					stopPropagation: function stopPropagation() {
						var e = this.originalEvent;
						this.isPropagationStopped = returnTrue;
						if (e && !this.isSimulated) {
							e.stopPropagation();
						}
					},
					stopImmediatePropagation: function stopImmediatePropagation() {
						var e = this.originalEvent;
						this.isImmediatePropagationStopped = returnTrue;
						if (e && !this.isSimulated) {
							e.stopImmediatePropagation();
						}
						this.stopPropagation();
					}
				};
				jQuery.each({
					altKey: true,
					bubbles: true,
					cancelable: true,
					changedTouches: true,
					ctrlKey: true,
					detail: true,
					eventPhase: true,
					metaKey: true,
					pageX: true,
					pageY: true,
					shiftKey: true,
					view: true,
					"char": true,
					charCode: true,
					key: true,
					keyCode: true,
					button: true,
					buttons: true,
					clientX: true,
					clientY: true,
					offsetX: true,
					offsetY: true,
					pointerId: true,
					pointerType: true,
					screenX: true,
					screenY: true,
					targetTouches: true,
					toElement: true,
					touches: true,
					which: function which(event) {
						var button = event.button;
						if (event.which == null && rkeyEvent.test(event.type)) {
							return event.charCode != null ? event.charCode : event.keyCode;
						}
						if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
							if (button & 1) {
								return 1;
							}
							if (button & 2) {
								return 3;
							}
							if (button & 4) {
								return 2;
							}
							return 0;
						}
						return event.which;
					}
				}, jQuery.event.addProp);
				jQuery.each({
					mouseenter: "mouseover",
					mouseleave: "mouseout",
					pointerenter: "pointerover",
					pointerleave: "pointerout"
				}, function (orig, fix) {
					jQuery.event.special[orig] = {
						delegateType: fix,
						bindType: fix,
						handle: function handle(event) {
							var ret, target = this,
								related = event.relatedTarget,
								handleObj = event.handleObj;
							if (!related || related !== target && !jQuery.contains(target, related)) {
								event.type = handleObj.origType;
								ret = handleObj.handler.apply(this, arguments);
								event.type = fix;
							}
							return ret;
						}
					};
				});
				jQuery.fn.extend({
					on: function on(types, selector, data, fn) {
						return _on(this, types, selector, data, fn);
					},
					one: function one(types, selector, data, fn) {
						return _on(this, types, selector, data, fn, 1);
					},
					off: function off(types, selector, fn) {
						var handleObj, type;
						if (types && types.preventDefault && types.handleObj) {
							handleObj = types.handleObj;
							jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
							return this;
						}
						if ((typeof types === "undefined" ? "undefined" : _typeof(types)) === "object") {
							for (type in types) {
								this.off(type, selector, types[type]);
							}
							return this;
						}
						if (selector === false || typeof selector === "function") {
							fn = selector;
							selector = undefined;
						}
						if (fn === false) {
							fn = returnFalse;
						}
						return this.each(function () {
							jQuery.event.remove(this, types, fn, selector);
						});
					}
				});
				var
					rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
					rnoInnerhtml = /<script|<style|<link/i,
					rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
					rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

				function manipulationTarget(elem, content) {
					if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
						return jQuery(elem).children("tbody")[0] || elem;
					}
					return elem;
				}

				function disableScript(elem) {
					elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
					return elem;
				}

				function restoreScript(elem) {
					if ((elem.type || "").slice(0, 5) === "true/") {
						elem.type = elem.type.slice(5);
					} else {
						elem.removeAttribute("type");
					}
					return elem;
				}

				function cloneCopyEvent(src, dest) {
					var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
					if (dest.nodeType !== 1) {
						return;
					}
					if (dataPriv.hasData(src)) {
						pdataOld = dataPriv.access(src);
						pdataCur = dataPriv.set(dest, pdataOld);
						events = pdataOld.events;
						if (events) {
							delete pdataCur.handle;
							pdataCur.events = {};
							for (type in events) {
								for (i = 0, l = events[type].length; i < l; i++) {
									jQuery.event.add(dest, type, events[type][i]);
								}
							}
						}
					}
					if (dataUser.hasData(src)) {
						udataOld = dataUser.access(src);
						udataCur = jQuery.extend({}, udataOld);
						dataUser.set(dest, udataCur);
					}
				}

				function fixInput(src, dest) {
					var nodeName = dest.nodeName.toLowerCase();
					if (nodeName === "input" && rcheckableType.test(src.type)) {
						dest.checked = src.checked;
					} else if (nodeName === "input" || nodeName === "textarea") {
						dest.defaultValue = src.defaultValue;
					}
				}

				function domManip(collection, args, callback, ignored) {
					args = concat.apply([], args);
					var fragment, first, scripts, hasScripts, node, doc, i = 0,
						l = collection.length,
						iNoClone = l - 1,
						value = args[0],
						valueIsFunction = isFunction(value);
					if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
						return collection.each(function (index) {
							var self = collection.eq(index);
							if (valueIsFunction) {
								args[0] = value.call(this, index, self.html());
							}
							domManip(self, args, callback, ignored);
						});
					}
					if (l) {
						fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
						first = fragment.firstChild;
						if (fragment.childNodes.length === 1) {
							fragment = first;
						}
						if (first || ignored) {
							scripts = jQuery.map(getAll(fragment, "script"), disableScript);
							hasScripts = scripts.length;
							for (; i < l; i++) {
								node = fragment;
								if (i !== iNoClone) {
									node = jQuery.clone(node, true, true);
									if (hasScripts) {
										jQuery.merge(scripts, getAll(node, "script"));
									}
								}
								callback.call(collection[i], node, i);
							}
							if (hasScripts) {
								doc = scripts[scripts.length - 1].ownerDocument;
								jQuery.map(scripts, restoreScript);
								for (i = 0; i < hasScripts; i++) {
									node = scripts[i];
									if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
										if (node.src && (node.type || "").toLowerCase() !== "module") {
											if (jQuery._evalUrl) {
												jQuery._evalUrl(node.src);
											}
										} else {
											DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
										}
									}
								}
							}
						}
					}
					return collection;
				}

				function _remove(elem, selector, keepData) {
					var node, nodes = selector ? jQuery.filter(selector, elem) : elem,
						i = 0;
					for (;
						(node = nodes[i]) != null; i++) {
						if (!keepData && node.nodeType === 1) {
							jQuery.cleanData(getAll(node));
						}
						if (node.parentNode) {
							if (keepData && jQuery.contains(node.ownerDocument, node)) {
								setGlobalEval(getAll(node, "script"));
							}
							node.parentNode.removeChild(node);
						}
					}
					return elem;
				}
				jQuery.extend({
					htmlPrefilter: function htmlPrefilter(html) {
						return html.replace(rxhtmlTag, "<$1></$2>");
					},
					clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
						var i, l, srcElements, destElements, clone = elem.cloneNode(true),
							inPage = jQuery.contains(elem.ownerDocument, elem);
						if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
							destElements = getAll(clone);
							srcElements = getAll(elem);
							for (i = 0, l = srcElements.length; i < l; i++) {
								fixInput(srcElements[i], destElements[i]);
							}
						}
						if (dataAndEvents) {
							if (deepDataAndEvents) {
								srcElements = srcElements || getAll(elem);
								destElements = destElements || getAll(clone);
								for (i = 0, l = srcElements.length; i < l; i++) {
									cloneCopyEvent(srcElements[i], destElements[i]);
								}
							} else {
								cloneCopyEvent(elem, clone);
							}
						}
						destElements = getAll(clone, "script");
						if (destElements.length > 0) {
							setGlobalEval(destElements, !inPage && getAll(elem, "script"));
						}
						return clone;
					},
					cleanData: function cleanData(elems) {
						var data, elem, type, special = jQuery.event.special,
							i = 0;
						for (;
							(elem = elems[i]) !== undefined; i++) {
							if (acceptData(elem)) {
								if (data = elem[dataPriv.expando]) {
									if (data.events) {
										for (type in data.events) {
											if (special[type]) {
												jQuery.event.remove(elem, type);
											} else {
												jQuery.removeEvent(elem, type, data.handle);
											}
										}
									}
									elem[dataPriv.expando] = undefined;
								}
								if (elem[dataUser.expando]) {
									elem[dataUser.expando] = undefined;
								}
							}
						}
					}
				});
				jQuery.fn.extend({
					detach: function detach(selector) {
						return _remove(this, selector, true);
					},
					remove: function remove(selector) {
						return _remove(this, selector);
					},
					text: function text(value) {
						return access(this, function (value) {
							return value === undefined ? jQuery.text(this) : this.empty().each(function () {
								if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
									this.textContent = value;
								}
							});
						}, null, value, arguments.length);
					},
					append: function append() {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.appendChild(elem);
							}
						});
					},
					prepend: function prepend() {
						return domManip(this, arguments, function (elem) {
							if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
								var target = manipulationTarget(this, elem);
								target.insertBefore(elem, target.firstChild);
							}
						});
					},
					before: function before() {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this);
							}
						});
					},
					after: function after() {
						return domManip(this, arguments, function (elem) {
							if (this.parentNode) {
								this.parentNode.insertBefore(elem, this.nextSibling);
							}
						});
					},
					empty: function empty() {
						var elem, i = 0;
						for (;
							(elem = this[i]) != null; i++) {
							if (elem.nodeType === 1) {
								jQuery.cleanData(getAll(elem, false));
								elem.textContent = "";
							}
						}
						return this;
					},
					clone: function clone(dataAndEvents, deepDataAndEvents) {
						dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
						deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
						return this.map(function () {
							return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
						});
					},
					html: function html(value) {
						return access(this, function (value) {
							var elem = this[0] || {},
								i = 0,
								l = this.length;
							if (value === undefined && elem.nodeType === 1) {
								return elem.innerHTML;
							}
							if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
								value = jQuery.htmlPrefilter(value);
								try {
									for (; i < l; i++) {
										elem = this[i] || {};
										if (elem.nodeType === 1) {
											jQuery.cleanData(getAll(elem, false));
											elem.innerHTML = value;
										}
									}
									elem = 0;
								} catch (e) { }
							}
							if (elem) {
								this.empty().append(value);
							}
						}, null, value, arguments.length);
					},
					replaceWith: function replaceWith() {
						var ignored = [];
						return domManip(this, arguments, function (elem) {
							var parent = this.parentNode;
							if (jQuery.inArray(this, ignored) < 0) {
								jQuery.cleanData(getAll(this));
								if (parent) {
									parent.replaceChild(elem, this);
								}
							}
						}, ignored);
					}
				});
				jQuery.each({
					appendTo: "append",
					prependTo: "prepend",
					insertBefore: "before",
					insertAfter: "after",
					replaceAll: "replaceWith"
				}, function (name, original) {
					jQuery.fn[name] = function (selector) {
						var elems, ret = [],
							insert = jQuery(selector),
							last = insert.length - 1,
							i = 0;
						for (; i <= last; i++) {
							elems = i === last ? this : this.clone(true);
							jQuery(insert[i])[original](elems);
							push.apply(ret, elems.get());
						}
						return this.pushStack(ret);
					};
				});
				var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
				var getStyles = function getStyles(elem) {
					var view = elem.ownerDocument.defaultView;
					if (!view || !view.opener) {
						view = window;
					}
					return view.getComputedStyle(elem);
				};
				var rboxStyle = new RegExp(cssExpand.join("|"), "i");
				(function () {
					function computeStyleTests() {
						if (!div) {
							return;
						}
						container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
						div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
						documentElement.appendChild(container).appendChild(div);
						var divStyle = window.getComputedStyle(div);
						pixelPositionVal = divStyle.top !== "1%";
						reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
						div.style.right = "60%";
						pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
						boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
						div.style.position = "absolute";
						scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
						documentElement.removeChild(container);
						div = null;
					}

					function roundPixelMeasures(measure) {
						return Math.round(parseFloat(measure));
					}
					var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"),
						div = document.createElement("div");
					if (!div.style) {
						return;
					}
					div.style.backgroundClip = "content-box";
					div.cloneNode(true).style.backgroundClip = "";
					support.clearCloneStyle = div.style.backgroundClip === "content-box";
					jQuery.extend(support, {
						boxSizingReliable: function boxSizingReliable() {
							computeStyleTests();
							return boxSizingReliableVal;
						},
						pixelBoxStyles: function pixelBoxStyles() {
							computeStyleTests();
							return pixelBoxStylesVal;
						},
						pixelPosition: function pixelPosition() {
							computeStyleTests();
							return pixelPositionVal;
						},
						reliableMarginLeft: function reliableMarginLeft() {
							computeStyleTests();
							return reliableMarginLeftVal;
						},
						scrollboxSize: function scrollboxSize() {
							computeStyleTests();
							return scrollboxSizeVal;
						}
					});
				})();

				function curCSS(elem, name, computed) {
					var width, minWidth, maxWidth, ret, style = elem.style;
					computed = computed || getStyles(elem);
					if (computed) {
						ret = computed.getPropertyValue(name) || computed[name];
						if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
							ret = jQuery.style(elem, name);
						}
						if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
							width = style.width;
							minWidth = style.minWidth;
							maxWidth = style.maxWidth;
							style.minWidth = style.maxWidth = style.width = ret;
							ret = computed.width;
							style.width = width;
							style.minWidth = minWidth;
							style.maxWidth = maxWidth;
						}
					}
					return ret !== undefined ? ret + "" : ret;
				}

				function addGetHookIf(conditionFn, hookFn) {
					return {
						get: function get() {
							if (conditionFn()) {
								delete this.get;
								return;
							}
							return (this.get = hookFn).apply(this, arguments);
						}
					};
				}
				var
					rdisplayswap = /^(none|table(?!-c[ea]).+)/,
					rcustomProp = /^--/,
					cssShow = {
						position: "absolute",
						visibility: "hidden",
						display: "block"
					},
					cssNormalTransform = {
						letterSpacing: "0",
						fontWeight: "400"
					},
					cssPrefixes = ["Webkit", "Moz", "ms"],
					emptyStyle = document.createElement("div").style;

				function vendorPropName(name) {
					if (name in emptyStyle) {
						return name;
					}
					var capName = name[0].toUpperCase() + name.slice(1),
						i = cssPrefixes.length;
					while (i--) {
						name = cssPrefixes[i] + capName;
						if (name in emptyStyle) {
							return name;
						}
					}
				}

				function finalPropName(name) {
					var ret = jQuery.cssProps[name];
					if (!ret) {
						ret = jQuery.cssProps[name] = vendorPropName(name) || name;
					}
					return ret;
				}

				function setPositiveNumber(elem, value, subtract) {
					var matches = rcssNum.exec(value);
					return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
				}

				function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
					var i = dimension === "width" ? 1 : 0,
						extra = 0,
						delta = 0;
					if (box === (isBorderBox ? "border" : "content")) {
						return 0;
					}
					for (; i < 4; i += 2) {
						if (box === "margin") {
							delta += jQuery.css(elem, box + cssExpand[i], true, styles);
						}
						if (!isBorderBox) {
							delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
							if (box !== "padding") {
								delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							} else {
								extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						} else {
							if (box === "content") {
								delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
							}
							if (box !== "margin") {
								delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
							}
						}
					}
					if (!isBorderBox && computedVal >= 0) {
						delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
					}
					return delta;
				}

				function getWidthOrHeight(elem, dimension, extra) {
					var styles = getStyles(elem),
						val = curCSS(elem, dimension, styles),
						isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
						valueIsBorderBox = isBorderBox;
					if (rnumnonpx.test(val)) {
						if (!extra) {
							return val;
						}
						val = "auto";
					}
					valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
					if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
						val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
						valueIsBorderBox = true;
					}
					val = parseFloat(val) || 0;
					return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
				}
				jQuery.extend({
					cssHooks: {
						opacity: {
							get: function get(elem, computed) {
								if (computed) {
									var ret = curCSS(elem, "opacity");
									return ret === "" ? "1" : ret;
								}
							}
						}
					},
					cssNumber: {
						"animationIterationCount": true,
						"columnCount": true,
						"fillOpacity": true,
						"flexGrow": true,
						"flexShrink": true,
						"fontWeight": true,
						"lineHeight": true,
						"opacity": true,
						"order": true,
						"orphans": true,
						"widows": true,
						"zIndex": true,
						"zoom": true
					},
					cssProps: {},
					style: function style(elem, name, value, extra) {
						if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
							return;
						}
						var ret, type, hooks, origName = camelCase(name),
							isCustomProp = rcustomProp.test(name),
							style = elem.style;
						if (!isCustomProp) {
							name = finalPropName(origName);
						}
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
						if (value !== undefined) {
							type = typeof value === "undefined" ? "undefined" : _typeof(value);
							if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
								value = adjustCSS(elem, name, ret);
								type = "number";
							}
							if (value == null || value !== value) {
								return;
							}
							if (type === "number") {
								value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
							}
							if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
								style[name] = "inherit";
							}
							if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
								if (isCustomProp) {
									style.setProperty(name, value);
								} else {
									style[name] = value;
								}
							}
						} else {
							if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
								return ret;
							}
							return style[name];
						}
					},
					css: function css(elem, name, extra, styles) {
						var val, num, hooks, origName = camelCase(name),
							isCustomProp = rcustomProp.test(name);
						if (!isCustomProp) {
							name = finalPropName(origName);
						}
						hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
						if (hooks && "get" in hooks) {
							val = hooks.get(elem, true, extra);
						}
						if (val === undefined) {
							val = curCSS(elem, name, styles);
						}
						if (val === "normal" && name in cssNormalTransform) {
							val = cssNormalTransform[name];
						}
						if (extra === "" || extra) {
							num = parseFloat(val);
							return extra === true || isFinite(num) ? num || 0 : val;
						}
						return val;
					}
				});
				jQuery.each(["height", "width"], function (i, dimension) {
					jQuery.cssHooks[dimension] = {
						get: function get(elem, computed, extra) {
							if (computed) {
								return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
									return getWidthOrHeight(elem, dimension, extra);
								}) : getWidthOrHeight(elem, dimension, extra);
							}
						},
						set: function set(elem, value, extra) {
							var matches, styles = getStyles(elem),
								isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
								subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
							if (isBorderBox && support.scrollboxSize() === styles.position) {
								subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
							}
							if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
								elem.style[dimension] = value;
								value = jQuery.css(elem, dimension);
							}
							return setPositiveNumber(elem, value, subtract);
						}
					};
				});
				jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
					if (computed) {
						return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
							marginLeft: 0
						}, function () {
							return elem.getBoundingClientRect().left;
						})) + "px";
					}
				});
				jQuery.each({
					margin: "",
					padding: "",
					border: "Width"
				}, function (prefix, suffix) {
					jQuery.cssHooks[prefix + suffix] = {
						expand: function expand(value) {
							var i = 0,
								expanded = {},
								parts = typeof value === "string" ? value.split(" ") : [value];
							for (; i < 4; i++) {
								expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
							}
							return expanded;
						}
					};
					if (prefix !== "margin") {
						jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
					}
				});
				jQuery.fn.extend({
					css: function css(name, value) {
						return access(this, function (elem, name, value) {
							var styles, len, map = {},
								i = 0;
							if (Array.isArray(name)) {
								styles = getStyles(elem);
								len = name.length;
								for (; i < len; i++) {
									map[name[i]] = jQuery.css(elem, name[i], false, styles);
								}
								return map;
							}
							return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
						}, name, value, arguments.length > 1);
					}
				});

				function Tween(elem, options, prop, end, easing) {
					return new Tween.prototype.init(elem, options, prop, end, easing);
				}
				jQuery.Tween = Tween;
				Tween.prototype = {
					constructor: Tween,
					init: function init(elem, options, prop, end, easing, unit) {
						this.elem = elem;
						this.prop = prop;
						this.easing = easing || jQuery.easing._default;
						this.options = options;
						this.start = this.now = this.cur();
						this.end = end;
						this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
					},
					cur: function cur() {
						var hooks = Tween.propHooks[this.prop];
						return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
					},
					run: function run(percent) {
						var eased, hooks = Tween.propHooks[this.prop];
						if (this.options.duration) {
							this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
						} else {
							this.pos = eased = percent;
						}
						this.now = (this.end - this.start) * eased + this.start;
						if (this.options.step) {
							this.options.step.call(this.elem, this.now, this);
						}
						if (hooks && hooks.set) {
							hooks.set(this);
						} else {
							Tween.propHooks._default.set(this);
						}
						return this;
					}
				};
				Tween.prototype.init.prototype = Tween.prototype;
				Tween.propHooks = {
					_default: {
						get: function get(tween) {
							var result;
							if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
								return tween.elem[tween.prop];
							}
							result = jQuery.css(tween.elem, tween.prop, "");
							return !result || result === "auto" ? 0 : result;
						},
						set: function set(tween) {
							if (jQuery.fx.step[tween.prop]) {
								jQuery.fx.step[tween.prop](tween);
							} else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
								jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
							} else {
								tween.elem[tween.prop] = tween.now;
							}
						}
					}
				};
				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
					set: function set(tween) {
						if (tween.elem.nodeType && tween.elem.parentNode) {
							tween.elem[tween.prop] = tween.now;
						}
					}
				};
				jQuery.easing = {
					linear: function linear(p) {
						return p;
					},
					swing: function swing(p) {
						return 0.5 - Math.cos(p * Math.PI) / 2;
					},
					_default: "swing"
				};
				jQuery.fx = Tween.prototype.init;
				jQuery.fx.step = {};
				var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/,
					rrun = /queueHooks$/;

				function schedule() {
					if (inProgress) {
						if (document.hidden === false && window.requestAnimationFrame) {
							window.requestAnimationFrame(schedule);
						} else {
							window.setTimeout(schedule, jQuery.fx.interval);
						}
						jQuery.fx.tick();
					}
				}

				function createFxNow() {
					window.setTimeout(function () {
						fxNow = undefined;
					});
					return fxNow = Date.now();
				}

				function genFx(type, includeWidth) {
					var which, i = 0,
						attrs = {
							height: type
						};
					includeWidth = includeWidth ? 1 : 0;
					for (; i < 4; i += 2 - includeWidth) {
						which = cssExpand[i];
						attrs["margin" + which] = attrs["padding" + which] = type;
					}
					if (includeWidth) {
						attrs.opacity = attrs.width = type;
					}
					return attrs;
				}

				function createTween(value, prop, animation) {
					var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
						index = 0,
						length = collection.length;
					for (; index < length; index++) {
						if (tween = collection[index].call(animation, prop, value)) {
							return tween;
						}
					}
				}

				function defaultPrefilter(elem, props, opts) {
					var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props,
						anim = this,
						orig = {},
						style = elem.style,
						hidden = elem.nodeType && isHiddenWithinTree(elem),
						dataShow = dataPriv.get(elem, "fxshow");
					if (!opts.queue) {
						hooks = jQuery._queueHooks(elem, "fx");
						if (hooks.unqueued == null) {
							hooks.unqueued = 0;
							oldfire = hooks.empty.fire;
							hooks.empty.fire = function () {
								if (!hooks.unqueued) {
									oldfire();
								}
							};
						}
						hooks.unqueued++;
						anim.always(function () {
							anim.always(function () {
								hooks.unqueued--;
								if (!jQuery.queue(elem, "fx").length) {
									hooks.empty.fire();
								}
							});
						});
					}
					for (prop in props) {
						value = props[prop];
						if (rfxtypes.test(value)) {
							delete props[prop];
							toggle = toggle || value === "toggle";
							if (value === (hidden ? "hide" : "show")) {
								if (value === "show" && dataShow && dataShow[prop] !== undefined) {
									hidden = true;
								} else {
									continue;
								}
							}
							orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
						}
					}
					propTween = !jQuery.isEmptyObject(props);
					if (!propTween && jQuery.isEmptyObject(orig)) {
						return;
					}
					if (isBox && elem.nodeType === 1) {
						opts.overflow = [style.overflow, style.overflowX, style.overflowY];
						restoreDisplay = dataShow && dataShow.display;
						if (restoreDisplay == null) {
							restoreDisplay = dataPriv.get(elem, "display");
						}
						display = jQuery.css(elem, "display");
						if (display === "none") {
							if (restoreDisplay) {
								display = restoreDisplay;
							} else {
								showHide([elem], true);
								restoreDisplay = elem.style.display || restoreDisplay;
								display = jQuery.css(elem, "display");
								showHide([elem]);
							}
						}
						if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
							if (jQuery.css(elem, "float") === "none") {
								if (!propTween) {
									anim.done(function () {
										style.display = restoreDisplay;
									});
									if (restoreDisplay == null) {
										display = style.display;
										restoreDisplay = display === "none" ? "" : display;
									}
								}
								style.display = "inline-block";
							}
						}
					}
					if (opts.overflow) {
						style.overflow = "hidden";
						anim.always(function () {
							style.overflow = opts.overflow[0];
							style.overflowX = opts.overflow[1];
							style.overflowY = opts.overflow[2];
						});
					}
					propTween = false;
					for (prop in orig) {
						if (!propTween) {
							if (dataShow) {
								if ("hidden" in dataShow) {
									hidden = dataShow.hidden;
								}
							} else {
								dataShow = dataPriv.access(elem, "fxshow", {
									display: restoreDisplay
								});
							}
							if (toggle) {
								dataShow.hidden = !hidden;
							}
							if (hidden) {
								showHide([elem], true);
							}
							anim.done(function () {
								if (!hidden) {
									showHide([elem]);
								}
								dataPriv.remove(elem, "fxshow");
								for (prop in orig) {
									jQuery.style(elem, prop, orig[prop]);
								}
							});
						}
						propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
						if (!(prop in dataShow)) {
							dataShow[prop] = propTween.start;
							if (hidden) {
								propTween.end = propTween.start;
								propTween.start = 0;
							}
						}
					}
				}

				function propFilter(props, specialEasing) {
					var index, name, easing, value, hooks;
					for (index in props) {
						name = camelCase(index);
						easing = specialEasing[name];
						value = props[index];
						if (Array.isArray(value)) {
							easing = value[1];
							value = props[index] = value[0];
						}
						if (index !== name) {
							props[name] = value;
							delete props[index];
						}
						hooks = jQuery.cssHooks[name];
						if (hooks && "expand" in hooks) {
							value = hooks.expand(value);
							delete props[name];
							for (index in value) {
								if (!(index in props)) {
									props[index] = value[index];
									specialEasing[index] = easing;
								}
							}
						} else {
							specialEasing[name] = easing;
						}
					}
				}

				function Animation(elem, properties, options) {
					var result, stopped, index = 0,
						length = Animation.prefilters.length,
						deferred = jQuery.Deferred().always(function () {
							delete tick.elem;
						}),
						tick = function tick() {
							if (stopped) {
								return false;
							}
							var currentTime = fxNow || createFxNow(),
								remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
								temp = remaining / animation.duration || 0,
								percent = 1 - temp,
								index = 0,
								length = animation.tweens.length;
							for (; index < length; index++) {
								animation.tweens[index].run(percent);
							}
							deferred.notifyWith(elem, [animation, percent, remaining]);
							if (percent < 1 && length) {
								return remaining;
							}
							if (!length) {
								deferred.notifyWith(elem, [animation, 1, 0]);
							}
							deferred.resolveWith(elem, [animation]);
							return false;
						},
						animation = deferred.promise({
							elem: elem,
							props: jQuery.extend({}, properties),
							opts: jQuery.extend(true, {
								specialEasing: {},
								easing: jQuery.easing._default
							}, options),
							originalProperties: properties,
							originalOptions: options,
							startTime: fxNow || createFxNow(),
							duration: options.duration,
							tweens: [],
							createTween: function createTween(prop, end) {
								var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
								animation.tweens.push(tween);
								return tween;
							},
							stop: function stop(gotoEnd) {
								var index = 0,
									length = gotoEnd ? animation.tweens.length : 0;
								if (stopped) {
									return this;
								}
								stopped = true;
								for (; index < length; index++) {
									animation.tweens[index].run(1);
								}
								if (gotoEnd) {
									deferred.notifyWith(elem, [animation, 1, 0]);
									deferred.resolveWith(elem, [animation, gotoEnd]);
								} else {
									deferred.rejectWith(elem, [animation, gotoEnd]);
								}
								return this;
							}
						}),
						props = animation.props;
					propFilter(props, animation.opts.specialEasing);
					for (; index < length; index++) {
						result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
						if (result) {
							if (isFunction(result.stop)) {
								jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
							}
							return result;
						}
					}
					jQuery.map(props, createTween, animation);
					if (isFunction(animation.opts.start)) {
						animation.opts.start.call(elem, animation);
					}
					animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
					jQuery.fx.timer(jQuery.extend(tick, {
						elem: elem,
						anim: animation,
						queue: animation.opts.queue
					}));
					return animation;
				}
				jQuery.Animation = jQuery.extend(Animation, {
					tweeners: {
						"*": [function (prop, value) {
							var tween = this.createTween(prop, value);
							adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
							return tween;
						}]
					},
					tweener: function tweener(props, callback) {
						if (isFunction(props)) {
							callback = props;
							props = ["*"];
						} else {
							props = props.match(rnothtmlwhite);
						}
						var prop, index = 0,
							length = props.length;
						for (; index < length; index++) {
							prop = props[index];
							Animation.tweeners[prop] = Animation.tweeners[prop] || [];
							Animation.tweeners[prop].unshift(callback);
						}
					},
					prefilters: [defaultPrefilter],
					prefilter: function prefilter(callback, prepend) {
						if (prepend) {
							Animation.prefilters.unshift(callback);
						} else {
							Animation.prefilters.push(callback);
						}
					}
				});
				jQuery.speed = function (speed, easing, fn) {
					var opt = speed && (typeof speed === "undefined" ? "undefined" : _typeof(speed)) === "object" ? jQuery.extend({}, speed) : {
						complete: fn || !fn && easing || isFunction(speed) && speed,
						duration: speed,
						easing: fn && easing || easing && !isFunction(easing) && easing
					};
					if (jQuery.fx.off) {
						opt.duration = 0;
					} else {
						if (typeof opt.duration !== "number") {
							if (opt.duration in jQuery.fx.speeds) {
								opt.duration = jQuery.fx.speeds[opt.duration];
							} else {
								opt.duration = jQuery.fx.speeds._default;
							}
						}
					}
					if (opt.queue == null || opt.queue === true) {
						opt.queue = "fx";
					}
					opt.old = opt.complete;
					opt.complete = function () {
						if (isFunction(opt.old)) {
							opt.old.call(this);
						}
						if (opt.queue) {
							jQuery.dequeue(this, opt.queue);
						}
					};
					return opt;
				};
				jQuery.fn.extend({
					fadeTo: function fadeTo(speed, to, easing, callback) {
						return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
							opacity: to
						}, speed, easing, callback);
					},
					animate: function animate(prop, speed, easing, callback) {
						var empty = jQuery.isEmptyObject(prop),
							optall = jQuery.speed(speed, easing, callback),
							doAnimation = function doAnimation() {
								var anim = Animation(this, jQuery.extend({}, prop), optall);
								if (empty || dataPriv.get(this, "finish")) {
									anim.stop(true);
								}
							};
						doAnimation.finish = doAnimation;
						return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
					},
					stop: function stop(type, clearQueue, gotoEnd) {
						var stopQueue = function stopQueue(hooks) {
							var stop = hooks.stop;
							delete hooks.stop;
							stop(gotoEnd);
						};
						if (typeof type !== "string") {
							gotoEnd = clearQueue;
							clearQueue = type;
							type = undefined;
						}
						if (clearQueue && type !== false) {
							this.queue(type || "fx", []);
						}
						return this.each(function () {
							var dequeue = true,
								index = type != null && type + "queueHooks",
								timers = jQuery.timers,
								data = dataPriv.get(this);
							if (index) {
								if (data[index] && data[index].stop) {
									stopQueue(data[index]);
								}
							} else {
								for (index in data) {
									if (data[index] && data[index].stop && rrun.test(index)) {
										stopQueue(data[index]);
									}
								}
							}
							for (index = timers.length; index--;) {
								if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
									timers[index].anim.stop(gotoEnd);
									dequeue = false;
									timers.splice(index, 1);
								}
							}
							if (dequeue || !gotoEnd) {
								jQuery.dequeue(this, type);
							}
						});
					},
					finish: function finish(type) {
						if (type !== false) {
							type = type || "fx";
						}
						return this.each(function () {
							var index, data = dataPriv.get(this),
								queue = data[type + "queue"],
								hooks = data[type + "queueHooks"],
								timers = jQuery.timers,
								length = queue ? queue.length : 0;
							data.finish = true;
							jQuery.queue(this, type, []);
							if (hooks && hooks.stop) {
								hooks.stop.call(this, true);
							}
							for (index = timers.length; index--;) {
								if (timers[index].elem === this && timers[index].queue === type) {
									timers[index].anim.stop(true);
									timers.splice(index, 1);
								}
							}
							for (index = 0; index < length; index++) {
								if (queue[index] && queue[index].finish) {
									queue[index].finish.call(this);
								}
							}
							delete data.finish;
						});
					}
				});
				jQuery.each(["toggle", "show", "hide"], function (i, name) {
					var cssFn = jQuery.fn[name];
					jQuery.fn[name] = function (speed, easing, callback) {
						return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
					};
				});
				jQuery.each({
					slideDown: genFx("show"),
					slideUp: genFx("hide"),
					slideToggle: genFx("toggle"),
					fadeIn: {
						opacity: "show"
					},
					fadeOut: {
						opacity: "hide"
					},
					fadeToggle: {
						opacity: "toggle"
					}
				}, function (name, props) {
					jQuery.fn[name] = function (speed, easing, callback) {
						return this.animate(props, speed, easing, callback);
					};
				});
				jQuery.timers = [];
				jQuery.fx.tick = function () {
					var timer, i = 0,
						timers = jQuery.timers;
					fxNow = Date.now();
					for (; i < timers.length; i++) {
						timer = timers[i];
						if (!timer() && timers[i] === timer) {
							timers.splice(i--, 1);
						}
					}
					if (!timers.length) {
						jQuery.fx.stop();
					}
					fxNow = undefined;
				};
				jQuery.fx.timer = function (timer) {
					jQuery.timers.push(timer);
					jQuery.fx.start();
				};
				jQuery.fx.interval = 13;
				jQuery.fx.start = function () {
					if (inProgress) {
						return;
					}
					inProgress = true;
					schedule();
				};
				jQuery.fx.stop = function () {
					inProgress = null;
				};
				jQuery.fx.speeds = {
					slow: 600,
					fast: 200,
					_default: 400
				};
				jQuery.fn.delay = function (time, type) {
					time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
					type = type || "fx";
					return this.queue(type, function (next, hooks) {
						var timeout = window.setTimeout(next, time);
						hooks.stop = function () {
							window.clearTimeout(timeout);
						};
					});
				};
				(function () {
					var input = document.createElement("input"),
						select = document.createElement("select"),
						opt = select.appendChild(document.createElement("option"));
					input.type = "checkbox";
					support.checkOn = input.value !== "";
					support.optSelected = opt.selected;
					input = document.createElement("input");
					input.value = "t";
					input.type = "radio";
					support.radioValue = input.value === "t";
				})();
				var boolHook, attrHandle = jQuery.expr.attrHandle;
				jQuery.fn.extend({
					attr: function attr(name, value) {
						return access(this, jQuery.attr, name, value, arguments.length > 1);
					},
					removeAttr: function removeAttr(name) {
						return this.each(function () {
							jQuery.removeAttr(this, name);
						});
					}
				});
				jQuery.extend({
					attr: function attr(elem, name, value) {
						var ret, hooks, nType = elem.nodeType;
						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						}
						if (typeof elem.getAttribute === "undefined") {
							return jQuery.prop(elem, name, value);
						}
						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
							hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
						}
						if (value !== undefined) {
							if (value === null) {
								jQuery.removeAttr(elem, name);
								return;
							}
							if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}
							elem.setAttribute(name, value + "");
							return value;
						}
						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}
						ret = jQuery.find.attr(elem, name);
						return ret == null ? undefined : ret;
					},
					attrHooks: {
						type: {
							set: function set(elem, value) {
								if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
									var val = elem.value;
									elem.setAttribute("type", value);
									if (val) {
										elem.value = val;
									}
									return value;
								}
							}
						}
					},
					removeAttr: function removeAttr(elem, value) {
						var name, i = 0,
							attrNames = value && value.match(rnothtmlwhite);
						if (attrNames && elem.nodeType === 1) {
							while (name = attrNames[i++]) {
								elem.removeAttribute(name);
							}
						}
					}
				});
				boolHook = {
					set: function set(elem, value, name) {
						if (value === false) {
							jQuery.removeAttr(elem, name);
						} else {
							elem.setAttribute(name, name);
						}
						return name;
					}
				};
				jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
					var getter = attrHandle[name] || jQuery.find.attr;
					attrHandle[name] = function (elem, name, isXML) {
						var ret, handle, lowercaseName = name.toLowerCase();
						if (!isXML) {
							handle = attrHandle[lowercaseName];
							attrHandle[lowercaseName] = ret;
							ret = getter(elem, name, isXML) != null ? lowercaseName : null;
							attrHandle[lowercaseName] = handle;
						}
						return ret;
					};
				});
				var rfocusable = /^(?:input|select|textarea|button)$/i,
					rclickable = /^(?:a|area)$/i;
				jQuery.fn.extend({
					prop: function prop(name, value) {
						return access(this, jQuery.prop, name, value, arguments.length > 1);
					},
					removeProp: function removeProp(name) {
						return this.each(function () {
							delete this[jQuery.propFix[name] || name];
						});
					}
				});
				jQuery.extend({
					prop: function prop(elem, name, value) {
						var ret, hooks, nType = elem.nodeType;
						if (nType === 3 || nType === 8 || nType === 2) {
							return;
						}
						if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
							name = jQuery.propFix[name] || name;
							hooks = jQuery.propHooks[name];
						}
						if (value !== undefined) {
							if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
								return ret;
							}
							return elem[name] = value;
						}
						if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
							return ret;
						}
						return elem[name];
					},
					propHooks: {
						tabIndex: {
							get: function get(elem) {
								var tabindex = jQuery.find.attr(elem, "tabindex");
								if (tabindex) {
									return parseInt(tabindex, 10);
								}
								if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
									return 0;
								}
								return -1;
							}
						}
					},
					propFix: {
						"for": "htmlFor",
						"class": "className"
					}
				});
				if (!support.optSelected) {
					jQuery.propHooks.selected = {
						get: function get(elem) {
							var parent = elem.parentNode;
							if (parent && parent.parentNode) {
								parent.parentNode.selectedIndex;
							}
							return null;
						},
						set: function set(elem) {
							var parent = elem.parentNode;
							if (parent) {
								parent.selectedIndex;
								if (parent.parentNode) {
									parent.parentNode.selectedIndex;
								}
							}
						}
					};
				}
				jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
					jQuery.propFix[this.toLowerCase()] = this;
				});

				function stripAndCollapse(value) {
					var tokens = value.match(rnothtmlwhite) || [];
					return tokens.join(" ");
				}

				function getClass(elem) {
					return elem.getAttribute && elem.getAttribute("class") || "";
				}

				function classesToArray(value) {
					if (Array.isArray(value)) {
						return value;
					}
					if (typeof value === "string") {
						return value.match(rnothtmlwhite) || [];
					}
					return [];
				}
				jQuery.fn.extend({
					addClass: function addClass(value) {
						var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
						if (isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).addClass(value.call(this, j, getClass(this)));
							});
						}
						classes = classesToArray(value);
						if (classes.length) {
							while (elem = this[i++]) {
								curValue = getClass(elem);
								cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
								if (cur) {
									j = 0;
									while (clazz = classes[j++]) {
										if (cur.indexOf(" " + clazz + " ") < 0) {
											cur += clazz + " ";
										}
									}
									finalValue = stripAndCollapse(cur);
									if (curValue !== finalValue) {
										elem.setAttribute("class", finalValue);
									}
								}
							}
						}
						return this;
					},
					removeClass: function removeClass(value) {
						var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
						if (isFunction(value)) {
							return this.each(function (j) {
								jQuery(this).removeClass(value.call(this, j, getClass(this)));
							});
						}
						if (!arguments.length) {
							return this.attr("class", "");
						}
						classes = classesToArray(value);
						if (classes.length) {
							while (elem = this[i++]) {
								curValue = getClass(elem);
								cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
								if (cur) {
									j = 0;
									while (clazz = classes[j++]) {
										while (cur.indexOf(" " + clazz + " ") > -1) {
											cur = cur.replace(" " + clazz + " ", " ");
										}
									}
									finalValue = stripAndCollapse(cur);
									if (curValue !== finalValue) {
										elem.setAttribute("class", finalValue);
									}
								}
							}
						}
						return this;
					},
					toggleClass: function toggleClass(value, stateVal) {
						var type = typeof value === "undefined" ? "undefined" : _typeof(value),
							isValidValue = type === "string" || Array.isArray(value);
						if (typeof stateVal === "boolean" && isValidValue) {
							return stateVal ? this.addClass(value) : this.removeClass(value);
						}
						if (isFunction(value)) {
							return this.each(function (i) {
								jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
							});
						}
						return this.each(function () {
							var className, i, self, classNames;
							if (isValidValue) {
								i = 0;
								self = jQuery(this);
								classNames = classesToArray(value);
								while (className = classNames[i++]) {
									if (self.hasClass(className)) {
										self.removeClass(className);
									} else {
										self.addClass(className);
									}
								}
							} else if (value === undefined || type === "boolean") {
								className = getClass(this);
								if (className) {
									dataPriv.set(this, "__className__", className);
								}
								if (this.setAttribute) {
									this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
								}
							}
						});
					},
					hasClass: function hasClass(selector) {
						var className, elem, i = 0;
						className = " " + selector + " ";
						while (elem = this[i++]) {
							if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
								return true;
							}
						}
						return false;
					}
				});
				var rreturn = /\r/g;
				jQuery.fn.extend({
					val: function val(value) {
						var hooks, ret, valueIsFunction, elem = this[0];
						if (!arguments.length) {
							if (elem) {
								hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
								if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
									return ret;
								}
								ret = elem.value;
								if (typeof ret === "string") {
									return ret.replace(rreturn, "");
								}
								return ret == null ? "" : ret;
							}
							return;
						}
						valueIsFunction = isFunction(value);
						return this.each(function (i) {
							var val;
							if (this.nodeType !== 1) {
								return;
							}
							if (valueIsFunction) {
								val = value.call(this, i, jQuery(this).val());
							} else {
								val = value;
							}
							if (val == null) {
								val = "";
							} else if (typeof val === "number") {
								val += "";
							} else if (Array.isArray(val)) {
								val = jQuery.map(val, function (value) {
									return value == null ? "" : value + "";
								});
							}
							hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
							if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
								this.value = val;
							}
						});
					}
				});
				jQuery.extend({
					valHooks: {
						option: {
							get: function get(elem) {
								var val = jQuery.find.attr(elem, "value");
								return val != null ? val : stripAndCollapse(jQuery.text(elem));
							}
						},
						select: {
							get: function get(elem) {
								var value, option, i, options = elem.options,
									index = elem.selectedIndex,
									one = elem.type === "select-one",
									values = one ? null : [],
									max = one ? index + 1 : options.length;
								if (index < 0) {
									i = max;
								} else {
									i = one ? index : 0;
								}
								for (; i < max; i++) {
									option = options[i];
									if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
										value = jQuery(option).val();
										if (one) {
											return value;
										}
										values.push(value);
									}
								}
								return values;
							},
							set: function set(elem, value) {
								var optionSet, option, options = elem.options,
									values = jQuery.makeArray(value),
									i = options.length;
								while (i--) {
									option = options[i];
									if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
										optionSet = true;
									}
								}
								if (!optionSet) {
									elem.selectedIndex = -1;
								}
								return values;
							}
						}
					}
				});
				jQuery.each(["radio", "checkbox"], function () {
					jQuery.valHooks[this] = {
						set: function set(elem, value) {
							if (Array.isArray(value)) {
								return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
							}
						}
					};
					if (!support.checkOn) {
						jQuery.valHooks[this].get = function (elem) {
							return elem.getAttribute("value") === null ? "on" : elem.value;
						};
					}
				});
				support.focusin = "onfocusin" in window;
				var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
					stopPropagationCallback = function stopPropagationCallback(e) {
						e.stopPropagation();
					};
				jQuery.extend(jQuery.event, {
					trigger: function trigger(event, data, elem, onlyHandlers) {
						var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document],
							type = hasOwn.call(event, "type") ? event.type : event,
							namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
						cur = lastElement = tmp = elem = elem || document;
						if (elem.nodeType === 3 || elem.nodeType === 8) {
							return;
						}
						if (rfocusMorph.test(type + jQuery.event.triggered)) {
							return;
						}
						if (type.indexOf(".") > -1) {
							namespaces = type.split(".");
							type = namespaces.shift();
							namespaces.sort();
						}
						ontype = type.indexOf(":") < 0 && "on" + type;
						event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === "undefined" ? "undefined" : _typeof(event)) === "object" && event);
						event.isTrigger = onlyHandlers ? 2 : 3;
						event.namespace = namespaces.join(".");
						event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
						event.result = undefined;
						if (!event.target) {
							event.target = elem;
						}
						data = data == null ? [event] : jQuery.makeArray(data, [event]);
						special = jQuery.event.special[type] || {};
						if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
							return;
						}
						if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
							bubbleType = special.delegateType || type;
							if (!rfocusMorph.test(bubbleType + type)) {
								cur = cur.parentNode;
							}
							for (; cur; cur = cur.parentNode) {
								eventPath.push(cur);
								tmp = cur;
							}
							if (tmp === (elem.ownerDocument || document)) {
								eventPath.push(tmp.defaultView || tmp.parentWindow || window);
							}
						}
						i = 0;
						while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
							lastElement = cur;
							event.type = i > 1 ? bubbleType : special.bindType || type;
							handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
							if (handle) {
								handle.apply(cur, data);
							}
							handle = ontype && cur[ontype];
							if (handle && handle.apply && acceptData(cur)) {
								event.result = handle.apply(cur, data);
								if (event.result === false) {
									event.preventDefault();
								}
							}
						}
						event.type = type;
						if (!onlyHandlers && !event.isDefaultPrevented()) {
							if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
								if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
									tmp = elem[ontype];
									if (tmp) {
										elem[ontype] = null;
									}
									jQuery.event.triggered = type;
									if (event.isPropagationStopped()) {
										lastElement.addEventListener(type, stopPropagationCallback);
									}
									elem[type]();
									if (event.isPropagationStopped()) {
										lastElement.removeEventListener(type, stopPropagationCallback);
									}
									jQuery.event.triggered = undefined;
									if (tmp) {
										elem[ontype] = tmp;
									}
								}
							}
						}
						return event.result;
					},
					simulate: function simulate(type, elem, event) {
						var e = jQuery.extend(new jQuery.Event(), event, {
							type: type,
							isSimulated: true
						});
						jQuery.event.trigger(e, null, elem);
					}
				});
				jQuery.fn.extend({
					trigger: function trigger(type, data) {
						return this.each(function () {
							jQuery.event.trigger(type, data, this);
						});
					},
					triggerHandler: function triggerHandler(type, data) {
						var elem = this[0];
						if (elem) {
							return jQuery.event.trigger(type, data, elem, true);
						}
					}
				});
				if (!support.focusin) {
					jQuery.each({
						focus: "focusin",
						blur: "focusout"
					}, function (orig, fix) {
						var handler = function handler(event) {
							jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
						};
						jQuery.event.special[fix] = {
							setup: function setup() {
								var doc = this.ownerDocument || this,
									attaches = dataPriv.access(doc, fix);
								if (!attaches) {
									doc.addEventListener(orig, handler, true);
								}
								dataPriv.access(doc, fix, (attaches || 0) + 1);
							},
							teardown: function teardown() {
								var doc = this.ownerDocument || this,
									attaches = dataPriv.access(doc, fix) - 1;
								if (!attaches) {
									doc.removeEventListener(orig, handler, true);
									dataPriv.remove(doc, fix);
								} else {
									dataPriv.access(doc, fix, attaches);
								}
							}
						};
					});
				}
				var location = window.location;
				var nonce = Date.now();
				var rquery = /\?/;
				jQuery.parseXML = function (data) {
					var xml;
					if (!data || typeof data !== "string") {
						return null;
					}
					try {
						xml = new window.DOMParser().parseFromString(data, "text/xml");
					} catch (e) {
						xml = undefined;
					}
					if (!xml || xml.getElementsByTagName("parsererror").length) {
						jQuery.error("Invalid XML: " + data);
					}
					return xml;
				};
				var rbracket = /\[\]$/,
					rCRLF = /\r?\n/g,
					rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
					rsubmittable = /^(?:input|select|textarea|keygen)/i;

				function buildParams(prefix, obj, traditional, add) {
					var name;
					if (Array.isArray(obj)) {
						jQuery.each(obj, function (i, v) {
							if (traditional || rbracket.test(prefix)) {
								add(prefix, v);
							} else {
								buildParams(prefix + "[" + ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object" && v != null ? i : "") + "]", v, traditional, add);
							}
						});
					} else if (!traditional && toType(obj) === "object") {
						for (name in obj) {
							buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
						}
					} else {
						add(prefix, obj);
					}
				}
				jQuery.param = function (a, traditional) {
					var prefix, s = [],
						add = function add(key, valueOrFunction) {
							var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
							s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
						};
					if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
						jQuery.each(a, function () {
							add(this.name, this.value);
						});
					} else {
						for (prefix in a) {
							buildParams(prefix, a[prefix], traditional, add);
						}
					}
					return s.join("&");
				};
				jQuery.fn.extend({
					serialize: function serialize() {
						return jQuery.param(this.serializeArray());
					},
					serializeArray: function serializeArray() {
						return this.map(function () {
							var elements = jQuery.prop(this, "elements");
							return elements ? jQuery.makeArray(elements) : this;
						}).filter(function () {
							var type = this.type;
							return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
						}).map(function (i, elem) {
							var val = jQuery(this).val();
							if (val == null) {
								return null;
							}
							if (Array.isArray(val)) {
								return jQuery.map(val, function (val) {
									return {
										name: elem.name,
										value: val.replace(rCRLF, "\r\n")
									};
								});
							}
							return {
								name: elem.name,
								value: val.replace(rCRLF, "\r\n")
							};
						}).get();
					}
				});
				var r20 = /%20/g,
					rhash = /#.*$/,
					rantiCache = /([?&])_=[^&]*/,
					rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
					rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
					rnoContent = /^(?:GET|HEAD)$/,
					rprotocol = /^\/\//,
					prefilters = {},
					transports = {},
					allTypes = "*/".concat("*"),
					originAnchor = document.createElement("a");
				originAnchor.href = location.href;

				function addToPrefiltersOrTransports(structure) {
					return function (dataTypeExpression, func) {
						if (typeof dataTypeExpression !== "string") {
							func = dataTypeExpression;
							dataTypeExpression = "*";
						}
						var dataType, i = 0,
							dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
						if (isFunction(func)) {
							while (dataType = dataTypes[i++]) {
								if (dataType[0] === "+") {
									dataType = dataType.slice(1) || "*";
									(structure[dataType] = structure[dataType] || []).unshift(func);
								} else {
									(structure[dataType] = structure[dataType] || []).push(func);
								}
							}
						}
					};
				}

				function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
					var inspected = {},
						seekingTransport = structure === transports;

					function inspect(dataType) {
						var selected;
						inspected[dataType] = true;
						jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
							var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
							if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
								options.dataTypes.unshift(dataTypeOrTransport);
								inspect(dataTypeOrTransport);
								return false;
							} else if (seekingTransport) {
								return !(selected = dataTypeOrTransport);
							}
						});
						return selected;
					}
					return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
				}

				function ajaxExtend(target, src) {
					var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
					for (key in src) {
						if (src[key] !== undefined) {
							(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
						}
					}
					if (deep) {
						jQuery.extend(true, target, deep);
					}
					return target;
				}

				function ajaxHandleResponses(s, jqXHR, responses) {
					var ct, type, finalDataType, firstDataType, contents = s.contents,
						dataTypes = s.dataTypes;
					while (dataTypes[0] === "*") {
						dataTypes.shift();
						if (ct === undefined) {
							ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
						}
					}
					if (ct) {
						for (type in contents) {
							if (contents[type] && contents[type].test(ct)) {
								dataTypes.unshift(type);
								break;
							}
						}
					}
					if (dataTypes[0] in responses) {
						finalDataType = dataTypes[0];
					} else {
						for (type in responses) {
							if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
								finalDataType = type;
								break;
							}
							if (!firstDataType) {
								firstDataType = type;
							}
						}
						finalDataType = finalDataType || firstDataType;
					}
					if (finalDataType) {
						if (finalDataType !== dataTypes[0]) {
							dataTypes.unshift(finalDataType);
						}
						return responses[finalDataType];
					}
				}

				function ajaxConvert(s, response, jqXHR, isSuccess) {
					var conv2, current, conv, tmp, prev, converters = {},
						dataTypes = s.dataTypes.slice();
					if (dataTypes[1]) {
						for (conv in s.converters) {
							converters[conv.toLowerCase()] = s.converters[conv];
						}
					}
					current = dataTypes.shift();
					while (current) {
						if (s.responseFields[current]) {
							jqXHR[s.responseFields[current]] = response;
						}
						if (!prev && isSuccess && s.dataFilter) {
							response = s.dataFilter(response, s.dataType);
						}
						prev = current;
						current = dataTypes.shift();
						if (current) {
							if (current === "*") {
								current = prev;
							} else if (prev !== "*" && prev !== current) {
								conv = converters[prev + " " + current] || converters["* " + current];
								if (!conv) {
									for (conv2 in converters) {
										tmp = conv2.split(" ");
										if (tmp[1] === current) {
											conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
											if (conv) {
												if (conv === true) {
													conv = converters[conv2];
												} else if (converters[conv2] !== true) {
													current = tmp[0];
													dataTypes.unshift(tmp[1]);
												}
												break;
											}
										}
									}
								}
								if (conv !== true) {
									if (conv && s.throws) {
										response = conv(response);
									} else {
										try {
											response = conv(response);
										} catch (e) {
											return {
												state: "parsererror",
												error: conv ? e : "No conversion from " + prev + " to " + current
											};
										}
									}
								}
							}
						}
					}
					return {
						state: "success",
						data: response
					};
				}
				jQuery.extend({
					active: 0,
					lastModified: {},
					etag: {},
					ajaxSettings: {
						url: location.href,
						type: "GET",
						isLocal: rlocalProtocol.test(location.protocol),
						global: true,
						processData: true,
						async: true,
						contentType: "application/x-www-form-urlencoded; charset=UTF-8",
						accepts: {
							"*": allTypes,
							text: "text/plain",
							html: "text/html",
							xml: "application/xml, text/xml",
							json: "application/json, text/javascript"
						},
						contents: {
							xml: /\bxml\b/,
							html: /\bhtml/,
							json: /\bjson\b/
						},
						responseFields: {
							xml: "responseXML",
							text: "responseText",
							json: "responseJSON"
						},
						converters: {
							"* text": String,
							"text html": true,
							"text json": JSON.parse,
							"text xml": jQuery.parseXML
						},
						flatOptions: {
							url: true,
							context: true
						}
					},
					ajaxSetup: function ajaxSetup(target, settings) {
						return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
					},
					ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
					ajaxTransport: addToPrefiltersOrTransports(transports),
					ajax: function ajax(url, options) {
						if ((typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
							options = url;
							url = undefined;
						}
						options = options || {};
						var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options),
							callbackContext = s.context || s,
							globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
							deferred = jQuery.Deferred(),
							completeDeferred = jQuery.Callbacks("once memory"),
							_statusCode = s.statusCode || {},
							requestHeaders = {},
							requestHeadersNames = {},
							strAbort = "canceled",
							jqXHR = {
								readyState: 0,
								getResponseHeader: function getResponseHeader(key) {
									var match;
									if (completed) {
										if (!responseHeaders) {
											responseHeaders = {};
											while (match = rheaders.exec(responseHeadersString)) {
												responseHeaders[match[1].toLowerCase()] = match[2];
											}
										}
										match = responseHeaders[key.toLowerCase()];
									}
									return match == null ? null : match;
								},
								getAllResponseHeaders: function getAllResponseHeaders() {
									return completed ? responseHeadersString : null;
								},
								setRequestHeader: function setRequestHeader(name, value) {
									if (completed == null) {
										name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
										requestHeaders[name] = value;
									}
									return this;
								},
								overrideMimeType: function overrideMimeType(type) {
									if (completed == null) {
										s.mimeType = type;
									}
									return this;
								},
								statusCode: function statusCode(map) {
									var code;
									if (map) {
										if (completed) {
											jqXHR.always(map[jqXHR.status]);
										} else {
											for (code in map) {
												_statusCode[code] = [_statusCode[code], map[code]];
											}
										}
									}
									return this;
								},
								abort: function abort(statusText) {
									var finalText = statusText || strAbort;
									if (transport) {
										transport.abort(finalText);
									}
									done(0, finalText);
									return this;
								}
							};
						deferred.promise(jqXHR);
						s.url;
						s.type = options.method || options.type || s.method || s.type;
						s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
						if (s.crossDomain == null) {
							urlAnchor = document.createElement("a");
							try {
								urlAnchor.href = s.url;
								urlAnchor.href = urlAnchor.href;
								s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
							} catch (e) {
								s.crossDomain = true;
							}
						}
						if (s.data && s.processData && typeof s.data !== "string") {
							s.data = jQuery.param(s.data, s.traditional);
						}
						inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
						if (completed) {
							return jqXHR;
						}
						fireGlobals = jQuery.event && s.global;
						if (fireGlobals && jQuery.active++ === 0) {
							jQuery.event.trigger("ajaxStart");
						}
						s.type = s.type.toUpperCase();
						s.hasContent = !rnoContent.test(s.type);
						cacheURL = s.url.replace(rhash, "");
						if (!s.hasContent) {
							uncached = s.url.slice(cacheURL.length);
							if (s.data && (s.processData || typeof s.data === "string")) {
								cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
								delete s.data;
							}
							if (s.cache === false) {
								cacheURL = cacheURL.replace(rantiCache, "$1");
								uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
							}
							s.url = cacheURL + uncached;
						} else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
							s.data = s.data.replace(r20, "+");
						}
						if (s.ifModified) {
							if (jQuery.lastModified[cacheURL]) {
								jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
							}
							if (jQuery.etag[cacheURL]) {
								jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
							}
						}
						if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
							jqXHR.setRequestHeader("Content-Type", s.contentType);
						}
						jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
						for (i in s.headers) {
							jqXHR.setRequestHeader(i, s.headers[i]);
						}
						if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
							return jqXHR.abort();
						}
						strAbort = "abort";
						completeDeferred.add(s.complete);
						jqXHR.done(s.success);
						jqXHR.fail(s.error);
						transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
						if (!transport) {
							done(-1, "No Transport");
						} else {
							jqXHR.readyState = 1;
							if (fireGlobals) {
								globalEventContext.trigger("ajaxSend", [jqXHR, s]);
							}
							if (completed) {
								return jqXHR;
							}
							if (s.async && s.timeout > 0) {
								timeoutTimer = window.setTimeout(function () {
									jqXHR.abort("timeout");
								}, s.timeout);
							}
							try {
								completed = false;
								transport.send(requestHeaders, done);
							} catch (e) {
								if (completed) {
									throw e;
								}
								done(-1, e);
							}
						}

						function done(status, nativeStatusText, responses, headers) {
							var isSuccess, success, error, response, modified, statusText = nativeStatusText;
							if (completed) {
								return;
							}
							completed = true;
							if (timeoutTimer) {
								window.clearTimeout(timeoutTimer);
							}
							transport = undefined;
							responseHeadersString = headers || "";
							jqXHR.readyState = status > 0 ? 4 : 0;
							isSuccess = status >= 200 && status < 300 || status === 304;
							if (responses) {
								response = ajaxHandleResponses(s, jqXHR, responses);
							}
							response = ajaxConvert(s, response, jqXHR, isSuccess);
							if (isSuccess) {
								if (s.ifModified) {
									modified = jqXHR.getResponseHeader("Last-Modified");
									if (modified) {
										jQuery.lastModified[cacheURL] = modified;
									}
									modified = jqXHR.getResponseHeader("etag");
									if (modified) {
										jQuery.etag[cacheURL] = modified;
									}
								}
								if (status === 204 || s.type === "HEAD") {
									statusText = "nocontent";
								} else if (status === 304) {
									statusText = "notmodified";
								} else {
									statusText = response.state;
									success = response.data;
									error = response.error;
									isSuccess = !error;
								}
							} else {
								error = statusText;
								if (status || !statusText) {
									statusText = "error";
									if (status < 0) {
										status = 0;
									}
								}
							}
							jqXHR.status = status;
							jqXHR.statusText = (nativeStatusText || statusText) + "";
							if (isSuccess) {
								deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
							} else {
								deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
							}
							jqXHR.statusCode(_statusCode);
							_statusCode = undefined;
							if (fireGlobals) {
								globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
							}
							completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
							if (fireGlobals) {
								globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
								if (!--jQuery.active) {
									jQuery.event.trigger("ajaxStop");
								}
							}
						}
						return jqXHR;
					},
					getJSON: function getJSON(url, data, callback) {
						return jQuery.get(url, data, callback, "json");
					},
					getScript: function getScript(url, callback) {
						return jQuery.get(url, undefined, callback, "script");
					}
				});
				jQuery.each(["get", "post"], function (i, method) {
					jQuery[method] = function (url, data, callback, type) {
						if (isFunction(data)) {
							type = type || callback;
							callback = data;
							data = undefined;
						}
						return jQuery.ajax(jQuery.extend({
							url: url,
							type: method,
							dataType: type,
							data: data,
							success: callback
						}, jQuery.isPlainObject(url) && url));
					};
				});
				jQuery._evalUrl = function (url) {
					return jQuery.ajax({
						url: url,
						type: "GET",
						dataType: "script",
						cache: true,
						async: false,
						global: false,
						"throws": true
					});
				};
				jQuery.fn.extend({
					wrapAll: function wrapAll(html) {
						var wrap;
						if (this[0]) {
							if (isFunction(html)) {
								html = html.call(this[0]);
							}
							wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
							if (this[0].parentNode) {
								wrap.insertBefore(this[0]);
							}
							wrap.map(function () {
								var elem = this;
								while (elem.firstElementChild) {
									elem = elem.firstElementChild;
								}
								return elem;
							}).append(this);
						}
						return this;
					},
					wrapInner: function wrapInner(html) {
						if (isFunction(html)) {
							return this.each(function (i) {
								jQuery(this).wrapInner(html.call(this, i));
							});
						}
						return this.each(function () {
							var self = jQuery(this),
								contents = self.contents();
							if (contents.length) {
								contents.wrapAll(html);
							} else {
								self.append(html);
							}
						});
					},
					wrap: function wrap(html) {
						var htmlIsFunction = isFunction(html);
						return this.each(function (i) {
							jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
						});
					},
					unwrap: function unwrap(selector) {
						this.parent(selector).not("body").each(function () {
							jQuery(this).replaceWith(this.childNodes);
						});
						return this;
					}
				});
				jQuery.expr.pseudos.hidden = function (elem) {
					return !jQuery.expr.pseudos.visible(elem);
				};
				jQuery.expr.pseudos.visible = function (elem) {
					return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
				};
				jQuery.ajaxSettings.xhr = function () {
					try {
						return new window.XMLHttpRequest();
					} catch (e) { }
				};
				var xhrSuccessStatus = {
					0: 200,
					1223: 204
				},
					xhrSupported = jQuery.ajaxSettings.xhr();
				support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
				support.ajax = xhrSupported = !!xhrSupported;
				jQuery.ajaxTransport(function (options) {
					var _callback, errorCallback;
					if (support.cors || xhrSupported && !options.crossDomain) {
						return {
							send: function send(headers, complete) {
								var i, xhr = options.xhr();
								xhr.open(options.type, options.url, options.async, options.username, options.password);
								if (options.xhrFields) {
									for (i in options.xhrFields) {
										xhr[i] = options.xhrFields[i];
									}
								}
								if (options.mimeType && xhr.overrideMimeType) {
									xhr.overrideMimeType(options.mimeType);
								}
								if (!options.crossDomain && !headers["X-Requested-With"]) {
									headers["X-Requested-With"] = "XMLHttpRequest";
								}
								for (i in headers) {
									xhr.setRequestHeader(i, headers[i]);
								}
								_callback = function callback(type) {
									return function () {
										if (_callback) {
											_callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
											if (type === "abort") {
												xhr.abort();
											} else if (type === "error") {
												if (typeof xhr.status !== "number") {
													complete(0, "error");
												} else {
													complete(xhr.status, xhr.statusText);
												}
											} else {
												complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
													binary: xhr.response
												} : {
													text: xhr.responseText
												}, xhr.getAllResponseHeaders());
											}
										}
									};
								};
								xhr.onload = _callback();
								errorCallback = xhr.onerror = xhr.ontimeout = _callback("error");
								if (xhr.onabort !== undefined) {
									xhr.onabort = errorCallback;
								} else {
									xhr.onreadystatechange = function () {
										if (xhr.readyState === 4) {
											window.setTimeout(function () {
												if (_callback) {
													errorCallback();
												}
											});
										}
									};
								}
								_callback = _callback("abort");
								try {
									xhr.send(options.hasContent && options.data || null);
								} catch (e) {
									if (_callback) {
										throw e;
									}
								}
							},
							abort: function abort() {
								if (_callback) {
									_callback();
								}
							}
						};
					}
				});
				jQuery.ajaxPrefilter(function (s) {
					if (s.crossDomain) {
						s.contents.script = false;
					}
				});
				jQuery.ajaxSetup({
					accepts: {
						script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
					},
					contents: {
						script: /\b(?:java|ecma)script\b/
					},
					converters: {
						"text script": function textScript(text) {
							jQuery.globalEval(text);
							return text;
						}
					}
				});
				jQuery.ajaxPrefilter("script", function (s) {
					if (s.cache === undefined) {
						s.cache = false;
					}
					if (s.crossDomain) {
						s.type = "GET";
					}
				});
				jQuery.ajaxTransport("script", function (s) {
					if (s.crossDomain) {
						var script, _callback2;
						return {
							send: function send(_, complete) {
								script = jQuery("<script>").prop({
									charset: s.scriptCharset,
									src: s.url
								}).on("load error", _callback2 = function callback(evt) {
									script.remove();
									_callback2 = null;
									if (evt) {
										complete(evt.type === "error" ? 404 : 200, evt.type);
									}
								});
								document.head.appendChild(script[0]);
							},
							abort: function abort() {
								if (_callback2) {
									_callback2();
								}
							}
						};
					}
				});
				var oldCallbacks = [],
					rjsonp = /(=)\?(?=&|$)|\?\?/;
				jQuery.ajaxSetup({
					jsonp: "callback",
					jsonpCallback: function jsonpCallback() {
						var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
						this[callback] = true;
						return callback;
					}
				});
				jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
					var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
					if (jsonProp || s.dataTypes[0] === "jsonp") {
						callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
						if (jsonProp) {
							s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
						} else if (s.jsonp !== false) {
							s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
						}
						s.converters["script json"] = function () {
							if (!responseContainer) {
								jQuery.error(callbackName + " was not called");
							}
							return responseContainer[0];
						};
						s.dataTypes[0] = "json";
						overwritten = window[callbackName];
						window[callbackName] = function () {
							responseContainer = arguments;
						};
						jqXHR.always(function () {
							if (overwritten === undefined) {
								jQuery(window).removeProp(callbackName);
							} else {
								window[callbackName] = overwritten;
							}
							if (s[callbackName]) {
								s.jsonpCallback = originalSettings.jsonpCallback;
								oldCallbacks.push(callbackName);
							}
							if (responseContainer && isFunction(overwritten)) {
								overwritten(responseContainer[0]);
							}
							responseContainer = overwritten = undefined;
						});
						return "script";
					}
				});
				support.createHTMLDocument = function () {
					var body = document.implementation.createHTMLDocument("").body;
					body.innerHTML = "<form></form><form></form>";
					return body.childNodes.length === 2;
				}();
				jQuery.parseHTML = function (data, context, keepScripts) {
					if (typeof data !== "string") {
						return [];
					}
					if (typeof context === "boolean") {
						keepScripts = context;
						context = false;
					}
					var base, parsed, scripts;
					if (!context) {
						if (support.createHTMLDocument) {
							context = document.implementation.createHTMLDocument("");
							base = context.createElement("base");
							base.href = document.location.href;
							context.head.appendChild(base);
						} else {
							context = document;
						}
					}
					parsed = rsingleTag.exec(data);
					scripts = !keepScripts && [];
					if (parsed) {
						return [context.createElement(parsed[1])];
					}
					parsed = buildFragment([data], context, scripts);
					if (scripts && scripts.length) {
						jQuery(scripts).remove();
					}
					return jQuery.merge([], parsed.childNodes);
				};
				jQuery.fn.load = function (url, params, callback) {
					var selector, type, response, self = this,
						off = url.indexOf(" ");
					if (off > -1) {
						selector = stripAndCollapse(url.slice(off));
						url = url.slice(0, off);
					}
					if (isFunction(params)) {
						callback = params;
						params = undefined;
					} else if (params && (typeof params === "undefined" ? "undefined" : _typeof(params)) === "object") {
						type = "POST";
					}
					if (self.length > 0) {
						jQuery.ajax({
							url: url,
							type: type || "GET",
							dataType: "html",
							data: params
						}).done(function (responseText) {
							response = arguments;
							self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
						}).always(callback && function (jqXHR, status) {
							self.each(function () {
								callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
							});
						});
					}
					return this;
				};
				jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
					jQuery.fn[type] = function (fn) {
						return this.on(type, fn);
					};
				});
				jQuery.expr.pseudos.animated = function (elem) {
					return jQuery.grep(jQuery.timers, function (fn) {
						return elem === fn.elem;
					}).length;
				};
				jQuery.offset = {
					setOffset: function setOffset(elem, options, i) {
						var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"),
							curElem = jQuery(elem),
							props = {};
						if (position === "static") {
							elem.style.position = "relative";
						}
						curOffset = curElem.offset();
						curCSSTop = jQuery.css(elem, "top");
						curCSSLeft = jQuery.css(elem, "left");
						calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
						if (calculatePosition) {
							curPosition = curElem.position();
							curTop = curPosition.top;
							curLeft = curPosition.left;
						} else {
							curTop = parseFloat(curCSSTop) || 0;
							curLeft = parseFloat(curCSSLeft) || 0;
						}
						if (isFunction(options)) {
							options = options.call(elem, i, jQuery.extend({}, curOffset));
						}
						if (options.top != null) {
							props.top = options.top - curOffset.top + curTop;
						}
						if (options.left != null) {
							props.left = options.left - curOffset.left + curLeft;
						}
						if ("using" in options) {
							options.using.call(elem, props);
						} else {
							curElem.css(props);
						}
					}
				};
				jQuery.fn.extend({
					offset: function offset(options) {
						if (arguments.length) {
							return options === undefined ? this : this.each(function (i) {
								jQuery.offset.setOffset(this, options, i);
							});
						}
						var rect, win, elem = this[0];
						if (!elem) {
							return;
						}
						if (!elem.getClientRects().length) {
							return {
								top: 0,
								left: 0
							};
						}
						rect = elem.getBoundingClientRect();
						win = elem.ownerDocument.defaultView;
						return {
							top: rect.top + win.pageYOffset,
							left: rect.left + win.pageXOffset
						};
					},
					position: function position() {
						if (!this[0]) {
							return;
						}
						var offsetParent, offset, doc, elem = this[0],
							parentOffset = {
								top: 0,
								left: 0
							};
						if (jQuery.css(elem, "position") === "fixed") {
							offset = elem.getBoundingClientRect();
						} else {
							offset = this.offset();
							doc = elem.ownerDocument;
							offsetParent = elem.offsetParent || doc.documentElement;
							while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
								offsetParent = offsetParent.parentNode;
							}
							if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
								parentOffset = jQuery(offsetParent).offset();
								parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
								parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
							}
						}
						return {
							top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
							left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
						};
					},
					offsetParent: function offsetParent() {
						return this.map(function () {
							var offsetParent = this.offsetParent;
							while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
								offsetParent = offsetParent.offsetParent;
							}
							return offsetParent || documentElement;
						});
					}
				});
				jQuery.each({
					scrollLeft: "pageXOffset",
					scrollTop: "pageYOffset"
				}, function (method, prop) {
					var top = "pageYOffset" === prop;
					jQuery.fn[method] = function (val) {
						return access(this, function (elem, method, val) {
							var win;
							if (isWindow(elem)) {
								win = elem;
							} else if (elem.nodeType === 9) {
								win = elem.defaultView;
							}
							if (val === undefined) {
								return win ? win[prop] : elem[method];
							}
							if (win) {
								win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
							} else {
								elem[method] = val;
							}
						}, method, val, arguments.length);
					};
				});
				jQuery.each(["top", "left"], function (i, prop) {
					jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
						if (computed) {
							computed = curCSS(elem, prop);
							return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
						}
					});
				});
				jQuery.each({
					Height: "height",
					Width: "width"
				}, function (name, type) {
					jQuery.each({
						padding: "inner" + name,
						content: type,
						"": "outer" + name
					}, function (defaultExtra, funcName) {
						jQuery.fn[funcName] = function (margin, value) {
							var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
								extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
							return access(this, function (elem, type, value) {
								var doc;
								if (isWindow(elem)) {
									return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
								}
								if (elem.nodeType === 9) {
									doc = elem.documentElement;
									return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
								}
								return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
							}, type, chainable ? margin : undefined, chainable);
						};
					});
				});
				jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
					jQuery.fn[name] = function (data, fn) {
						return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
					};
				});
				jQuery.fn.extend({
					hover: function hover(fnOver, fnOut) {
						return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
					}
				});
				jQuery.fn.extend({
					bind: function bind(types, data, fn) {
						return this.on(types, null, data, fn);
					},
					unbind: function unbind(types, fn) {
						return this.off(types, null, fn);
					},
					delegate: function delegate(selector, types, data, fn) {
						return this.on(types, selector, data, fn);
					},
					undelegate: function undelegate(selector, types, fn) {
						return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
					}
				});
				jQuery.proxy = function (fn, context) {
					var tmp, args, proxy;
					if (typeof context === "string") {
						tmp = fn[context];
						context = fn;
						fn = tmp;
					}
					if (!isFunction(fn)) {
						return undefined;
					}
					args = _slice.call(arguments, 2);
					proxy = function proxy() {
						return fn.apply(context || this, args.concat(_slice.call(arguments)));
					};
					proxy.guid = fn.guid = fn.guid || jQuery.guid++;
					return proxy;
				};
				jQuery.holdReady = function (hold) {
					if (hold) {
						jQuery.readyWait++;
					} else {
						jQuery.ready(true);
					}
				};
				jQuery.isArray = Array.isArray;
				jQuery.parseJSON = JSON.parse;
				jQuery.nodeName = nodeName;
				jQuery.isFunction = isFunction;
				jQuery.isWindow = isWindow;
				jQuery.camelCase = camelCase;
				jQuery.type = toType;
				jQuery.now = Date.now;
				jQuery.isNumeric = function (obj) {
					var type = jQuery.type(obj);
					return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
				};
				if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
						return jQuery;
					}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				}
				var
					_jQuery = window.jQuery,
					_$ = window.$;
				jQuery.noConflict = function (deep) {
					if (window.$ === jQuery) {
						window.$ = _$;
					}
					if (deep && window.jQuery === jQuery) {
						window.jQuery = _jQuery;
					}
					return jQuery;
				};
				if (!noGlobal) {
					window.jQuery = window.$ = jQuery;
				}
				return jQuery;
			});
		}.call(exports, __webpack_require__(11)(module)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		var g;
		g = function () {
			return this;
		}();
		try {
			g = g || Function("return this")() || (1, eval)("this");
		} catch (e) {
			if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
		}
		module.exports = g;
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		/*!
		 * ScrollMagic v2.0.5 (2015-04-29)
		 * The javascript library for magical scroll interactions.
		 * (c) 2015 Jan Paepke (@janpaepke)
		 * Project Website: http://scrollmagic.io
		 * 
		 * @version 2.0.5
		 * @license Dual licensed under MIT license and GPL.
		 * @author Jan Paepke - e-mail@janpaepke.de
		 *
		 * @file ScrollMagic main library.
		 */
		(function (root, factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				module.exports = factory();
			} else {
				root.ScrollMagic = factory();
			}
		})(undefined, function () {
			"use strict";
			var ScrollMagic = function ScrollMagic() {
				_util.log(2, '(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use \'new ScrollMagic.Controller()\' to create a new controller instance. Use \'new ScrollMagic.Scene()\' to instance a scene.');
			};
			ScrollMagic.version = "2.0.5";
			window.addEventListener("mousewheel", function () { });
			var PIN_SPACER_ATTRIBUTE = "data-scrollmagic-pin-spacer";
			ScrollMagic.Controller = function (options) {
				var NAMESPACE = 'ScrollMagic.Controller',
					SCROLL_DIRECTION_FORWARD = 'FORWARD',
					SCROLL_DIRECTION_REVERSE = 'REVERSE',
					SCROLL_DIRECTION_PAUSED = 'PAUSED',
					DEFAULT_OPTIONS = CONTROLLER_OPTIONS.defaults;
				var Controller = this,
					_options = _util.extend({}, DEFAULT_OPTIONS, options),
					_sceneObjects = [],
					_updateScenesOnNextCycle = false,
					_scrollPos = 0,
					_scrollDirection = SCROLL_DIRECTION_PAUSED,
					_isDocument = true,
					_viewPortSize = 0,
					_enabled = true,
					_updateTimeout, _refreshTimeout;
				var construct = function construct() {
					for (var key in _options) {
						if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
							log(2, "WARNING: Unknown option \"" + key + "\"");
							delete _options[key];
						}
					}
					_options.container = _util.get.elements(_options.container)[0];
					if (!_options.container) {
						log(1, "ERROR creating object " + NAMESPACE + ": No valid scroll container supplied");
						throw NAMESPACE + " init failed.";
					}
					_isDocument = _options.container === window || _options.container === document.body || !document.body.contains(_options.container);
					if (_isDocument) {
						_options.container = window;
					}
					_viewPortSize = getViewportSize();
					_options.container.addEventListener("resize", onChange);
					_options.container.addEventListener("scroll", onChange);
					_options.refreshInterval = parseInt(_options.refreshInterval) || DEFAULT_OPTIONS.refreshInterval;
					scheduleRefresh();
					log(3, "added new " + NAMESPACE + " controller (v" + ScrollMagic.version + ")");
				};
				var scheduleRefresh = function scheduleRefresh() {
					if (_options.refreshInterval > 0) {
						_refreshTimeout = window.setTimeout(refresh, _options.refreshInterval);
					}
				};
				var getScrollPos = function getScrollPos() {
					return _options.vertical ? _util.get.scrollTop(_options.container) : _util.get.scrollLeft(_options.container);
				};
				var getViewportSize = function getViewportSize() {
					return _options.vertical ? _util.get.height(_options.container) : _util.get.width(_options.container);
				};
				var setScrollPos = this._setScrollPos = function (pos) {
					if (_options.vertical) {
						if (_isDocument) {
							window.scrollTo(_util.get.scrollLeft(), pos);
						} else {
							_options.container.scrollTop = pos;
						}
					} else {
						if (_isDocument) {
							window.scrollTo(pos, _util.get.scrollTop());
						} else {
							_options.container.scrollLeft = pos;
						}
					}
				};
				var updateScenes = function updateScenes() {
					if (_enabled && _updateScenesOnNextCycle) {
						var scenesToUpdate = _util.type.Array(_updateScenesOnNextCycle) ? _updateScenesOnNextCycle : _sceneObjects.slice(0);
						_updateScenesOnNextCycle = false;
						var oldScrollPos = _scrollPos;
						_scrollPos = Controller.scrollPos();
						var deltaScroll = _scrollPos - oldScrollPos;
						if (deltaScroll !== 0) {
							_scrollDirection = deltaScroll > 0 ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_REVERSE;
						}
						if (_scrollDirection === SCROLL_DIRECTION_REVERSE) {
							scenesToUpdate.reverse();
						}
						scenesToUpdate.forEach(function (scene, index) {
							log(3, "updating Scene " + (index + 1) + "/" + scenesToUpdate.length + " (" + _sceneObjects.length + " total)");
							scene.update(true);
						});
						if (scenesToUpdate.length === 0 && _options.loglevel >= 3) {
							log(3, "updating 0 Scenes (nothing added to controller)");
						}
					}
				};
				var debounceUpdate = function debounceUpdate() {
					_updateTimeout = _util.rAF(updateScenes);
				};
				var onChange = function onChange(e) {
					log(3, "event fired causing an update:", e.type);
					if (e.type == "resize") {
						_viewPortSize = getViewportSize();
						_scrollDirection = SCROLL_DIRECTION_PAUSED;
					}
					if (_updateScenesOnNextCycle !== true) {
						_updateScenesOnNextCycle = true;
						debounceUpdate();
					}
				};
				var refresh = function refresh() {
					if (!_isDocument) {
						if (_viewPortSize != getViewportSize()) {
							var resizeEvent;
							try {
								resizeEvent = new Event('resize', {
									bubbles: false,
									cancelable: false
								});
							} catch (e) {
								resizeEvent = document.createEvent("Event");
								resizeEvent.initEvent("resize", false, false);
							}
							_options.container.dispatchEvent(resizeEvent);
						}
					}
					_sceneObjects.forEach(function (scene, index) {
						scene.refresh();
					});
					scheduleRefresh();
				};
				var log = this._log = function (loglevel, output) {
					if (_options.loglevel >= loglevel) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
						_util.log.apply(window, arguments);
					}
				};
				this._options = _options;
				var sortScenes = function sortScenes(ScenesArray) {
					if (ScenesArray.length <= 1) {
						return ScenesArray;
					} else {
						var scenes = ScenesArray.slice(0);
						scenes.sort(function (a, b) {
							return a.scrollOffset() > b.scrollOffset() ? 1 : -1;
						});
						return scenes;
					}
				};
				this.addScene = function (newScene) {
					if (_util.type.Array(newScene)) {
						newScene.forEach(function (scene, index) {
							Controller.addScene(scene);
						});
					} else if (newScene instanceof ScrollMagic.Scene) {
						if (newScene.controller() !== Controller) {
							newScene.addTo(Controller);
						} else if (_sceneObjects.indexOf(newScene) < 0) {
							_sceneObjects.push(newScene);
							_sceneObjects = sortScenes(_sceneObjects);
							newScene.on("shift.controller_sort", function () {
								_sceneObjects = sortScenes(_sceneObjects);
							});
							for (var key in _options.globalSceneOptions) {
								if (newScene[key]) {
									newScene[key].call(newScene, _options.globalSceneOptions[key]);
								}
							}
							log(3, "adding Scene (now " + _sceneObjects.length + " total)");
						}
					} else {
						log(1, "ERROR: invalid argument supplied for '.addScene()'");
					}
					return Controller;
				};
				this.removeScene = function (Scene) {
					if (_util.type.Array(Scene)) {
						Scene.forEach(function (scene, index) {
							Controller.removeScene(scene);
						});
					} else {
						var index = _sceneObjects.indexOf(Scene);
						if (index > -1) {
							Scene.off("shift.controller_sort");
							_sceneObjects.splice(index, 1);
							log(3, "removing Scene (now " + _sceneObjects.length + " left)");
							Scene.remove();
						}
					}
					return Controller;
				};
				this.updateScene = function (Scene, immediately) {
					if (_util.type.Array(Scene)) {
						Scene.forEach(function (scene, index) {
							Controller.updateScene(scene, immediately);
						});
					} else {
						if (immediately) {
							Scene.update(true);
						} else if (_updateScenesOnNextCycle !== true && Scene instanceof ScrollMagic.Scene) {
							_updateScenesOnNextCycle = _updateScenesOnNextCycle || [];
							if (_updateScenesOnNextCycle.indexOf(Scene) == -1) {
								_updateScenesOnNextCycle.push(Scene);
							}
							_updateScenesOnNextCycle = sortScenes(_updateScenesOnNextCycle);
							debounceUpdate();
						}
					}
					return Controller;
				};
				this.update = function (immediately) {
					onChange({
						type: "resize"
					});
					if (immediately) {
						updateScenes();
					}
					return Controller;
				};
				this.scrollTo = function (scrollTarget, additionalParameter) {
					if (_util.type.Number(scrollTarget)) {
						setScrollPos.call(_options.container, scrollTarget, additionalParameter);
					} else if (scrollTarget instanceof ScrollMagic.Scene) {
						if (scrollTarget.controller() === Controller) {
							Controller.scrollTo(scrollTarget.scrollOffset(), additionalParameter);
						} else {
							log(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", scrollTarget);
						}
					} else if (_util.type.Function(scrollTarget)) {
						setScrollPos = scrollTarget;
					} else {
						var elem = _util.get.elements(scrollTarget)[0];
						if (elem) {
							while (elem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
								elem = elem.parentNode;
							}
							var param = _options.vertical ? "top" : "left",
								containerOffset = _util.get.offset(_options.container),
								elementOffset = _util.get.offset(elem);
							if (!_isDocument) {
								containerOffset[param] -= Controller.scrollPos();
							}
							Controller.scrollTo(elementOffset[param] - containerOffset[param], additionalParameter);
						} else {
							log(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", scrollTarget);
						}
					}
					return Controller;
				};
				this.scrollPos = function (scrollPosMethod) {
					if (!arguments.length) {
						return getScrollPos.call(Controller);
					} else {
						if (_util.type.Function(scrollPosMethod)) {
							getScrollPos = scrollPosMethod;
						} else {
							log(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'.");
						}
					}
					return Controller;
				};
				this.info = function (about) {
					var values = {
						size: _viewPortSize,
						vertical: _options.vertical,
						scrollPos: _scrollPos,
						scrollDirection: _scrollDirection,
						container: _options.container,
						isDocument: _isDocument
					};
					if (!arguments.length) {
						return values;
					} else if (values[about] !== undefined) {
						return values[about];
					} else {
						log(1, "ERROR: option \"" + about + "\" is not available");
						return;
					}
				};
				this.loglevel = function (newLoglevel) {
					if (!arguments.length) {
						return _options.loglevel;
					} else if (_options.loglevel != newLoglevel) {
						_options.loglevel = newLoglevel;
					}
					return Controller;
				};
				this.enabled = function (newState) {
					if (!arguments.length) {
						return _enabled;
					} else if (_enabled != newState) {
						_enabled = !!newState;
						Controller.updateScene(_sceneObjects, true);
					}
					return Controller;
				};
				this.destroy = function (resetScenes) {
					window.clearTimeout(_refreshTimeout);
					var i = _sceneObjects.length;
					while (i--) {
						_sceneObjects[i].destroy(resetScenes);
					}
					_options.container.removeEventListener("resize", onChange);
					_options.container.removeEventListener("scroll", onChange);
					_util.cAF(_updateTimeout);
					log(3, "destroyed " + NAMESPACE + " (reset: " + (resetScenes ? "true" : "false") + ")");
					return null;
				};
				construct();
				return Controller;
			};
			var CONTROLLER_OPTIONS = {
				defaults: {
					container: window,
					vertical: true,
					globalSceneOptions: {},
					loglevel: 2,
					refreshInterval: 100
				}
			};
			ScrollMagic.Controller.addOption = function (name, defaultValue) {
				CONTROLLER_OPTIONS.defaults[name] = defaultValue;
			};
			ScrollMagic.Controller.extend = function (extension) {
				var oldClass = this;
				ScrollMagic.Controller = function () {
					oldClass.apply(this, arguments);
					this.$super = _util.extend({}, this);
					return extension.apply(this, arguments) || this;
				};
				_util.extend(ScrollMagic.Controller, oldClass);
				ScrollMagic.Controller.prototype = oldClass.prototype;
				ScrollMagic.Controller.prototype.constructor = ScrollMagic.Controller;
			};
			ScrollMagic.Scene = function (options) {
				var NAMESPACE = 'ScrollMagic.Scene',
					SCENE_STATE_BEFORE = 'BEFORE',
					SCENE_STATE_DURING = 'DURING',
					SCENE_STATE_AFTER = 'AFTER',
					DEFAULT_OPTIONS = SCENE_OPTIONS.defaults;
				var Scene = this,
					_options = _util.extend({}, DEFAULT_OPTIONS, options),
					_state = SCENE_STATE_BEFORE,
					_progress = 0,
					_scrollOffset = {
						start: 0,
						end: 0
					},
					_triggerPos = 0,
					_enabled = true,
					_durationUpdateMethod, _controller;
				var construct = function construct() {
					for (var key in _options) {
						if (!DEFAULT_OPTIONS.hasOwnProperty(key)) {
							log(2, "WARNING: Unknown option \"" + key + "\"");
							delete _options[key];
						}
					}
					for (var optionName in DEFAULT_OPTIONS) {
						addSceneOption(optionName);
					}
					validateOption();
				};
				var _listeners = {};
				this.on = function (names, callback) {
					if (_util.type.Function(callback)) {
						names = names.trim().split(' ');
						names.forEach(function (fullname) {
							var nameparts = fullname.split('.'),
								eventname = nameparts[0],
								namespace = nameparts[1];
							if (eventname != "*") {
								if (!_listeners[eventname]) {
									_listeners[eventname] = [];
								}
								_listeners[eventname].push({
									namespace: namespace || '',
									callback: callback
								});
							}
						});
					} else {
						log(1, "ERROR when calling '.on()': Supplied callback for '" + names + "' is not a valid function!");
					}
					return Scene;
				};
				this.off = function (names, callback) {
					if (!names) {
						log(1, "ERROR: Invalid event name supplied.");
						return Scene;
					}
					names = names.trim().split(' ');
					names.forEach(function (fullname, key) {
						var nameparts = fullname.split('.'),
							eventname = nameparts[0],
							namespace = nameparts[1] || '',
							removeList = eventname === '*' ? Object.keys(_listeners) : [eventname];
						removeList.forEach(function (remove) {
							var list = _listeners[remove] || [],
								i = list.length;
							while (i--) {
								var listener = list[i];
								if (listener && (namespace === listener.namespace || namespace === '*') && (!callback || callback == listener.callback)) {
									list.splice(i, 1);
								}
							}
							if (!list.length) {
								delete _listeners[remove];
							}
						});
					});
					return Scene;
				};
				this.trigger = function (name, vars) {
					if (name) {
						var nameparts = name.trim().split('.'),
							eventname = nameparts[0],
							namespace = nameparts[1],
							listeners = _listeners[eventname];
						log(3, 'event fired:', eventname, vars ? "->" : '', vars || '');
						if (listeners) {
							listeners.forEach(function (listener, key) {
								if (!namespace || namespace === listener.namespace) {
									listener.callback.call(Scene, new ScrollMagic.Event(eventname, listener.namespace, Scene, vars));
								}
							});
						}
					} else {
						log(1, "ERROR: Invalid event name supplied.");
					}
					return Scene;
				};
				Scene.on("change.internal", function (e) {
					if (e.what !== "loglevel" && e.what !== "tweenChanges") {
						if (e.what === "triggerElement") {
							updateTriggerElementPosition();
						} else if (e.what === "reverse") {
							Scene.update();
						}
					}
				}).on("shift.internal", function (e) {
					updateScrollOffset();
					Scene.update();
				});
				var log = this._log = function (loglevel, output) {
					if (_options.loglevel >= loglevel) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ") ->");
						_util.log.apply(window, arguments);
					}
				};
				this.addTo = function (controller) {
					if (!(controller instanceof ScrollMagic.Controller)) {
						log(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller");
					} else if (_controller != controller) {
						if (_controller) {
							_controller.removeScene(Scene);
						}
						_controller = controller;
						validateOption();
						updateDuration(true);
						updateTriggerElementPosition(true);
						updateScrollOffset();
						_controller.info("container").addEventListener('resize', onContainerResize);
						controller.addScene(Scene);
						Scene.trigger("add", {
							controller: _controller
						});
						log(3, "added " + NAMESPACE + " to controller");
						Scene.update();
					}
					return Scene;
				};
				this.enabled = function (newState) {
					if (!arguments.length) {
						return _enabled;
					} else if (_enabled != newState) {
						_enabled = !!newState;
						Scene.update(true);
					}
					return Scene;
				};
				this.remove = function () {
					if (_controller) {
						_controller.info("container").removeEventListener('resize', onContainerResize);
						var tmpParent = _controller;
						_controller = undefined;
						tmpParent.removeScene(Scene);
						Scene.trigger("remove");
						log(3, "removed " + NAMESPACE + " from controller");
					}
					return Scene;
				};
				this.destroy = function (reset) {
					Scene.trigger("destroy", {
						reset: reset
					});
					Scene.remove();
					Scene.off("*.*");
					log(3, "destroyed " + NAMESPACE + " (reset: " + (reset ? "true" : "false") + ")");
					return null;
				};
				this.update = function (immediately) {
					if (_controller) {
						if (immediately) {
							if (_controller.enabled() && _enabled) {
								var scrollPos = _controller.info("scrollPos"),
									newProgress;
								if (_options.duration > 0) {
									newProgress = (scrollPos - _scrollOffset.start) / (_scrollOffset.end - _scrollOffset.start);
								} else {
									newProgress = scrollPos >= _scrollOffset.start ? 1 : 0;
								}
								Scene.trigger("update", {
									startPos: _scrollOffset.start,
									endPos: _scrollOffset.end,
									scrollPos: scrollPos
								});
								Scene.progress(newProgress);
							} else if (_pin && _state === SCENE_STATE_DURING) {
								updatePinState(true);
							}
						} else {
							_controller.updateScene(Scene, false);
						}
					}
					return Scene;
				};
				this.refresh = function () {
					updateDuration();
					updateTriggerElementPosition();
					return Scene;
				};
				this.progress = function (progress) {
					if (!arguments.length) {
						return _progress;
					} else {
						var doUpdate = false,
							oldState = _state,
							scrollDirection = _controller ? _controller.info("scrollDirection") : 'PAUSED',
							reverseOrForward = _options.reverse || progress >= _progress;
						if (_options.duration === 0) {
							doUpdate = _progress != progress;
							_progress = progress < 1 && reverseOrForward ? 0 : 1;
							_state = _progress === 0 ? SCENE_STATE_BEFORE : SCENE_STATE_DURING;
						} else {
							if (progress < 0 && _state !== SCENE_STATE_BEFORE && reverseOrForward) {
								_progress = 0;
								_state = SCENE_STATE_BEFORE;
								doUpdate = true;
							} else if (progress >= 0 && progress < 1 && reverseOrForward) {
								_progress = progress;
								_state = SCENE_STATE_DURING;
								doUpdate = true;
							} else if (progress >= 1 && _state !== SCENE_STATE_AFTER) {
								_progress = 1;
								_state = SCENE_STATE_AFTER;
								doUpdate = true;
							} else if (_state === SCENE_STATE_DURING && !reverseOrForward) {
								updatePinState();
							}
						}
						if (doUpdate) {
							var eventVars = {
								progress: _progress,
								state: _state,
								scrollDirection: scrollDirection
							},
								stateChanged = _state != oldState;
							var trigger = function trigger(eventName) {
								Scene.trigger(eventName, eventVars);
							};
							if (stateChanged) {
								if (oldState !== SCENE_STATE_DURING) {
									trigger("enter");
									trigger(oldState === SCENE_STATE_BEFORE ? "start" : "end");
								}
							}
							trigger("progress");
							if (stateChanged) {
								if (_state !== SCENE_STATE_DURING) {
									trigger(_state === SCENE_STATE_BEFORE ? "start" : "end");
									trigger("leave");
								}
							}
						}
						return Scene;
					}
				};
				var updateScrollOffset = function updateScrollOffset() {
					_scrollOffset = {
						start: _triggerPos + _options.offset
					};
					if (_controller && _options.triggerElement) {
						_scrollOffset.start -= _controller.info("size") * _options.triggerHook;
					}
					_scrollOffset.end = _scrollOffset.start + _options.duration;
				};
				var updateDuration = function updateDuration(suppressEvents) {
					if (_durationUpdateMethod) {
						var varname = "duration";
						if (changeOption(varname, _durationUpdateMethod.call(Scene)) && !suppressEvents) {
							Scene.trigger("change", {
								what: varname,
								newval: _options[varname]
							});
							Scene.trigger("shift", {
								reason: varname
							});
						}
					}
				};
				var updateTriggerElementPosition = function updateTriggerElementPosition(suppressEvents) {
					var elementPos = 0,
						telem = _options.triggerElement;
					if (_controller && telem) {
						var controllerInfo = _controller.info(),
							containerOffset = _util.get.offset(controllerInfo.container),
							param = controllerInfo.vertical ? "top" : "left";
						while (telem.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
							telem = telem.parentNode;
						}
						var elementOffset = _util.get.offset(telem);
						if (!controllerInfo.isDocument) {
							containerOffset[param] -= _controller.scrollPos();
						}
						elementPos = elementOffset[param] - containerOffset[param];
					}
					var changed = elementPos != _triggerPos;
					_triggerPos = elementPos;
					if (changed && !suppressEvents) {
						Scene.trigger("shift", {
							reason: "triggerElementPosition"
						});
					}
				};
				var onContainerResize = function onContainerResize(e) {
					if (_options.triggerHook > 0) {
						Scene.trigger("shift", {
							reason: "containerResize"
						});
					}
				};
				var _validate = _util.extend(SCENE_OPTIONS.validate, {
					duration: function duration(val) {
						if (_util.type.String(val) && val.match(/^(\.|\d)*\d+%$/)) {
							var perc = parseFloat(val) / 100;
							val = function val() {
								return _controller ? _controller.info("size") * perc : 0;
							};
						}
						if (_util.type.Function(val)) {
							_durationUpdateMethod = val;
							try {
								val = parseFloat(_durationUpdateMethod());
							} catch (e) {
								val = -1;
							}
						}
						val = parseFloat(val);
						if (!_util.type.Number(val) || val < 0) {
							if (_durationUpdateMethod) {
								_durationUpdateMethod = undefined;
								throw ["Invalid return value of supplied function for option \"duration\":", val];
							} else {
								throw ["Invalid value for option \"duration\":", val];
							}
						}
						return val;
					}
				});
				var validateOption = function validateOption(check) {
					check = arguments.length ? [check] : Object.keys(_validate);
					check.forEach(function (optionName, key) {
						var value;
						if (_validate[optionName]) {
							try {
								value = _validate[optionName](_options[optionName]);
							} catch (e) {
								value = DEFAULT_OPTIONS[optionName];
								var logMSG = _util.type.String(e) ? [e] : e;
								if (_util.type.Array(logMSG)) {
									logMSG[0] = "ERROR: " + logMSG[0];
									logMSG.unshift(1);
									log.apply(this, logMSG);
								} else {
									log(1, "ERROR: Problem executing validation callback for option '" + optionName + "':", e.message);
								}
							} finally {
								_options[optionName] = value;
							}
						}
					});
				};
				var changeOption = function changeOption(varname, newval) {
					var changed = false,
						oldval = _options[varname];
					if (_options[varname] != newval) {
						_options[varname] = newval;
						validateOption(varname);
						changed = oldval != _options[varname];
					}
					return changed;
				};
				var addSceneOption = function addSceneOption(optionName) {
					if (!Scene[optionName]) {
						Scene[optionName] = function (newVal) {
							if (!arguments.length) {
								return _options[optionName];
							} else {
								if (optionName === "duration") {
									_durationUpdateMethod = undefined;
								}
								if (changeOption(optionName, newVal)) {
									Scene.trigger("change", {
										what: optionName,
										newval: _options[optionName]
									});
									if (SCENE_OPTIONS.shifts.indexOf(optionName) > -1) {
										Scene.trigger("shift", {
											reason: optionName
										});
									}
								}
							}
							return Scene;
						};
					}
				};
				this.controller = function () {
					return _controller;
				};
				this.state = function () {
					return _state;
				};
				this.scrollOffset = function () {
					return _scrollOffset.start;
				};
				this.triggerPosition = function () {
					var pos = _options.offset;
					if (_controller) {
						if (_options.triggerElement) {
							pos += _triggerPos;
						} else {
							pos += _controller.info("size") * Scene.triggerHook();
						}
					}
					return pos;
				};
				var _pin, _pinOptions;
				Scene.on("shift.internal", function (e) {
					var durationChanged = e.reason === "duration";
					if (_state === SCENE_STATE_AFTER && durationChanged || _state === SCENE_STATE_DURING && _options.duration === 0) {
						updatePinState();
					}
					if (durationChanged) {
						updatePinDimensions();
					}
				}).on("progress.internal", function (e) {
					updatePinState();
				}).on("add.internal", function (e) {
					updatePinDimensions();
				}).on("destroy.internal", function (e) {
					Scene.removePin(e.reset);
				});
				var updatePinState = function updatePinState(forceUnpin) {
					if (_pin && _controller) {
						var containerInfo = _controller.info(),
							pinTarget = _pinOptions.spacer.firstChild;
						if (!forceUnpin && _state === SCENE_STATE_DURING) {
							if (_util.css(pinTarget, "position") != "fixed") {
								_util.css(pinTarget, {
									"position": "fixed"
								});
								updatePinDimensions();
							}
							var fixedPos = _util.get.offset(_pinOptions.spacer, true),
								scrollDistance = _options.reverse || _options.duration === 0 ? containerInfo.scrollPos - _scrollOffset.start : Math.round(_progress * _options.duration * 10) / 10;
							fixedPos[containerInfo.vertical ? "top" : "left"] += scrollDistance;
							_util.css(_pinOptions.spacer.firstChild, {
								top: fixedPos.top,
								left: fixedPos.left
							});
						} else {
							var newCSS = {
								position: _pinOptions.inFlow ? "relative" : "absolute",
								top: 0,
								left: 0
							},
								change = _util.css(pinTarget, "position") != newCSS.position;
							if (!_pinOptions.pushFollowers) {
								newCSS[containerInfo.vertical ? "top" : "left"] = _options.duration * _progress;
							} else if (_options.duration > 0) {
								if (_state === SCENE_STATE_AFTER && parseFloat(_util.css(_pinOptions.spacer, "padding-top")) === 0) {
									change = true;
								} else if (_state === SCENE_STATE_BEFORE && parseFloat(_util.css(_pinOptions.spacer, "padding-bottom")) === 0) {
									change = true;
								}
							}
							_util.css(pinTarget, newCSS);
							if (change) {
								updatePinDimensions();
							}
						}
					}
				};
				var updatePinDimensions = function updatePinDimensions() {
					if (_pin && _controller && _pinOptions.inFlow) {
						var after = _state === SCENE_STATE_AFTER,
							before = _state === SCENE_STATE_BEFORE,
							during = _state === SCENE_STATE_DURING,
							vertical = _controller.info("vertical"),
							pinTarget = _pinOptions.spacer.firstChild,
							marginCollapse = _util.isMarginCollapseType(_util.css(_pinOptions.spacer, "display")),
							css = {};
						if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
							if (during) {
								_util.css(_pin, {
									"width": _util.get.width(_pinOptions.spacer)
								});
							} else {
								_util.css(_pin, {
									"width": "100%"
								});
							}
						} else {
							css["min-width"] = _util.get.width(vertical ? _pin : pinTarget, true, true);
							css.width = during ? css["min-width"] : "auto";
						}
						if (_pinOptions.relSize.height) {
							if (during) {
								_util.css(_pin, {
									"height": _util.get.height(_pinOptions.spacer) - (_pinOptions.pushFollowers ? _options.duration : 0)
								});
							} else {
								_util.css(_pin, {
									"height": "100%"
								});
							}
						} else {
							css["min-height"] = _util.get.height(vertical ? pinTarget : _pin, true, !marginCollapse);
							css.height = during ? css["min-height"] : "auto";
						}
						if (_pinOptions.pushFollowers) {
							css["padding" + (vertical ? "Top" : "Left")] = _options.duration * _progress;
							css["padding" + (vertical ? "Bottom" : "Right")] = _options.duration * (1 - _progress);
						}
						_util.css(_pinOptions.spacer, css);
					}
				};
				var updatePinInContainer = function updatePinInContainer() {
					if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
						updatePinState();
					}
				};
				var updateRelativePinSpacer = function updateRelativePinSpacer() {
					if (_controller && _pin && _state === SCENE_STATE_DURING && ((_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) && _util.get.width(window) != _util.get.width(_pinOptions.spacer.parentNode) || _pinOptions.relSize.height && _util.get.height(window) != _util.get.height(_pinOptions.spacer.parentNode))) {
						updatePinDimensions();
					}
				};
				var onMousewheelOverPin = function onMousewheelOverPin(e) {
					if (_controller && _pin && _state === SCENE_STATE_DURING && !_controller.info("isDocument")) {
						e.preventDefault();
						_controller._setScrollPos(_controller.info("scrollPos") - ((e.wheelDelta || e[_controller.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || -e.detail * 30));
					}
				};
				this.setPin = function (element, settings) {
					var defaultSettings = {
						pushFollowers: true,
						spacerClass: "scrollmagic-pin-spacer"
					};
					settings = _util.extend({}, defaultSettings, settings);
					element = _util.get.elements(element)[0];
					if (!element) {
						log(1, "ERROR calling method 'setPin()': Invalid pin element supplied.");
						return Scene;
					} else if (_util.css(element, "position") === "fixed") {
						log(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'.");
						return Scene;
					}
					if (_pin) {
						if (_pin === element) {
							return Scene;
						} else {
							Scene.removePin();
						}
					}
					_pin = element;
					var parentDisplay = _pin.parentNode.style.display,
						boundsParams = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
					_pin.parentNode.style.display = 'none';
					var inFlow = _util.css(_pin, "position") != "absolute",
						pinCSS = _util.css(_pin, boundsParams.concat(["display"])),
						sizeCSS = _util.css(_pin, ["width", "height"]);
					_pin.parentNode.style.display = parentDisplay;
					if (!inFlow && settings.pushFollowers) {
						log(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled.");
						settings.pushFollowers = false;
					}
					window.setTimeout(function () {
						if (_pin && _options.duration === 0 && settings.pushFollowers) {
							log(2, "WARNING: pushFollowers =", true, "has no effect, when scene duration is 0.");
						}
					}, 0);
					var spacer = _pin.parentNode.insertBefore(document.createElement('div'), _pin),
						spacerCSS = _util.extend(pinCSS, {
							position: inFlow ? "relative" : "absolute",
							boxSizing: "content-box",
							mozBoxSizing: "content-box",
							webkitBoxSizing: "content-box"
						});
					if (!inFlow) {
						_util.extend(spacerCSS, _util.css(_pin, ["width", "height"]));
					}
					_util.css(spacer, spacerCSS);
					spacer.setAttribute(PIN_SPACER_ATTRIBUTE, "");
					_util.addClass(spacer, settings.spacerClass);
					_pinOptions = {
						spacer: spacer,
						relSize: {
							width: sizeCSS.width.slice(-1) === "%",
							height: sizeCSS.height.slice(-1) === "%",
							autoFullWidth: sizeCSS.width === "auto" && inFlow && _util.isMarginCollapseType(pinCSS.display)
						},
						pushFollowers: settings.pushFollowers,
						inFlow: inFlow
					};
					if (!_pin.___origStyle) {
						_pin.___origStyle = {};
						var pinInlineCSS = _pin.style,
							copyStyles = boundsParams.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
						copyStyles.forEach(function (val) {
							_pin.___origStyle[val] = pinInlineCSS[val] || "";
						});
					}
					if (_pinOptions.relSize.width) {
						_util.css(spacer, {
							width: sizeCSS.width
						});
					}
					if (_pinOptions.relSize.height) {
						_util.css(spacer, {
							height: sizeCSS.height
						});
					}
					spacer.appendChild(_pin);
					_util.css(_pin, {
						position: inFlow ? "relative" : "absolute",
						margin: "auto",
						top: "auto",
						left: "auto",
						bottom: "auto",
						right: "auto"
					});
					if (_pinOptions.relSize.width || _pinOptions.relSize.autoFullWidth) {
						_util.css(_pin, {
							boxSizing: "border-box",
							mozBoxSizing: "border-box",
							webkitBoxSizing: "border-box"
						});
					}
					window.addEventListener('scroll', updatePinInContainer);
					window.addEventListener('resize', updatePinInContainer);
					window.addEventListener('resize', updateRelativePinSpacer);
					_pin.addEventListener("mousewheel", onMousewheelOverPin);
					_pin.addEventListener("DOMMouseScroll", onMousewheelOverPin);
					log(3, "added pin");
					updatePinState();
					return Scene;
				};
				this.removePin = function (reset) {
					if (_pin) {
						if (_state === SCENE_STATE_DURING) {
							updatePinState(true);
						}
						if (reset || !_controller) {
							var pinTarget = _pinOptions.spacer.firstChild;
							if (pinTarget.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
								var style = _pinOptions.spacer.style,
									values = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
								margins = {};
								values.forEach(function (val) {
									margins[val] = style[val] || "";
								});
								_util.css(pinTarget, margins);
							}
							_pinOptions.spacer.parentNode.insertBefore(pinTarget, _pinOptions.spacer);
							_pinOptions.spacer.parentNode.removeChild(_pinOptions.spacer);
							if (!_pin.parentNode.hasAttribute(PIN_SPACER_ATTRIBUTE)) {
								_util.css(_pin, _pin.___origStyle);
								delete _pin.___origStyle;
							}
						}
						window.removeEventListener('scroll', updatePinInContainer);
						window.removeEventListener('resize', updatePinInContainer);
						window.removeEventListener('resize', updateRelativePinSpacer);
						_pin.removeEventListener("mousewheel", onMousewheelOverPin);
						_pin.removeEventListener("DOMMouseScroll", onMousewheelOverPin);
						_pin = undefined;
						log(3, "removed pin (reset: " + (reset ? "true" : "false") + ")");
					}
					return Scene;
				};
				var _cssClasses, _cssClassElems = [];
				Scene.on("destroy.internal", function (e) {
					Scene.removeClassToggle(e.reset);
				});
				this.setClassToggle = function (element, classes) {
					var elems = _util.get.elements(element);
					if (elems.length === 0 || !_util.type.String(classes)) {
						log(1, "ERROR calling method 'setClassToggle()': Invalid " + (elems.length === 0 ? "element" : "classes") + " supplied.");
						return Scene;
					}
					if (_cssClassElems.length > 0) {
						Scene.removeClassToggle();
					}
					_cssClasses = classes;
					_cssClassElems = elems;
					Scene.on("enter.internal_class leave.internal_class", function (e) {
						var toggle = e.type === "enter" ? _util.addClass : _util.removeClass;
						_cssClassElems.forEach(function (elem, key) {
							toggle(elem, _cssClasses);
						});
					});
					return Scene;
				};
				this.removeClassToggle = function (reset) {
					if (reset) {
						_cssClassElems.forEach(function (elem, key) {
							_util.removeClass(elem, _cssClasses);
						});
					}
					Scene.off("start.internal_class end.internal_class");
					_cssClasses = undefined;
					_cssClassElems = [];
					return Scene;
				};
				construct();
				return Scene;
			};
			var SCENE_OPTIONS = {
				defaults: {
					duration: 0,
					offset: 0,
					triggerElement: undefined,
					triggerHook: 0.5,
					reverse: true,
					loglevel: 2
				},
				validate: {
					offset: function offset(val) {
						val = parseFloat(val);
						if (!_util.type.Number(val)) {
							throw ["Invalid value for option \"offset\":", val];
						}
						return val;
					},
					triggerElement: function triggerElement(val) {
						val = val || undefined;
						if (val) {
							var elem = _util.get.elements(val)[0];
							if (elem) {
								val = elem;
							} else {
								throw ["Element defined in option \"triggerElement\" was not found:", val];
							}
						}
						return val;
					},
					triggerHook: function triggerHook(val) {
						var translate = {
							"onCenter": 0.5,
							"onEnter": 1,
							"onLeave": 0
						};
						if (_util.type.Number(val)) {
							val = Math.max(0, Math.min(parseFloat(val), 1));
						} else if (val in translate) {
							val = translate[val];
						} else {
							throw ["Invalid value for option \"triggerHook\": ", val];
						}
						return val;
					},
					reverse: function reverse(val) {
						return !!val;
					},
					loglevel: function loglevel(val) {
						val = parseInt(val);
						if (!_util.type.Number(val) || val < 0 || val > 3) {
							throw ["Invalid value for option \"loglevel\":", val];
						}
						return val;
					}
				},
				shifts: ["duration", "offset", "triggerHook"]
			};
			ScrollMagic.Scene.addOption = function (name, defaultValue, validationCallback, shifts) {
				if (!(name in SCENE_OPTIONS.defaults)) {
					SCENE_OPTIONS.defaults[name] = defaultValue;
					SCENE_OPTIONS.validate[name] = validationCallback;
					if (shifts) {
						SCENE_OPTIONS.shifts.push(name);
					}
				} else {
					ScrollMagic._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + name + "', because it already exists.");
				}
			};
			ScrollMagic.Scene.extend = function (extension) {
				var oldClass = this;
				ScrollMagic.Scene = function () {
					oldClass.apply(this, arguments);
					this.$super = _util.extend({}, this);
					return extension.apply(this, arguments) || this;
				};
				_util.extend(ScrollMagic.Scene, oldClass);
				ScrollMagic.Scene.prototype = oldClass.prototype;
				ScrollMagic.Scene.prototype.constructor = ScrollMagic.Scene;
			};
			ScrollMagic.Event = function (type, namespace, target, vars) {
				vars = vars || {};
				for (var key in vars) {
					this[key] = vars[key];
				}
				this.type = type;
				this.target = this.currentTarget = target;
				this.namespace = namespace || '';
				this.timeStamp = this.timestamp = Date.now();
				return this;
			};
			var _util = ScrollMagic._util = function (window) {
				var U = {},
					i;
				var floatval = function floatval(number) {
					return parseFloat(number) || 0;
				};
				var _getComputedStyle = function _getComputedStyle(elem) {
					return elem.currentStyle ? elem.currentStyle : window.getComputedStyle(elem);
				};
				var _dimension = function _dimension(which, elem, outer, includeMargin) {
					elem = elem === document ? window : elem;
					if (elem === window) {
						includeMargin = false;
					} else if (!_type.DomElement(elem)) {
						return 0;
					}
					which = which.charAt(0).toUpperCase() + which.substr(1).toLowerCase();
					var dimension = (outer ? elem['offset' + which] || elem['outer' + which] : elem['client' + which] || elem['inner' + which]) || 0;
					if (outer && includeMargin) {
						var style = _getComputedStyle(elem);
						dimension += which === 'Height' ? floatval(style.marginTop) + floatval(style.marginBottom) : floatval(style.marginLeft) + floatval(style.marginRight);
					}
					return dimension;
				};
				var _camelCase = function _camelCase(str) {
					return str.replace(/^[^a-z]+([a-z])/g, '$1').replace(/-([a-z])/g, function (g) {
						return g[1].toUpperCase();
					});
				};
				U.extend = function (obj) {
					obj = obj || {};
					for (i = 1; i < arguments.length; i++) {
						if (!arguments[i]) {
							continue;
						}
						for (var key in arguments[i]) {
							if (arguments[i].hasOwnProperty(key)) {
								obj[key] = arguments[i][key];
							}
						}
					}
					return obj;
				};
				U.isMarginCollapseType = function (str) {
					return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(str) > -1;
				};
				var lastTime = 0,
					vendors = ['ms', 'moz', 'webkit', 'o'];
				var _requestAnimationFrame = window.requestAnimationFrame;
				var _cancelAnimationFrame = window.cancelAnimationFrame;
				for (i = 0; !_requestAnimationFrame && i < vendors.length; ++i) {
					_requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
					_cancelAnimationFrame = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];
				}
				if (!_requestAnimationFrame) {
					_requestAnimationFrame = function _requestAnimationFrame(callback) {
						var currTime = new Date().getTime(),
							timeToCall = Math.max(0, 16 - (currTime - lastTime)),
							id = window.setTimeout(function () {
								callback(currTime + timeToCall);
							}, timeToCall);
						lastTime = currTime + timeToCall;
						return id;
					};
				}
				if (!_cancelAnimationFrame) {
					_cancelAnimationFrame = function _cancelAnimationFrame(id) {
						window.clearTimeout(id);
					};
				}
				U.rAF = _requestAnimationFrame.bind(window);
				U.cAF = _cancelAnimationFrame.bind(window);
				var loglevels = ["error", "warn", "log"],
					console = window.console || {};
				console.log = console.log || function () { };
				for (i = 0; i < loglevels.length; i++) {
					var method = loglevels[i];
					if (!console[method]) {
						console[method] = console.log;
					}
				}
				U.log = function (loglevel) {
					if (loglevel > loglevels.length || loglevel <= 0) loglevel = loglevels.length;
					var now = new Date(),
						time = ("0" + now.getHours()).slice(-2) + ":" + ("0" + now.getMinutes()).slice(-2) + ":" + ("0" + now.getSeconds()).slice(-2) + ":" + ("00" + now.getMilliseconds()).slice(-3),
						method = loglevels[loglevel - 1],
						args = Array.prototype.splice.call(arguments, 1),
						func = Function.prototype.bind.call(console[method], console);
					args.unshift(time);
					func.apply(console, args);
				};
				var _type = U.type = function (v) {
					return Object.prototype.toString.call(v).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
				};
				_type.String = function (v) {
					return _type(v) === 'string';
				};
				_type.Function = function (v) {
					return _type(v) === 'function';
				};
				_type.Array = function (v) {
					return Array.isArray(v);
				};
				_type.Number = function (v) {
					return !_type.Array(v) && v - parseFloat(v) + 1 >= 0;
				};
				_type.DomElement = function (o) {
					return (typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === "object" ? o instanceof HTMLElement : o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
				};
				var _get = U.get = {};
				_get.elements = function (selector) {
					var arr = [];
					if (_type.String(selector)) {
						try {
							selector = document.querySelectorAll(selector);
						} catch (e) {
							return arr;
						}
					}
					if (_type(selector) === 'nodelist' || _type.Array(selector)) {
						for (var i = 0, ref = arr.length = selector.length; i < ref; i++) {
							var elem = selector[i];
							arr[i] = _type.DomElement(elem) ? elem : _get.elements(elem);
						}
					} else if (_type.DomElement(selector) || selector === document || selector === window) {
						arr = [selector];
					}
					return arr;
				};
				_get.scrollTop = function (elem) {
					return elem && typeof elem.scrollTop === 'number' ? elem.scrollTop : window.pageYOffset || 0;
				};
				_get.scrollLeft = function (elem) {
					return elem && typeof elem.scrollLeft === 'number' ? elem.scrollLeft : window.pageXOffset || 0;
				};
				_get.width = function (elem, outer, includeMargin) {
					return _dimension('width', elem, outer, includeMargin);
				};
				_get.height = function (elem, outer, includeMargin) {
					return _dimension('height', elem, outer, includeMargin);
				};
				_get.offset = function (elem, relativeToViewport) {
					var offset = {
						top: 0,
						left: 0
					};
					if (elem && elem.getBoundingClientRect) {
						var rect = elem.getBoundingClientRect();
						offset.top = rect.top;
						offset.left = rect.left;
						if (!relativeToViewport) {
							offset.top += _get.scrollTop();
							offset.left += _get.scrollLeft();
						}
					}
					return offset;
				};
				U.addClass = function (elem, classname) {
					if (classname) {
						if (elem.classList) elem.classList.add(classname);
						else elem.className += ' ' + classname;
					}
				};
				U.removeClass = function (elem, classname) {
					if (classname) {
						if (elem.classList) elem.classList.remove(classname);
						else elem.className = elem.className.replace(new RegExp('(^|\\b)' + classname.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
					}
				};
				U.css = function (elem, options) {
					if (_type.String(options)) {
						return _getComputedStyle(elem)[_camelCase(options)];
					} else if (_type.Array(options)) {
						var obj = {},
							style = _getComputedStyle(elem);
						options.forEach(function (option, key) {
							obj[option] = style[_camelCase(option)];
						});
						return obj;
					} else {
						for (var option in options) {
							var val = options[option];
							if (val == parseFloat(val)) {
								val += 'px';
							}
							elem.style[_camelCase(option)] = val;
						}
					}
				};
				return U;
			}(window || {});
			ScrollMagic.Scene.prototype.addIndicators = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
				return this;
			};
			ScrollMagic.Scene.prototype.removeIndicators = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin \'debug.addIndicators\'. Please make sure to include plugins/debug.addIndicators.js');
				return this;
			};
			ScrollMagic.Scene.prototype.setTween = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
				return this;
			};
			ScrollMagic.Scene.prototype.removeTween = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin \'animation.gsap\'. Please make sure to include plugins/animation.gsap.js');
				return this;
			};
			ScrollMagic.Scene.prototype.setVelocity = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
				return this;
			};
			ScrollMagic.Scene.prototype.removeVelocity = function () {
				ScrollMagic._util.log(1, '(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin \'animation.velocity\'. Please make sure to include plugins/animation.velocity.js');
				return this;
			};
			return ScrollMagic;
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (global) {
			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
				return typeof obj;
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
			};
			/*!
			 * VERSION: 2.0.1
			 * DATE: 2018-05-30
			 * UPDATES AND DOCS AT: http://greensock.com
			 * 
			 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
			 *
			 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
			 * This work is subject to the terms at http://greensock.com/standard-license or for
			 * Club GreenSock members, the software agreement that was issued with your membership.
			 * 
			 * @author: Jack Doyle, jack@greensock.com
			 **/
			var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : undefined || window;
			(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
				"use strict";
				_gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
					var _slice = function _slice(a) {
						var b = [],
							l = a.length,
							i;
						for (i = 0; i !== l; b.push(a[i++])) { }
						return b;
					},
						_applyCycle = function _applyCycle(vars, targets, i) {
							var alt = vars.cycle,
								p, val;
							for (p in alt) {
								val = alt[p];
								vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length];
							}
							delete vars.cycle;
						},
						TweenMax = function TweenMax(target, duration, vars) {
							TweenLite.call(this, target, duration, vars);
							this._cycle = 0;
							this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
							this._repeat = this.vars.repeat || 0;
							this._repeatDelay = this.vars.repeatDelay || 0;
							if (this._repeat) {
								this._uncache(true);
							}
							this.render = TweenMax.prototype.render;
						},
						_tinyNum = 0.0000000001,
						TweenLiteInternals = TweenLite._internals,
						_isSelector = TweenLiteInternals.isSelector,
						_isArray = TweenLiteInternals.isArray,
						p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
						_blankArray = [];
					TweenMax.version = "2.0.1";
					p.constructor = TweenMax;
					p.kill()._gc = false;
					TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
					TweenMax.getTweensOf = TweenLite.getTweensOf;
					TweenMax.lagSmoothing = TweenLite.lagSmoothing;
					TweenMax.ticker = TweenLite.ticker;
					TweenMax.render = TweenLite.render;
					p.invalidate = function () {
						this._yoyo = this.vars.yoyo === true || !!this.vars.yoyoEase;
						this._repeat = this.vars.repeat || 0;
						this._repeatDelay = this.vars.repeatDelay || 0;
						this._yoyoEase = null;
						this._uncache(true);
						return TweenLite.prototype.invalidate.call(this);
					};
					p.updateTo = function (vars, resetDuration) {
						var curRatio = this.ratio,
							immediate = this.vars.immediateRender || vars.immediateRender,
							p;
						if (resetDuration && this._startTime < this._timeline._time) {
							this._startTime = this._timeline._time;
							this._uncache(false);
							if (this._gc) {
								this._enabled(true, false);
							} else {
								this._timeline.insert(this, this._startTime - this._delay);
							}
						}
						for (p in vars) {
							this.vars[p] = vars[p];
						}
						if (this._initted || immediate) {
							if (resetDuration) {
								this._initted = false;
								if (immediate) {
									this.render(0, true, true);
								}
							} else {
								if (this._gc) {
									this._enabled(true, false);
								}
								if (this._notifyPluginsOfEnabled && this._firstPT) {
									TweenLite._onPluginEvent("_onDisable", this);
								}
								if (this._time / this._duration > 0.998) {
									var prevTime = this._totalTime;
									this.render(0, true, false);
									this._initted = false;
									this.render(prevTime, true, false);
								} else {
									this._initted = false;
									this._init();
									if (this._time > 0 || immediate) {
										var inv = 1 / (1 - curRatio),
											pt = this._firstPT,
											endValue;
										while (pt) {
											endValue = pt.s + pt.c;
											pt.c *= inv;
											pt.s = endValue - pt.c;
											pt = pt._next;
										}
									}
								}
							}
						}
						return this;
					};
					p.render = function (time, suppressEvents, force) {
						if (!this._initted)
							if (this._duration === 0 && this.vars.repeat) {
								this.invalidate();
							}
						var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
							prevTime = this._time,
							prevTotalTime = this._totalTime,
							prevCycle = this._cycle,
							duration = this._duration,
							prevRawPrevTime = this._rawPrevTime,
							isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime, yoyoEase;
						if (time >= totalDur - 0.0000001 && time >= 0) {
							this._totalTime = totalDur;
							this._cycle = this._repeat;
							if (this._yoyo && (this._cycle & 1) !== 0) {
								this._time = 0;
								this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
							} else {
								this._time = duration;
								this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
							}
							if (!this._reversed) {
								isComplete = true;
								callback = "onComplete";
								force = force || this._timeline.autoRemoveChildren;
							}
							if (duration === 0)
								if (this._initted || !this.vars.lazy || force) {
									if (this._startTime === this._timeline._duration) {
										time = 0;
									}
									if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause")
										if (prevRawPrevTime !== time) {
											force = true;
											if (prevRawPrevTime > _tinyNum) {
												callback = "onReverseComplete";
											}
										}
									this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
								}
						} else if (time < 0.0000001) {
							this._totalTime = this._time = this._cycle = 0;
							this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
							if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
								callback = "onReverseComplete";
								isComplete = this._reversed;
							}
							if (time < 0) {
								this._active = false;
								if (duration === 0)
									if (this._initted || !this.vars.lazy || force) {
										if (prevRawPrevTime >= 0) {
											force = true;
										}
										this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
									}
							}
							if (!this._initted) {
								force = true;
							}
						} else {
							this._totalTime = this._time = time;
							if (this._repeat !== 0) {
								cycleDuration = duration + this._repeatDelay;
								this._cycle = this._totalTime / cycleDuration >> 0;
								if (this._cycle !== 0)
									if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
										this._cycle--;
									}
								this._time = this._totalTime - this._cycle * cycleDuration;
								if (this._yoyo)
									if ((this._cycle & 1) !== 0) {
										this._time = duration - this._time;
										yoyoEase = this._yoyoEase || this.vars.yoyoEase;
										if (yoyoEase) {
											if (!this._yoyoEase) {
												if (yoyoEase === true && !this._initted) {
													yoyoEase = this.vars.ease;
													this._yoyoEase = yoyoEase = !yoyoEase ? TweenLite.defaultEase : yoyoEase instanceof Ease ? yoyoEase : typeof yoyoEase === "function" ? new Ease(yoyoEase, this.vars.easeParams) : Ease.map[yoyoEase] || TweenLite.defaultEase;
												} else {
													this._yoyoEase = yoyoEase = yoyoEase === true ? this._ease : yoyoEase instanceof Ease ? yoyoEase : Ease.map[yoyoEase];
												}
											}
											this.ratio = yoyoEase ? 1 - yoyoEase.getRatio((duration - this._time) / duration) : 0;
										}
									}
								if (this._time > duration) {
									this._time = duration;
								} else if (this._time < 0) {
									this._time = 0;
								}
							}
							if (this._easeType && !yoyoEase) {
								r = this._time / duration;
								type = this._easeType;
								pow = this._easePower;
								if (type === 1 || type === 3 && r >= 0.5) {
									r = 1 - r;
								}
								if (type === 3) {
									r *= 2;
								}
								if (pow === 1) {
									r *= r;
								} else if (pow === 2) {
									r *= r * r;
								} else if (pow === 3) {
									r *= r * r * r;
								} else if (pow === 4) {
									r *= r * r * r * r;
								}
								if (type === 1) {
									this.ratio = 1 - r;
								} else if (type === 2) {
									this.ratio = r;
								} else if (this._time / duration < 0.5) {
									this.ratio = r / 2;
								} else {
									this.ratio = 1 - r / 2;
								}
							} else if (!yoyoEase) {
								this.ratio = this._ease.getRatio(this._time / duration);
							}
						}
						if (prevTime === this._time && !force && prevCycle === this._cycle) {
							if (prevTotalTime !== this._totalTime)
								if (this._onUpdate)
									if (!suppressEvents) {
										this._callback("onUpdate");
									}
							return;
						} else if (!this._initted) {
							this._init();
							if (!this._initted || this._gc) {
								return;
							} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
								this._time = prevTime;
								this._totalTime = prevTotalTime;
								this._rawPrevTime = prevRawPrevTime;
								this._cycle = prevCycle;
								TweenLiteInternals.lazyTweens.push(this);
								this._lazy = [time, suppressEvents];
								return;
							}
							if (this._time && !isComplete && !yoyoEase) {
								this.ratio = this._ease.getRatio(this._time / duration);
							} else if (isComplete && this._ease._calcEnd && !yoyoEase) {
								this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
							}
						}
						if (this._lazy !== false) {
							this._lazy = false;
						}
						if (!this._active)
							if (!this._paused && this._time !== prevTime && time >= 0) {
								this._active = true;
							}
						if (prevTotalTime === 0) {
							if (this._initted === 2 && time > 0) {
								this._init();
							}
							if (this._startAt) {
								if (time >= 0) {
									this._startAt.render(time, true, force);
								} else if (!callback) {
									callback = "_dummyGS";
								}
							}
							if (this.vars.onStart)
								if (this._totalTime !== 0 || duration === 0)
									if (!suppressEvents) {
										this._callback("onStart");
									}
						}
						pt = this._firstPT;
						while (pt) {
							if (pt.f) {
								pt.t[pt.p](pt.c * this.ratio + pt.s);
							} else {
								pt.t[pt.p] = pt.c * this.ratio + pt.s;
							}
							pt = pt._next;
						}
						if (this._onUpdate) {
							if (time < 0)
								if (this._startAt && this._startTime) {
									this._startAt.render(time, true, force);
								}
							if (!suppressEvents)
								if (this._totalTime !== prevTotalTime || callback) {
									this._callback("onUpdate");
								}
						}
						if (this._cycle !== prevCycle)
							if (!suppressEvents)
								if (!this._gc)
									if (this.vars.onRepeat) {
										this._callback("onRepeat");
									}
						if (callback)
							if (!this._gc || force) {
								if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
									this._startAt.render(time, true, force);
								}
								if (isComplete) {
									if (this._timeline.autoRemoveChildren) {
										this._enabled(false, false);
									}
									this._active = false;
								}
								if (!suppressEvents && this.vars[callback]) {
									this._callback(callback);
								}
								if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
									this._rawPrevTime = 0;
								}
							}
					};
					TweenMax.to = function (target, duration, vars) {
						return new TweenMax(target, duration, vars);
					};
					TweenMax.from = function (target, duration, vars) {
						vars.runBackwards = true;
						vars.immediateRender = vars.immediateRender != false;
						return new TweenMax(target, duration, vars);
					};
					TweenMax.fromTo = function (target, duration, fromVars, toVars) {
						toVars.startAt = fromVars;
						toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
						return new TweenMax(target, duration, toVars);
					};
					TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						stagger = stagger || 0;
						var delay = 0,
							a = [],
							finalComplete = function finalComplete() {
								if (vars.onComplete) {
									vars.onComplete.apply(vars.onCompleteScope || this, arguments);
								}
								onCompleteAll.apply(onCompleteAllScope || vars.callbackScope || this, onCompleteAllParams || _blankArray);
							},
							cycle = vars.cycle,
							fromCycle = vars.startAt && vars.startAt.cycle,
							l, copy, i, p;
						if (!_isArray(targets)) {
							if (typeof targets === "string") {
								targets = TweenLite.selector(targets) || targets;
							}
							if (_isSelector(targets)) {
								targets = _slice(targets);
							}
						}
						targets = targets || [];
						if (stagger < 0) {
							targets = _slice(targets);
							targets.reverse();
							stagger *= -1;
						}
						l = targets.length - 1;
						for (i = 0; i <= l; i++) {
							copy = {};
							for (p in vars) {
								copy[p] = vars[p];
							}
							if (cycle) {
								_applyCycle(copy, targets, i);
								if (copy.duration != null) {
									duration = copy.duration;
									delete copy.duration;
								}
							}
							if (fromCycle) {
								fromCycle = copy.startAt = {};
								for (p in vars.startAt) {
									fromCycle[p] = vars.startAt[p];
								}
								_applyCycle(copy.startAt, targets, i);
							}
							copy.delay = delay + (copy.delay || 0);
							if (i === l && onCompleteAll) {
								copy.onComplete = finalComplete;
							}
							a[i] = new TweenMax(targets[i], duration, copy);
							delay += stagger;
						}
						return a;
					};
					TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						vars.runBackwards = true;
						vars.immediateRender = vars.immediateRender != false;
						return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						toVars.startAt = fromVars;
						toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
						return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
						return new TweenMax(callback, 0, {
							delay: delay,
							onComplete: callback,
							onCompleteParams: params,
							callbackScope: scope,
							onReverseComplete: callback,
							onReverseCompleteParams: params,
							immediateRender: false,
							useFrames: useFrames,
							overwrite: 0
						});
					};
					TweenMax.set = function (target, vars) {
						return new TweenMax(target, 0, vars);
					};
					TweenMax.isTweening = function (target) {
						return TweenLite.getTweensOf(target, true).length > 0;
					};
					var _getChildrenOf = function _getChildrenOf(timeline, includeTimelines) {
						var a = [],
							cnt = 0,
							tween = timeline._first;
						while (tween) {
							if (tween instanceof TweenLite) {
								a[cnt++] = tween;
							} else {
								if (includeTimelines) {
									a[cnt++] = tween;
								}
								a = a.concat(_getChildrenOf(tween, includeTimelines));
								cnt = a.length;
							}
							tween = tween._next;
						}
						return a;
					},
						getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
							return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
						};
					TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
						if (tweens == null) {
							tweens = true;
						}
						if (delayedCalls == null) {
							delayedCalls = true;
						}
						var a = getAllTweens(timelines != false),
							l = a.length,
							allTrue = tweens && delayedCalls && timelines,
							isDC, tween, i;
						for (i = 0; i < l; i++) {
							tween = a[i];
							if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
								if (complete) {
									tween.totalTime(tween._reversed ? 0 : tween.totalDuration());
								} else {
									tween._enabled(false, false);
								}
							}
						}
					};
					TweenMax.killChildTweensOf = function (parent, complete) {
						if (parent == null) {
							return;
						}
						var tl = TweenLiteInternals.tweenLookup,
							a, curParent, p, i, l;
						if (typeof parent === "string") {
							parent = TweenLite.selector(parent) || parent;
						}
						if (_isSelector(parent)) {
							parent = _slice(parent);
						}
						if (_isArray(parent)) {
							i = parent.length;
							while (--i > -1) {
								TweenMax.killChildTweensOf(parent[i], complete);
							}
							return;
						}
						a = [];
						for (p in tl) {
							curParent = tl[p].target.parentNode;
							while (curParent) {
								if (curParent === parent) {
									a = a.concat(tl[p].tweens);
								}
								curParent = curParent.parentNode;
							}
						}
						l = a.length;
						for (i = 0; i < l; i++) {
							if (complete) {
								a[i].totalTime(a[i].totalDuration());
							}
							a[i]._enabled(false, false);
						}
					};
					var _changePause = function _changePause(pause, tweens, delayedCalls, timelines) {
						tweens = tweens !== false;
						delayedCalls = delayedCalls !== false;
						timelines = timelines !== false;
						var a = getAllTweens(timelines),
							allTrue = tweens && delayedCalls && timelines,
							i = a.length,
							isDC, tween;
						while (--i > -1) {
							tween = a[i];
							if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
								tween.paused(pause);
							}
						}
					};
					TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
						_changePause(true, tweens, delayedCalls, timelines);
					};
					TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
						_changePause(false, tweens, delayedCalls, timelines);
					};
					TweenMax.globalTimeScale = function (value) {
						var tl = Animation._rootTimeline,
							t = TweenLite.ticker.time;
						if (!arguments.length) {
							return tl._timeScale;
						}
						value = value || _tinyNum;
						tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
						tl = Animation._rootFramesTimeline;
						t = TweenLite.ticker.frame;
						tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
						tl._timeScale = Animation._rootTimeline._timeScale = value;
						return value;
					};
					p.progress = function (value, suppressEvents) {
						return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
					};
					p.totalProgress = function (value, suppressEvents) {
						return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents);
					};
					p.time = function (value, suppressEvents) {
						if (!arguments.length) {
							return this._time;
						}
						if (this._dirty) {
							this.totalDuration();
						}
						if (value > this._duration) {
							value = this._duration;
						}
						if (this._yoyo && (this._cycle & 1) !== 0) {
							value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
						} else if (this._repeat !== 0) {
							value += this._cycle * (this._duration + this._repeatDelay);
						}
						return this.totalTime(value, suppressEvents);
					};
					p.duration = function (value) {
						if (!arguments.length) {
							return this._duration;
						}
						return Animation.prototype.duration.call(this, value);
					};
					p.totalDuration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
								this._dirty = false;
							}
							return this._totalDuration;
						}
						return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
					};
					p.repeat = function (value) {
						if (!arguments.length) {
							return this._repeat;
						}
						this._repeat = value;
						return this._uncache(true);
					};
					p.repeatDelay = function (value) {
						if (!arguments.length) {
							return this._repeatDelay;
						}
						this._repeatDelay = value;
						return this._uncache(true);
					};
					p.yoyo = function (value) {
						if (!arguments.length) {
							return this._yoyo;
						}
						this._yoyo = value;
						return this;
					};
					return TweenMax;
				}, true);
				_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
					var TimelineLite = function TimelineLite(vars) {
						SimpleTimeline.call(this, vars);
						this._labels = {};
						this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
						this.smoothChildTiming = this.vars.smoothChildTiming === true;
						this._sortChildren = true;
						this._onUpdate = this.vars.onUpdate;
						var v = this.vars,
							val, p;
						for (p in v) {
							val = v[p];
							if (_isArray(val))
								if (val.join("").indexOf("{self}") !== -1) {
									v[p] = this._swapSelfInParams(val);
								}
						}
						if (_isArray(v.tweens)) {
							this.add(v.tweens, 0, v.align, v.stagger);
						}
					},
						_tinyNum = 0.0000000001,
						TweenLiteInternals = TweenLite._internals,
						_internals = TimelineLite._internals = {},
						_isSelector = TweenLiteInternals.isSelector,
						_isArray = TweenLiteInternals.isArray,
						_lazyTweens = TweenLiteInternals.lazyTweens,
						_lazyRender = TweenLiteInternals.lazyRender,
						_globals = _gsScope._gsDefine.globals,
						_copy = function _copy(vars) {
							var copy = {},
								p;
							for (p in vars) {
								copy[p] = vars[p];
							}
							return copy;
						},
						_applyCycle = function _applyCycle(vars, targets, i) {
							var alt = vars.cycle,
								p, val;
							for (p in alt) {
								val = alt[p];
								vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length];
							}
							delete vars.cycle;
						},
						_pauseCallback = _internals.pauseCallback = function () { },
						_slice = function _slice(a) {
							var b = [],
								l = a.length,
								i;
							for (i = 0; i !== l; b.push(a[i++])) { }
							return b;
						},
						p = TimelineLite.prototype = new SimpleTimeline();
					TimelineLite.version = "2.0.1";
					p.constructor = TimelineLite;
					p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
					p.to = function (target, duration, vars, position) {
						var Engine = vars.repeat && _globals.TweenMax || TweenLite;
						return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
					};
					p.from = function (target, duration, vars, position) {
						return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
					};
					p.fromTo = function (target, duration, fromVars, toVars, position) {
						var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
						return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
					};
					p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						var tl = new TimelineLite({
							onComplete: onCompleteAll,
							onCompleteParams: onCompleteAllParams,
							callbackScope: onCompleteAllScope,
							smoothChildTiming: this.smoothChildTiming
						}),
							cycle = vars.cycle,
							copy, i;
						if (typeof targets === "string") {
							targets = TweenLite.selector(targets) || targets;
						}
						targets = targets || [];
						if (_isSelector(targets)) {
							targets = _slice(targets);
						}
						stagger = stagger || 0;
						if (stagger < 0) {
							targets = _slice(targets);
							targets.reverse();
							stagger *= -1;
						}
						for (i = 0; i < targets.length; i++) {
							copy = _copy(vars);
							if (copy.startAt) {
								copy.startAt = _copy(copy.startAt);
								if (copy.startAt.cycle) {
									_applyCycle(copy.startAt, targets, i);
								}
							}
							if (cycle) {
								_applyCycle(copy, targets, i);
								if (copy.duration != null) {
									duration = copy.duration;
									delete copy.duration;
								}
							}
							tl.to(targets[i], duration, copy, i * stagger);
						}
						return this.add(tl, position);
					};
					p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						vars.immediateRender = vars.immediateRender != false;
						vars.runBackwards = true;
						return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						toVars.startAt = fromVars;
						toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
						return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					p.call = function (callback, params, scope, position) {
						return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
					};
					p.set = function (target, vars, position) {
						position = this._parseTimeOrLabel(position, 0, true);
						if (vars.immediateRender == null) {
							vars.immediateRender = position === this._time && !this._paused;
						}
						return this.add(new TweenLite(target, 0, vars), position);
					};
					TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
						vars = vars || {};
						if (vars.smoothChildTiming == null) {
							vars.smoothChildTiming = true;
						}
						var tl = new TimelineLite(vars),
							root = tl._timeline,
							hasNegativeStart, time, tween, next;
						if (ignoreDelayedCalls == null) {
							ignoreDelayedCalls = true;
						}
						root._remove(tl, true);
						tl._startTime = 0;
						tl._rawPrevTime = tl._time = tl._totalTime = root._time;
						tween = root._first;
						while (tween) {
							next = tween._next;
							if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
								time = tween._startTime - tween._delay;
								if (time < 0) {
									hasNegativeStart = 1;
								}
								tl.add(tween, time);
							}
							tween = next;
						}
						root.add(tl, 0);
						if (hasNegativeStart) {
							tl.totalDuration();
						}
						return tl;
					};
					p.add = function (value, position, align, stagger) {
						var curTime, l, i, child, tl, beforeRawTime;
						if (typeof position !== "number") {
							position = this._parseTimeOrLabel(position, 0, true, value);
						}
						if (!(value instanceof Animation)) {
							if (value instanceof Array || value && value.push && _isArray(value)) {
								align = align || "normal";
								stagger = stagger || 0;
								curTime = position;
								l = value.length;
								for (i = 0; i < l; i++) {
									if (_isArray(child = value[i])) {
										child = new TimelineLite({
											tweens: child
										});
									}
									this.add(child, curTime);
									if (typeof child !== "string" && typeof child !== "function") {
										if (align === "sequence") {
											curTime = child._startTime + child.totalDuration() / child._timeScale;
										} else if (align === "start") {
											child._startTime -= child.delay();
										}
									}
									curTime += stagger;
								}
								return this._uncache(true);
							} else if (typeof value === "string") {
								return this.addLabel(value, position);
							} else if (typeof value === "function") {
								value = TweenLite.delayedCall(0, value);
							} else {
								throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
							}
						}
						SimpleTimeline.prototype.add.call(this, value, position);
						if (value._time) {
							value.render((this.rawTime() - value._startTime) * value._timeScale, false, false);
						}
						if (this._gc || this._time === this._duration)
							if (!this._paused)
								if (this._duration < this.duration()) {
									tl = this;
									beforeRawTime = tl.rawTime() > value._startTime;
									while (tl._timeline) {
										if (beforeRawTime && tl._timeline.smoothChildTiming) {
											tl.totalTime(tl._totalTime, true);
										} else if (tl._gc) {
											tl._enabled(true, false);
										}
										tl = tl._timeline;
									}
								}
						return this;
					};
					p.remove = function (value) {
						if (value instanceof Animation) {
							this._remove(value, false);
							var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline;
							value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale;
							return this;
						} else if (value instanceof Array || value && value.push && _isArray(value)) {
							var i = value.length;
							while (--i > -1) {
								this.remove(value[i]);
							}
							return this;
						} else if (typeof value === "string") {
							return this.removeLabel(value);
						}
						return this.kill(null, value);
					};
					p._remove = function (tween, skipDisable) {
						SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
						var last = this._last;
						if (!last) {
							this._time = this._totalTime = this._duration = this._totalDuration = 0;
						} else if (this._time > this.duration()) {
							this._time = this._duration;
							this._totalTime = this._totalDuration;
						}
						return this;
					};
					p.append = function (value, offsetOrLabel) {
						return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
					};
					p.insert = p.insertMultiple = function (value, position, align, stagger) {
						return this.add(value, position || 0, align, stagger);
					};
					p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
						return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
					};
					p.addLabel = function (label, position) {
						this._labels[label] = this._parseTimeOrLabel(position);
						return this;
					};
					p.addPause = function (position, callback, params, scope) {
						var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
						t.vars.onComplete = t.vars.onReverseComplete = callback;
						t.data = "isPause";
						this._hasPause = true;
						return this.add(t, position);
					};
					p.removeLabel = function (label) {
						delete this._labels[label];
						return this;
					};
					p.getLabelTime = function (label) {
						return this._labels[label] != null ? this._labels[label] : -1;
					};
					p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
						var clippedDuration, i;
						if (ignore instanceof Animation && ignore.timeline === this) {
							this.remove(ignore);
						} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
							i = ignore.length;
							while (--i > -1) {
								if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
									this.remove(ignore[i]);
								}
							}
						}
						clippedDuration = typeof timeOrLabel === "number" && !offsetOrLabel ? 0 : this.duration() > 99999999999 ? this.recent().endTime(false) : this._duration;
						if (typeof offsetOrLabel === "string") {
							return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
						}
						offsetOrLabel = offsetOrLabel || 0;
						if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
							i = timeOrLabel.indexOf("=");
							if (i === -1) {
								if (this._labels[timeOrLabel] == null) {
									return appendIfAbsent ? this._labels[timeOrLabel] = clippedDuration + offsetOrLabel : offsetOrLabel;
								}
								return this._labels[timeOrLabel] + offsetOrLabel;
							}
							offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
							timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : clippedDuration;
						} else if (timeOrLabel == null) {
							timeOrLabel = clippedDuration;
						}
						return Number(timeOrLabel) + offsetOrLabel;
					};
					p.seek = function (position, suppressEvents) {
						return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
					};
					p.stop = function () {
						return this.paused(true);
					};
					p.gotoAndPlay = function (position, suppressEvents) {
						return this.play(position, suppressEvents);
					};
					p.gotoAndStop = function (position, suppressEvents) {
						return this.pause(position, suppressEvents);
					};
					p.render = function (time, suppressEvents, force) {
						if (this._gc) {
							this._enabled(true, false);
						}
						var prevTime = this._time,
							totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
							prevStart = this._startTime,
							prevTimeScale = this._timeScale,
							prevPaused = this._paused,
							tween, isComplete, next, callback, internalForce, pauseTween, curTime;
						if (prevTime !== this._time) {
							time += this._time - prevTime;
						}
						if (time >= totalDur - 0.0000001 && time >= 0) {
							this._totalTime = this._time = totalDur;
							if (!this._reversed)
								if (!this._hasPausedChild()) {
									isComplete = true;
									callback = "onComplete";
									internalForce = !!this._timeline.autoRemoveChildren;
									if (this._duration === 0)
										if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
											if (this._rawPrevTime !== time && this._first) {
												internalForce = true;
												if (this._rawPrevTime > _tinyNum) {
													callback = "onReverseComplete";
												}
											}
								}
							this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
							time = totalDur + 0.0001;
						} else if (time < 0.0000001) {
							this._totalTime = this._time = 0;
							if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
								callback = "onReverseComplete";
								isComplete = this._reversed;
							}
							if (time < 0) {
								this._active = false;
								if (this._timeline.autoRemoveChildren && this._reversed) {
									internalForce = isComplete = true;
									callback = "onReverseComplete";
								} else if (this._rawPrevTime >= 0 && this._first) {
									internalForce = true;
								}
								this._rawPrevTime = time;
							} else {
								this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
								if (time === 0 && isComplete) {
									tween = this._first;
									while (tween && tween._startTime === 0) {
										if (!tween._duration) {
											isComplete = false;
										}
										tween = tween._next;
									}
								}
								time = 0;
								if (!this._initted) {
									internalForce = true;
								}
							}
						} else {
							if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
								if (time >= prevTime) {
									tween = this._first;
									while (tween && tween._startTime <= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
												pauseTween = tween;
											}
										tween = tween._next;
									}
								} else {
									tween = this._last;
									while (tween && tween._startTime >= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && tween._rawPrevTime > 0) {
												pauseTween = tween;
											}
										tween = tween._prev;
									}
								}
								if (pauseTween) {
									this._time = time = pauseTween._startTime;
									this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
								}
							}
							this._totalTime = this._time = this._rawPrevTime = time;
						}
						if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
							return;
						} else if (!this._initted) {
							this._initted = true;
						}
						if (!this._active)
							if (!this._paused && this._time !== prevTime && time > 0) {
								this._active = true;
							}
						if (prevTime === 0)
							if (this.vars.onStart)
								if (this._time !== 0 || !this._duration)
									if (!suppressEvents) {
										this._callback("onStart");
									}
						curTime = this._time;
						if (curTime >= prevTime) {
							tween = this._first;
							while (tween) {
								next = tween._next;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						} else {
							tween = this._last;
							while (tween) {
								next = tween._prev;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										pauseTween = tween._prev;
										while (pauseTween && pauseTween.endTime() > this._time) {
											pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
											pauseTween = pauseTween._prev;
										}
										pauseTween = null;
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						}
						if (this._onUpdate)
							if (!suppressEvents) {
								if (_lazyTweens.length) {
									_lazyRender();
								}
								this._callback("onUpdate");
							}
						if (callback)
							if (!this._gc)
								if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
									if (this._time === 0 || totalDur >= this.totalDuration()) {
										if (isComplete) {
											if (_lazyTweens.length) {
												_lazyRender();
											}
											if (this._timeline.autoRemoveChildren) {
												this._enabled(false, false);
											}
											this._active = false;
										}
										if (!suppressEvents && this.vars[callback]) {
											this._callback(callback);
										}
									}
					};
					p._hasPausedChild = function () {
						var tween = this._first;
						while (tween) {
							if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
								return true;
							}
							tween = tween._next;
						}
						return false;
					};
					p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
						ignoreBeforeTime = ignoreBeforeTime || -9999999999;
						var a = [],
							tween = this._first,
							cnt = 0;
						while (tween) {
							if (tween._startTime < ignoreBeforeTime) { } else if (tween instanceof TweenLite) {
								if (tweens !== false) {
									a[cnt++] = tween;
								}
							} else {
								if (timelines !== false) {
									a[cnt++] = tween;
								}
								if (nested !== false) {
									a = a.concat(tween.getChildren(true, tweens, timelines));
									cnt = a.length;
								}
							}
							tween = tween._next;
						}
						return a;
					};
					p.getTweensOf = function (target, nested) {
						var disabled = this._gc,
							a = [],
							cnt = 0,
							tweens, i;
						if (disabled) {
							this._enabled(true, true);
						}
						tweens = TweenLite.getTweensOf(target);
						i = tweens.length;
						while (--i > -1) {
							if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
								a[cnt++] = tweens[i];
							}
						}
						if (disabled) {
							this._enabled(false, true);
						}
						return a;
					};
					p.recent = function () {
						return this._recent;
					};
					p._contains = function (tween) {
						var tl = tween.timeline;
						while (tl) {
							if (tl === this) {
								return true;
							}
							tl = tl.timeline;
						}
						return false;
					};
					p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
						ignoreBeforeTime = ignoreBeforeTime || 0;
						var tween = this._first,
							labels = this._labels,
							p;
						while (tween) {
							if (tween._startTime >= ignoreBeforeTime) {
								tween._startTime += amount;
							}
							tween = tween._next;
						}
						if (adjustLabels) {
							for (p in labels) {
								if (labels[p] >= ignoreBeforeTime) {
									labels[p] += amount;
								}
							}
						}
						return this._uncache(true);
					};
					p._kill = function (vars, target) {
						if (!vars && !target) {
							return this._enabled(false, false);
						}
						var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
							i = tweens.length,
							changed = false;
						while (--i > -1) {
							if (tweens[i]._kill(vars, target)) {
								changed = true;
							}
						}
						return changed;
					};
					p.clear = function (labels) {
						var tweens = this.getChildren(false, true, true),
							i = tweens.length;
						this._time = this._totalTime = 0;
						while (--i > -1) {
							tweens[i]._enabled(false, false);
						}
						if (labels !== false) {
							this._labels = {};
						}
						return this._uncache(true);
					};
					p.invalidate = function () {
						var tween = this._first;
						while (tween) {
							tween.invalidate();
							tween = tween._next;
						}
						return Animation.prototype.invalidate.call(this);;
					};
					p._enabled = function (enabled, ignoreTimeline) {
						if (enabled === this._gc) {
							var tween = this._first;
							while (tween) {
								tween._enabled(enabled, true);
								tween = tween._next;
							}
						}
						return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
					};
					p.totalTime = function (time, suppressEvents, uncapped) {
						this._forcingPlayhead = true;
						var val = Animation.prototype.totalTime.apply(this, arguments);
						this._forcingPlayhead = false;
						return val;
					};
					p.duration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								this.totalDuration();
							}
							return this._duration;
						}
						if (this.duration() !== 0 && value !== 0) {
							this.timeScale(this._duration / value);
						}
						return this;
					};
					p.totalDuration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								var max = 0,
									tween = this._last,
									prevStart = 999999999999,
									prev, end;
								while (tween) {
									prev = tween._prev;
									if (tween._dirty) {
										tween.totalDuration();
									}
									if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) {
										this._calculatingDuration = 1;
										this.add(tween, tween._startTime - tween._delay);
										this._calculatingDuration = 0;
									} else {
										prevStart = tween._startTime;
									}
									if (tween._startTime < 0 && !tween._paused) {
										max -= tween._startTime;
										if (this._timeline.smoothChildTiming) {
											this._startTime += tween._startTime / this._timeScale;
											this._time -= tween._startTime;
											this._totalTime -= tween._startTime;
											this._rawPrevTime -= tween._startTime;
										}
										this.shiftChildren(-tween._startTime, false, -9999999999);
										prevStart = 0;
									}
									end = tween._startTime + tween._totalDuration / tween._timeScale;
									if (end > max) {
										max = end;
									}
									tween = prev;
								}
								this._duration = this._totalDuration = max;
								this._dirty = false;
							}
							return this._totalDuration;
						}
						return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
					};
					p.paused = function (value) {
						if (!value) {
							var tween = this._first,
								time = this._time;
							while (tween) {
								if (tween._startTime === time && tween.data === "isPause") {
									tween._rawPrevTime = 0;
								}
								tween = tween._next;
							}
						}
						return Animation.prototype.paused.apply(this, arguments);
					};
					p.usesFrames = function () {
						var tl = this._timeline;
						while (tl._timeline) {
							tl = tl._timeline;
						}
						return tl === Animation._rootFramesTimeline;
					};
					p.rawTime = function (wrapRepeats) {
						return wrapRepeats && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
					};
					return TimelineLite;
				}, true);
				_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {
					var TimelineMax = function TimelineMax(vars) {
						TimelineLite.call(this, vars);
						this._repeat = this.vars.repeat || 0;
						this._repeatDelay = this.vars.repeatDelay || 0;
						this._cycle = 0;
						this._yoyo = this.vars.yoyo === true;
						this._dirty = true;
					},
						_tinyNum = 0.0000000001,
						TweenLiteInternals = TweenLite._internals,
						_lazyTweens = TweenLiteInternals.lazyTweens,
						_lazyRender = TweenLiteInternals.lazyRender,
						_globals = _gsScope._gsDefine.globals,
						_easeNone = new Ease(null, null, 1, 0),
						p = TimelineMax.prototype = new TimelineLite();
					p.constructor = TimelineMax;
					p.kill()._gc = false;
					TimelineMax.version = "2.0.1";
					p.invalidate = function () {
						this._yoyo = this.vars.yoyo === true;
						this._repeat = this.vars.repeat || 0;
						this._repeatDelay = this.vars.repeatDelay || 0;
						this._uncache(true);
						return TimelineLite.prototype.invalidate.call(this);
					};
					p.addCallback = function (callback, position, params, scope) {
						return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
					};
					p.removeCallback = function (callback, position) {
						if (callback) {
							if (position == null) {
								this._kill(null, callback);
							} else {
								var a = this.getTweensOf(callback, false),
									i = a.length,
									time = this._parseTimeOrLabel(position);
								while (--i > -1) {
									if (a[i]._startTime === time) {
										a[i]._enabled(false, false);
									}
								}
							}
						}
						return this;
					};
					p.removePause = function (position) {
						return this.removeCallback(TimelineLite._internals.pauseCallback, position);
					};
					p.tweenTo = function (position, vars) {
						vars = vars || {};
						var copy = {
							ease: _easeNone,
							useFrames: this.usesFrames(),
							immediateRender: false,
							lazy: false
						},
							Engine = vars.repeat && _globals.TweenMax || TweenLite,
							duration, p, t;
						for (p in vars) {
							copy[p] = vars[p];
						}
						copy.time = this._parseTimeOrLabel(position);
						duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
						t = new Engine(this, duration, copy);
						copy.onStart = function () {
							t.target.paused(true);
							if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) {
								t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale).render(t.time(), true, true);
							}
							if (vars.onStart) {
								vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []);
							}
						};
						return t;
					};
					p.tweenFromTo = function (fromPosition, toPosition, vars) {
						vars = vars || {};
						fromPosition = this._parseTimeOrLabel(fromPosition);
						vars.startAt = {
							onComplete: this.seek,
							onCompleteParams: [fromPosition],
							callbackScope: this
						};
						vars.immediateRender = vars.immediateRender !== false;
						var t = this.tweenTo(toPosition, vars);
						t.isFromTo = 1;
						return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
					};
					p.render = function (time, suppressEvents, force) {
						if (this._gc) {
							this._enabled(true, false);
						}
						var prevTime = this._time,
							totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
							dur = this._duration,
							prevTotalTime = this._totalTime,
							prevStart = this._startTime,
							prevTimeScale = this._timeScale,
							prevRawPrevTime = this._rawPrevTime,
							prevPaused = this._paused,
							prevCycle = this._cycle,
							tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
						if (prevTime !== this._time) {
							time += this._time - prevTime;
						}
						if (time >= totalDur - 0.0000001 && time >= 0) {
							if (!this._locked) {
								this._totalTime = totalDur;
								this._cycle = this._repeat;
							}
							if (!this._reversed)
								if (!this._hasPausedChild()) {
									isComplete = true;
									callback = "onComplete";
									internalForce = !!this._timeline.autoRemoveChildren;
									if (this._duration === 0)
										if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
											if (prevRawPrevTime !== time && this._first) {
												internalForce = true;
												if (prevRawPrevTime > _tinyNum) {
													callback = "onReverseComplete";
												}
											}
								}
							this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
							if (this._yoyo && (this._cycle & 1) !== 0) {
								this._time = time = 0;
							} else {
								this._time = dur;
								time = dur + 0.0001;
							}
						} else if (time < 0.0000001) {
							if (!this._locked) {
								this._totalTime = this._cycle = 0;
							}
							this._time = 0;
							if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
								callback = "onReverseComplete";
								isComplete = this._reversed;
							}
							if (time < 0) {
								this._active = false;
								if (this._timeline.autoRemoveChildren && this._reversed) {
									internalForce = isComplete = true;
									callback = "onReverseComplete";
								} else if (prevRawPrevTime >= 0 && this._first) {
									internalForce = true;
								}
								this._rawPrevTime = time;
							} else {
								this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
								if (time === 0 && isComplete) {
									tween = this._first;
									while (tween && tween._startTime === 0) {
										if (!tween._duration) {
											isComplete = false;
										}
										tween = tween._next;
									}
								}
								time = 0;
								if (!this._initted) {
									internalForce = true;
								}
							}
						} else {
							if (dur === 0 && prevRawPrevTime < 0) {
								internalForce = true;
							}
							this._time = this._rawPrevTime = time;
							if (!this._locked) {
								this._totalTime = time;
								if (this._repeat !== 0) {
									cycleDuration = dur + this._repeatDelay;
									this._cycle = this._totalTime / cycleDuration >> 0;
									if (this._cycle !== 0)
										if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
											this._cycle--;
										}
									this._time = this._totalTime - this._cycle * cycleDuration;
									if (this._yoyo)
										if ((this._cycle & 1) !== 0) {
											this._time = dur - this._time;
										}
									if (this._time > dur) {
										this._time = dur;
										time = dur + 0.0001;
									} else if (this._time < 0) {
										this._time = time = 0;
									} else {
										time = this._time;
									}
								}
							}
							if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
								time = this._time;
								if (time >= prevTime || this._repeat && prevCycle !== this._cycle) {
									tween = this._first;
									while (tween && tween._startTime <= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
												pauseTween = tween;
											}
										tween = tween._next;
									}
								} else {
									tween = this._last;
									while (tween && tween._startTime >= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && tween._rawPrevTime > 0) {
												pauseTween = tween;
											}
										tween = tween._prev;
									}
								}
								if (pauseTween && pauseTween._startTime < dur) {
									this._time = time = pauseTween._startTime;
									this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
								}
							}
						}
						if (this._cycle !== prevCycle)
							if (!this._locked) {
								var backwards = this._yoyo && (prevCycle & 1) !== 0,
									wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
									recTotalTime = this._totalTime,
									recCycle = this._cycle,
									recRawPrevTime = this._rawPrevTime,
									recTime = this._time;
								this._totalTime = prevCycle * dur;
								if (this._cycle < prevCycle) {
									backwards = !backwards;
								} else {
									this._totalTime += dur;
								}
								this._time = prevTime;
								this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
								this._cycle = prevCycle;
								this._locked = true;
								prevTime = backwards ? 0 : dur;
								this.render(prevTime, suppressEvents, dur === 0);
								if (!suppressEvents)
									if (!this._gc) {
										if (this.vars.onRepeat) {
											this._cycle = recCycle;
											this._locked = false;
											this._callback("onRepeat");
										}
									}
								if (prevTime !== this._time) {
									return;
								}
								if (wrap) {
									this._cycle = prevCycle;
									this._locked = true;
									prevTime = backwards ? dur + 0.0001 : -0.0001;
									this.render(prevTime, true, false);
								}
								this._locked = false;
								if (this._paused && !prevPaused) {
									return;
								}
								this._time = recTime;
								this._totalTime = recTotalTime;
								this._cycle = recCycle;
								this._rawPrevTime = recRawPrevTime;
							}
						if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
							if (prevTotalTime !== this._totalTime)
								if (this._onUpdate)
									if (!suppressEvents) {
										this._callback("onUpdate");
									}
							return;
						} else if (!this._initted) {
							this._initted = true;
						}
						if (!this._active)
							if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
								this._active = true;
							}
						if (prevTotalTime === 0)
							if (this.vars.onStart)
								if (this._totalTime !== 0 || !this._totalDuration)
									if (!suppressEvents) {
										this._callback("onStart");
									}
						curTime = this._time;
						if (curTime >= prevTime) {
							tween = this._first;
							while (tween) {
								next = tween._next;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						} else {
							tween = this._last;
							while (tween) {
								next = tween._prev;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										pauseTween = tween._prev;
										while (pauseTween && pauseTween.endTime() > this._time) {
											pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
											pauseTween = pauseTween._prev;
										}
										pauseTween = null;
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						}
						if (this._onUpdate)
							if (!suppressEvents) {
								if (_lazyTweens.length) {
									_lazyRender();
								}
								this._callback("onUpdate");
							}
						if (callback)
							if (!this._locked)
								if (!this._gc)
									if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
										if (this._time === 0 || totalDur >= this.totalDuration()) {
											if (isComplete) {
												if (_lazyTweens.length) {
													_lazyRender();
												}
												if (this._timeline.autoRemoveChildren) {
													this._enabled(false, false);
												}
												this._active = false;
											}
											if (!suppressEvents && this.vars[callback]) {
												this._callback(callback);
											}
										}
					};
					p.getActive = function (nested, tweens, timelines) {
						if (nested == null) {
							nested = true;
						}
						if (tweens == null) {
							tweens = true;
						}
						if (timelines == null) {
							timelines = false;
						}
						var a = [],
							all = this.getChildren(nested, tweens, timelines),
							cnt = 0,
							l = all.length,
							i, tween;
						for (i = 0; i < l; i++) {
							tween = all[i];
							if (tween.isActive()) {
								a[cnt++] = tween;
							}
						}
						return a;
					};
					p.getLabelAfter = function (time) {
						if (!time)
							if (time !== 0) {
								time = this._time;
							}
						var labels = this.getLabelsArray(),
							l = labels.length,
							i;
						for (i = 0; i < l; i++) {
							if (labels[i].time > time) {
								return labels[i].name;
							}
						}
						return null;
					};
					p.getLabelBefore = function (time) {
						if (time == null) {
							time = this._time;
						}
						var labels = this.getLabelsArray(),
							i = labels.length;
						while (--i > -1) {
							if (labels[i].time < time) {
								return labels[i].name;
							}
						}
						return null;
					};
					p.getLabelsArray = function () {
						var a = [],
							cnt = 0,
							p;
						for (p in this._labels) {
							a[cnt++] = {
								time: this._labels[p],
								name: p
							};
						}
						a.sort(function (a, b) {
							return a.time - b.time;
						});
						return a;
					};
					p.invalidate = function () {
						this._locked = false;
						return TimelineLite.prototype.invalidate.call(this);
					};
					p.progress = function (value, suppressEvents) {
						return !arguments.length ? this._time / this.duration() || 0 : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
					};
					p.totalProgress = function (value, suppressEvents) {
						return !arguments.length ? this._totalTime / this.totalDuration() || 0 : this.totalTime(this.totalDuration() * value, suppressEvents);
					};
					p.totalDuration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								TimelineLite.prototype.totalDuration.call(this);
								this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
							}
							return this._totalDuration;
						}
						return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
					};
					p.time = function (value, suppressEvents) {
						if (!arguments.length) {
							return this._time;
						}
						if (this._dirty) {
							this.totalDuration();
						}
						if (value > this._duration) {
							value = this._duration;
						}
						if (this._yoyo && (this._cycle & 1) !== 0) {
							value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
						} else if (this._repeat !== 0) {
							value += this._cycle * (this._duration + this._repeatDelay);
						}
						return this.totalTime(value, suppressEvents);
					};
					p.repeat = function (value) {
						if (!arguments.length) {
							return this._repeat;
						}
						this._repeat = value;
						return this._uncache(true);
					};
					p.repeatDelay = function (value) {
						if (!arguments.length) {
							return this._repeatDelay;
						}
						this._repeatDelay = value;
						return this._uncache(true);
					};
					p.yoyo = function (value) {
						if (!arguments.length) {
							return this._yoyo;
						}
						this._yoyo = value;
						return this;
					};
					p.currentLabel = function (value) {
						if (!arguments.length) {
							return this.getLabelBefore(this._time + 0.00000001);
						}
						return this.seek(value, true);
					};
					return TimelineMax;
				}, true);
				(function () {
					var _RAD2DEG = 180 / Math.PI,
						_r1 = [],
						_r2 = [],
						_r3 = [],
						_corProps = {},
						_globals = _gsScope._gsDefine.globals,
						Segment = function Segment(a, b, c, d) {
							if (c === d) {
								c = d - (d - b) / 1000000;
							}
							if (a === b) {
								b = a + (c - a) / 1000000;
							}
							this.a = a;
							this.b = b;
							this.c = c;
							this.d = d;
							this.da = d - a;
							this.ca = c - a;
							this.ba = b - a;
						},
						_correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
						cubicToQuadratic = function cubicToQuadratic(a, b, c, d) {
							var q1 = {
								a: a
							},
								q2 = {},
								q3 = {},
								q4 = {
									c: d
								},
								mab = (a + b) / 2,
								mbc = (b + c) / 2,
								mcd = (c + d) / 2,
								mabc = (mab + mbc) / 2,
								mbcd = (mbc + mcd) / 2,
								m8 = (mbcd - mabc) / 8;
							q1.b = mab + (a - mab) / 4;
							q2.b = mabc + m8;
							q1.c = q2.a = (q1.b + q2.b) / 2;
							q2.c = q3.a = (mabc + mbcd) / 2;
							q3.b = mbcd - m8;
							q4.b = mcd + (d - mcd) / 4;
							q3.c = q4.a = (q3.b + q4.b) / 2;
							return [q1, q2, q3, q4];
						},
						_calculateControlPoints = function _calculateControlPoints(a, curviness, quad, basic, correlate) {
							var l = a.length - 1,
								ii = 0,
								cp1 = a[0].a,
								i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl;
							for (i = 0; i < l; i++) {
								seg = a[ii];
								p1 = seg.a;
								p2 = seg.d;
								p3 = a[ii + 1].d;
								if (correlate) {
									r1 = _r1[i];
									r2 = _r2[i];
									tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
									m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
									m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
									mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
								} else {
									m1 = p2 - (p2 - p1) * curviness * 0.5;
									m2 = p2 + (p3 - p2) * curviness * 0.5;
									mm = p2 - (m1 + m2) / 2;
								}
								m1 += mm;
								m2 += mm;
								seg.c = cp2 = m1;
								if (i !== 0) {
									seg.b = cp1;
								} else {
									seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6;
								}
								seg.da = p2 - p1;
								seg.ca = cp2 - p1;
								seg.ba = cp1 - p1;
								if (quad) {
									qb = cubicToQuadratic(p1, cp1, cp2, p2);
									a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
									ii += 4;
								} else {
									ii++;
								}
								cp1 = m2;
							}
							seg = a[ii];
							seg.b = cp1;
							seg.c = cp1 + (seg.d - cp1) * 0.4;
							seg.da = seg.d - seg.a;
							seg.ca = seg.c - seg.a;
							seg.ba = cp1 - seg.a;
							if (quad) {
								qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
								a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
							}
						},
						_parseAnchors = function _parseAnchors(values, p, correlate, prepend) {
							var a = [],
								l, i, p1, p2, p3, tmp;
							if (prepend) {
								values = [prepend].concat(values);
								i = values.length;
								while (--i > -1) {
									if (typeof (tmp = values[i][p]) === "string")
										if (tmp.charAt(1) === "=") {
											values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2));
										}
								}
							}
							l = values.length - 2;
							if (l < 0) {
								a[0] = new Segment(values[0][p], 0, 0, values[0][p]);
								return a;
							}
							for (i = 0; i < l; i++) {
								p1 = values[i][p];
								p2 = values[i + 1][p];
								a[i] = new Segment(p1, 0, 0, p2);
								if (correlate) {
									p3 = values[i + 2][p];
									_r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
									_r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
								}
							}
							a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
							return a;
						},
						bezierThrough = function bezierThrough(values, curviness, quadratic, basic, correlate, prepend) {
							var obj = {},
								props = [],
								first = prepend || values[0],
								i, p, a, j, r, l, seamless, last;
							correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
							if (curviness == null) {
								curviness = 1;
							}
							for (p in values[0]) {
								props.push(p);
							}
							if (values.length > 1) {
								last = values[values.length - 1];
								seamless = true;
								i = props.length;
								while (--i > -1) {
									p = props[i];
									if (Math.abs(first[p] - last[p]) > 0.05) {
										seamless = false;
										break;
									}
								}
								if (seamless) {
									values = values.concat();
									if (prepend) {
										values.unshift(prepend);
									}
									values.push(values[1]);
									prepend = values[values.length - 3];
								}
							}
							_r1.length = _r2.length = _r3.length = 0;
							i = props.length;
							while (--i > -1) {
								p = props[i];
								_corProps[p] = correlate.indexOf("," + p + ",") !== -1;
								obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
							}
							i = _r1.length;
							while (--i > -1) {
								_r1[i] = Math.sqrt(_r1[i]);
								_r2[i] = Math.sqrt(_r2[i]);
							}
							if (!basic) {
								i = props.length;
								while (--i > -1) {
									if (_corProps[p]) {
										a = obj[props[i]];
										l = a.length - 1;
										for (j = 0; j < l; j++) {
											r = a[j + 1].da / _r2[j] + a[j].da / _r1[j] || 0;
											_r3[j] = (_r3[j] || 0) + r * r;
										}
									}
								}
								i = _r3.length;
								while (--i > -1) {
									_r3[i] = Math.sqrt(_r3[i]);
								}
							}
							i = props.length;
							j = quadratic ? 4 : 1;
							while (--i > -1) {
								p = props[i];
								a = obj[p];
								_calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]);
								if (seamless) {
									a.splice(0, j);
									a.splice(a.length - j, j);
								}
							}
							return obj;
						},
						_parseBezierData = function _parseBezierData(values, type, prepend) {
							type = type || "soft";
							var obj = {},
								inc = type === "cubic" ? 3 : 2,
								soft = type === "soft",
								props = [],
								a, b, c, d, cur, i, j, l, p, cnt, tmp;
							if (soft && prepend) {
								values = [prepend].concat(values);
							}
							if (values == null || values.length < inc + 1) {
								throw "invalid Bezier data";
							}
							for (p in values[0]) {
								props.push(p);
							}
							i = props.length;
							while (--i > -1) {
								p = props[i];
								obj[p] = cur = [];
								cnt = 0;
								l = values.length;
								for (j = 0; j < l; j++) {
									a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
									if (soft)
										if (j > 1)
											if (j < l - 1) {
												cur[cnt++] = (a + cur[cnt - 2]) / 2;
											}
									cur[cnt++] = a;
								}
								l = cnt - inc + 1;
								cnt = 0;
								for (j = 0; j < l; j += inc) {
									a = cur[j];
									b = cur[j + 1];
									c = cur[j + 2];
									d = inc === 2 ? 0 : cur[j + 3];
									cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
								}
								cur.length = cnt;
							}
							return obj;
						},
						_addCubicLengths = function _addCubicLengths(a, steps, resolution) {
							var inc = 1 / resolution,
								j = a.length,
								d, d1, s, da, ca, ba, p, i, inv, bez, index;
							while (--j > -1) {
								bez = a[j];
								s = bez.a;
								da = bez.d - s;
								ca = bez.c - s;
								ba = bez.b - s;
								d = d1 = 0;
								for (i = 1; i <= resolution; i++) {
									p = inc * i;
									inv = 1 - p;
									d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
									index = j * resolution + i - 1;
									steps[index] = (steps[index] || 0) + d * d;
								}
							}
						},
						_parseLengthData = function _parseLengthData(obj, resolution) {
							resolution = resolution >> 0 || 6;
							var a = [],
								lengths = [],
								d = 0,
								total = 0,
								threshold = resolution - 1,
								segments = [],
								curLS = [],
								p, i, l, index;
							for (p in obj) {
								_addCubicLengths(obj[p], a, resolution);
							}
							l = a.length;
							for (i = 0; i < l; i++) {
								d += Math.sqrt(a[i]);
								index = i % resolution;
								curLS[index] = d;
								if (index === threshold) {
									total += d;
									index = i / resolution >> 0;
									segments[index] = curLS;
									lengths[index] = total;
									d = 0;
									curLS = [];
								}
							}
							return {
								length: total,
								lengths: lengths,
								segments: segments
							};
						},
						BezierPlugin = _gsScope._gsDefine.plugin({
							propName: "bezier",
							priority: -1,
							version: "1.3.8",
							API: 2,
							global: true,
							init: function init(target, vars, tween) {
								this._target = target;
								if (vars instanceof Array) {
									vars = {
										values: vars
									};
								}
								this._func = {};
								this._mod = {};
								this._props = [];
								this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
								var values = vars.values || [],
									first = {},
									second = values[0],
									autoRotate = vars.autoRotate || tween.vars.orientToBezier,
									p, isFunc, i, j, prepend;
								this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [
									["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]
								] : null;
								for (p in second) {
									this._props.push(p);
								}
								i = this._props.length;
								while (--i > -1) {
									p = this._props[i];
									this._overwriteProps.push(p);
									isFunc = this._func[p] = typeof target[p] === "function";
									first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
									if (!prepend)
										if (first[p] !== values[0][p]) {
											prepend = first;
										}
								}
								this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
								this._segCount = this._beziers[p].length;
								if (this._timeRes) {
									var ld = _parseLengthData(this._beziers, this._timeRes);
									this._length = ld.length;
									this._lengths = ld.lengths;
									this._segments = ld.segments;
									this._l1 = this._li = this._s1 = this._si = 0;
									this._l2 = this._lengths[0];
									this._curSeg = this._segments[0];
									this._s2 = this._curSeg[0];
									this._prec = 1 / this._curSeg.length;
								}
								if (autoRotate = this._autoRotate) {
									this._initialRotations = [];
									if (!(autoRotate[0] instanceof Array)) {
										this._autoRotate = autoRotate = [autoRotate];
									}
									i = autoRotate.length;
									while (--i > -1) {
										for (j = 0; j < 3; j++) {
											p = autoRotate[i][j];
											this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
										}
										p = autoRotate[i][2];
										this._initialRotations[i] = (this._func[p] ? this._func[p].call(this._target) : this._target[p]) || 0;
										this._overwriteProps.push(p);
									}
								}
								this._startRatio = tween.vars.runBackwards ? 1 : 0;
								return true;
							},
							set: function set(v) {
								var segments = this._segCount,
									func = this._func,
									target = this._target,
									notStart = v !== this._startRatio,
									curIndex, inv, i, p, b, t, val, l, lengths, curSeg;
								if (!this._timeRes) {
									curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
									t = (v - curIndex * (1 / segments)) * segments;
								} else {
									lengths = this._lengths;
									curSeg = this._curSeg;
									v *= this._length;
									i = this._li;
									if (v > this._l2 && i < segments - 1) {
										l = segments - 1;
										while (i < l && (this._l2 = lengths[++i]) <= v) { }
										this._l1 = lengths[i - 1];
										this._li = i;
										this._curSeg = curSeg = this._segments[i];
										this._s2 = curSeg[this._s1 = this._si = 0];
									} else if (v < this._l1 && i > 0) {
										while (i > 0 && (this._l1 = lengths[--i]) >= v) { }
										if (i === 0 && v < this._l1) {
											this._l1 = 0;
										} else {
											i++;
										}
										this._l2 = lengths[i];
										this._li = i;
										this._curSeg = curSeg = this._segments[i];
										this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
										this._s2 = curSeg[this._si];
									}
									curIndex = i;
									v -= this._l1;
									i = this._si;
									if (v > this._s2 && i < curSeg.length - 1) {
										l = curSeg.length - 1;
										while (i < l && (this._s2 = curSeg[++i]) <= v) { }
										this._s1 = curSeg[i - 1];
										this._si = i;
									} else if (v < this._s1 && i > 0) {
										while (i > 0 && (this._s1 = curSeg[--i]) >= v) { }
										if (i === 0 && v < this._s1) {
											this._s1 = 0;
										} else {
											i++;
										}
										this._s2 = curSeg[i];
										this._si = i;
									}
									t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec || 0;
								}
								inv = 1 - t;
								i = this._props.length;
								while (--i > -1) {
									p = this._props[i];
									b = this._beziers[p][curIndex];
									val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
									if (this._mod[p]) {
										val = this._mod[p](val, target);
									}
									if (func[p]) {
										target[p](val);
									} else {
										target[p] = val;
									}
								}
								if (this._autoRotate) {
									var ar = this._autoRotate,
										b2, x1, y1, x2, y2, add, conv;
									i = ar.length;
									while (--i > -1) {
										p = ar[i][2];
										add = ar[i][3] || 0;
										conv = ar[i][4] === true ? 1 : _RAD2DEG;
										b = this._beziers[ar[i][0]];
										b2 = this._beziers[ar[i][1]];
										if (b && b2) {
											b = b[curIndex];
											b2 = b2[curIndex];
											x1 = b.a + (b.b - b.a) * t;
											x2 = b.b + (b.c - b.b) * t;
											x1 += (x2 - x1) * t;
											x2 += (b.c + (b.d - b.c) * t - x2) * t;
											y1 = b2.a + (b2.b - b2.a) * t;
											y2 = b2.b + (b2.c - b2.b) * t;
											y1 += (y2 - y1) * t;
											y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;
											val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i];
											if (this._mod[p]) {
												val = this._mod[p](val, target);
											}
											if (func[p]) {
												target[p](val);
											} else {
												target[p] = val;
											}
										}
									}
								}
							}
						}),
						p = BezierPlugin.prototype;
					BezierPlugin.bezierThrough = bezierThrough;
					BezierPlugin.cubicToQuadratic = cubicToQuadratic;
					BezierPlugin._autoCSS = true;
					BezierPlugin.quadraticToCubic = function (a, b, c) {
						return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
					};
					BezierPlugin._cssRegister = function () {
						var CSSPlugin = _globals.CSSPlugin;
						if (!CSSPlugin) {
							return;
						}
						var _internals = CSSPlugin._internals,
							_parseToProxy = _internals._parseToProxy,
							_setPluginRatio = _internals._setPluginRatio,
							CSSPropTween = _internals.CSSPropTween;
						_internals._registerComplexSpecialProp("bezier", {
							parser: function parser(t, e, prop, cssp, pt, plugin) {
								if (e instanceof Array) {
									e = {
										values: e
									};
								}
								plugin = new BezierPlugin();
								var values = e.values,
									l = values.length - 1,
									pluginValues = [],
									v = {},
									i, p, data;
								if (l < 0) {
									return pt;
								}
								for (i = 0; i <= l; i++) {
									data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
									pluginValues[i] = data.end;
								}
								for (p in e) {
									v[p] = e[p];
								}
								v.values = pluginValues;
								pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
								pt.data = data;
								pt.plugin = plugin;
								pt.setRatio = _setPluginRatio;
								if (v.autoRotate === 0) {
									v.autoRotate = true;
								}
								if (v.autoRotate && !(v.autoRotate instanceof Array)) {
									i = v.autoRotate === true ? 0 : Number(v.autoRotate);
									v.autoRotate = data.end.left != null ? [
										["left", "top", "rotation", i, false]
									] : data.end.x != null ? [
										["x", "y", "rotation", i, false]
									] : false;
								}
								if (v.autoRotate) {
									if (!cssp._transform) {
										cssp._enableTransforms(false);
									}
									data.autoRotate = cssp._target._gsTransform;
									data.proxy.rotation = data.autoRotate.rotation || 0;
									cssp._overwriteProps.push("rotation");
								}
								plugin._onInitTween(data.proxy, v, cssp._tween);
								return pt;
							}
						});
					};
					p._mod = function (lookup) {
						var op = this._overwriteProps,
							i = op.length,
							val;
						while (--i > -1) {
							val = lookup[op[i]];
							if (val && typeof val === "function") {
								this._mod[op[i]] = val;
							}
						}
					};
					p._kill = function (lookup) {
						var a = this._props,
							p, i;
						for (p in this._beziers) {
							if (p in lookup) {
								delete this._beziers[p];
								delete this._func[p];
								i = a.length;
								while (--i > -1) {
									if (a[i] === p) {
										a.splice(i, 1);
									}
								}
							}
						}
						a = this._autoRotate;
						if (a) {
							i = a.length;
							while (--i > -1) {
								if (lookup[a[i][2]]) {
									a.splice(i, 1);
								}
							}
						}
						return this._super._kill.call(this, lookup);
					};
				})();
				_gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {
					var CSSPlugin = function CSSPlugin() {
						TweenPlugin.call(this, "css");
						this._overwriteProps.length = 0;
						this.setRatio = CSSPlugin.prototype.setRatio;
					},
						_globals = _gsScope._gsDefine.globals,
						_hasPriority, _suffixMap, _cs, _overwriteProps, _specialProps = {},
						p = CSSPlugin.prototype = new TweenPlugin("css");
					p.constructor = CSSPlugin;
					CSSPlugin.version = "1.20.5";
					CSSPlugin.API = 2;
					CSSPlugin.defaultTransformPerspective = 0;
					CSSPlugin.defaultSkewType = "compensated";
					CSSPlugin.defaultSmoothOrigin = true;
					p = "px";
					CSSPlugin.suffixMap = {
						top: p,
						right: p,
						bottom: p,
						left: p,
						width: p,
						height: p,
						fontSize: p,
						padding: p,
						margin: p,
						perspective: p,
						lineHeight: ""
					};
					var _numExp = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
						_relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
						_valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
						_NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
						_suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
						_opacityExp = /opacity *= *([^)]*)/i,
						_opacityValExp = /opacity:([^;]*)/i,
						_alphaFilterExp = /alpha\(opacity *=.+?\)/i,
						_rgbhslExp = /^(rgb|hsl)/,
						_capsExp = /([A-Z])/g,
						_camelExp = /-([a-z])/gi,
						_urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
						_camelFunc = function _camelFunc(s, g) {
							return g.toUpperCase();
						},
						_horizExp = /(?:Left|Right|Width)/i,
						_ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
						_ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
						_commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
						_complexExp = /[\s,\(]/i,
						_DEG2RAD = Math.PI / 180,
						_RAD2DEG = 180 / Math.PI,
						_forcePT = {},
						_dummyElement = {
							style: {}
						},
						_doc = _gsScope.document || {
							createElement: function createElement() {
								return _dummyElement;
							}
						},
						_createElement = function _createElement(type, ns) {
							return _doc.createElementNS ? _doc.createElementNS(ns || "http://www.w3.org/1999/xhtml", type) : _doc.createElement(type);
						},
						_tempDiv = _createElement("div"),
						_tempImg = _createElement("img"),
						_internals = CSSPlugin._internals = {
							_specialProps: _specialProps
						},
						_agent = (_gsScope.navigator || {}).userAgent || "",
						_autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _supportsOpacity = function () {
							var i = _agent.indexOf("Android"),
								a = _createElement("a");
							_isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || parseFloat(_agent.substr(i + 8, 2)) > 3);
							_isSafariLT6 = _isSafari && parseFloat(_agent.substr(_agent.indexOf("Version/") + 8, 2)) < 6;
							_isFirefox = _agent.indexOf("Firefox") !== -1;
							if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
								_ieVers = parseFloat(RegExp.$1);
							}
							if (!a) {
								return false;
							}
							a.style.cssText = "top:1px;opacity:.55;";
							return (/^0.55/.test(a.style.opacity));
						}(),
						_getIEOpacity = function _getIEOpacity(v) {
							return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
						},
						_log = function _log(s) {
							if (_gsScope.console) {
								console.log(s);
							}
						},
						_target, _index, _prefixCSS = "",
						_prefix = "",
						_checkPropPrefix = function _checkPropPrefix(p, e) {
							e = e || _tempDiv;
							var s = e.style,
								a, i;
							if (s[p] !== undefined) {
								return p;
							}
							p = p.charAt(0).toUpperCase() + p.substr(1);
							a = ["O", "Moz", "ms", "Ms", "Webkit"];
							i = 5;
							while (--i > -1 && s[a[i] + p] === undefined) { }
							if (i >= 0) {
								_prefix = i === 3 ? "ms" : a[i];
								_prefixCSS = "-" + _prefix.toLowerCase() + "-";
								return _prefix + p;
							}
							return null;
						},
						_getComputedStyle = (typeof window !== "undefined" ? window : _doc.defaultView || {
							getComputedStyle: function getComputedStyle() { }
						}).getComputedStyle,
						_getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
							var rv;
							if (!_supportsOpacity)
								if (p === "opacity") {
									return _getIEOpacity(t);
								}
							if (!calc && t.style[p]) {
								rv = t.style[p];
							} else if (cs = cs || _getComputedStyle(t)) {
								rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
							} else if (t.currentStyle) {
								rv = t.currentStyle[p];
							}
							return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
						},
						_convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
							if (sfx === "px" || !sfx && p !== "lineHeight") {
								return v;
							}
							if (sfx === "auto" || !v) {
								return 0;
							}
							var horiz = _horizExp.test(p),
								node = t,
								style = _tempDiv.style,
								neg = v < 0,
								precise = v === 1,
								pix, cache, time;
							if (neg) {
								v = -v;
							}
							if (precise) {
								v *= 100;
							}
							if (p === "lineHeight" && !sfx) {
								cache = _getComputedStyle(t).lineHeight;
								t.style.lineHeight = v;
								pix = parseFloat(_getComputedStyle(t).lineHeight);
								t.style.lineHeight = cache;
							} else if (sfx === "%" && p.indexOf("border") !== -1) {
								pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
							} else {
								style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
								if (sfx === "%" || !node.appendChild || sfx.charAt(0) === "v" || sfx === "rem") {
									node = t.parentNode || _doc.body;
									if (_getStyle(node, "display").indexOf("flex") !== -1) {
										style.position = "absolute";
									}
									cache = node._gsCache;
									time = TweenLite.ticker.frame;
									if (cache && horiz && cache.time === time) {
										return cache.width * v / 100;
									}
									style[horiz ? "width" : "height"] = v + sfx;
								} else {
									style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
								}
								node.appendChild(_tempDiv);
								pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
								node.removeChild(_tempDiv);
								if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
									cache = node._gsCache = node._gsCache || {};
									cache.time = time;
									cache.width = pix / v * 100;
								}
								if (pix === 0 && !recurse) {
									pix = _convertToPixels(t, p, v, sfx, true);
								}
							}
							if (precise) {
								pix /= 100;
							}
							return neg ? -pix : pix;
						},
						_calculateOffset = _internals.calculateOffset = function (t, p, cs) {
							if (_getStyle(t, "position", cs) !== "absolute") {
								return 0;
							}
							var dim = p === "left" ? "Left" : "Top",
								v = _getStyle(t, "margin" + dim, cs);
							return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
						},
						_getAllStyles = function _getAllStyles(t, cs) {
							var s = {},
								i, tr, p;
							if (cs = cs || _getComputedStyle(t, null)) {
								if (i = cs.length) {
									while (--i > -1) {
										p = cs[i];
										if (p.indexOf("-transform") === -1 || _transformPropCSS === p) {
											s[p.replace(_camelExp, _camelFunc)] = cs.getPropertyValue(p);
										}
									}
								} else {
									for (i in cs) {
										if (i.indexOf("Transform") === -1 || _transformProp === i) {
											s[i] = cs[i];
										}
									}
								}
							} else if (cs = t.currentStyle || t.style) {
								for (i in cs) {
									if (typeof i === "string" && s[i] === undefined) {
										s[i.replace(_camelExp, _camelFunc)] = cs[i];
									}
								}
							}
							if (!_supportsOpacity) {
								s.opacity = _getIEOpacity(t);
							}
							tr = _getTransform(t, cs, false);
							s.rotation = tr.rotation;
							s.skewX = tr.skewX;
							s.scaleX = tr.scaleX;
							s.scaleY = tr.scaleY;
							s.x = tr.x;
							s.y = tr.y;
							if (_supports3D) {
								s.z = tr.z;
								s.rotationX = tr.rotationX;
								s.rotationY = tr.rotationY;
								s.scaleZ = tr.scaleZ;
							}
							if (s.filters) {
								delete s.filters;
							}
							return s;
						},
						_cssDif = function _cssDif(t, s1, s2, vars, forceLookup) {
							var difs = {},
								style = t.style,
								val, p, mpt;
							for (p in s2) {
								if (p !== "cssText")
									if (p !== "length")
										if (isNaN(p))
											if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p])
												if (p.indexOf("Origin") === -1)
													if (typeof val === "number" || typeof val === "string") {
														difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val;
														if (style[p] !== undefined) {
															mpt = new MiniPropTween(style, p, style[p], mpt);
														}
													}
							}
							if (vars) {
								for (p in vars) {
									if (p !== "className") {
										difs[p] = vars[p];
									}
								}
							}
							return {
								difs: difs,
								firstMPT: mpt
							};
						},
						_dimensions = {
							width: ["Left", "Right"],
							height: ["Top", "Bottom"]
						},
						_margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
						_getDimension = function _getDimension(t, p, cs) {
							if ((t.nodeName + "").toLowerCase() === "svg") {
								return (cs || _getComputedStyle(t))[p] || 0;
							} else if (t.getCTM && _isSVG(t)) {
								return t.getBBox()[p] || 0;
							}
							var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
								a = _dimensions[p],
								i = a.length;
							cs = cs || _getComputedStyle(t, null);
							while (--i > -1) {
								v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
								v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
							}
							return v;
						},
						_parsePosition = function _parsePosition(v, recObj) {
							if (v === "contain" || v === "auto" || v === "auto auto") {
								return v + " ";
							}
							if (v == null || v === "") {
								v = "0 0";
							}
							var a = v.split(" "),
								x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
								y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1],
								i;
							if (a.length > 3 && !recObj) {
								a = v.split(", ").join(",").split(",");
								v = [];
								for (i = 0; i < a.length; i++) {
									v.push(_parsePosition(a[i]));
								}
								return v.join(",");
							}
							if (y == null) {
								y = x === "center" ? "50%" : "0";
							} else if (y === "center") {
								y = "50%";
							}
							if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
								x = "50%";
							}
							v = x + " " + y + (a.length > 2 ? " " + a[2] : "");
							if (recObj) {
								recObj.oxp = x.indexOf("%") !== -1;
								recObj.oyp = y.indexOf("%") !== -1;
								recObj.oxr = x.charAt(1) === "=";
								recObj.oyr = y.charAt(1) === "=";
								recObj.ox = parseFloat(x.replace(_NaNExp, ""));
								recObj.oy = parseFloat(y.replace(_NaNExp, ""));
								recObj.v = v;
							}
							return recObj || v;
						},
						_parseChange = function _parseChange(e, b) {
							if (typeof e === "function") {
								e = e(_index, _target);
							}
							return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b) || 0;
						},
						_parseVal = function _parseVal(v, d) {
							if (typeof v === "function") {
								v = v(_index, _target);
							}
							return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v) || 0;
						},
						_parseAngle = function _parseAngle(v, d, p, directionalEnd) {
							var min = 0.000001,
								cap, split, dif, result, isRelative;
							if (typeof v === "function") {
								v = v(_index, _target);
							}
							if (v == null) {
								result = d;
							} else if (typeof v === "number") {
								result = v;
							} else {
								cap = 360;
								split = v.split("_");
								isRelative = v.charAt(1) === "=";
								dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d);
								if (split.length) {
									if (directionalEnd) {
										directionalEnd[p] = d + dif;
									}
									if (v.indexOf("short") !== -1) {
										dif = dif % cap;
										if (dif !== dif % (cap / 2)) {
											dif = dif < 0 ? dif + cap : dif - cap;
										}
									}
									if (v.indexOf("_cw") !== -1 && dif < 0) {
										dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
									} else if (v.indexOf("ccw") !== -1 && dif > 0) {
										dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
									}
								}
								result = d + dif;
							}
							if (result < min && result > -min) {
								result = 0;
							}
							return result;
						},
						_colorLookup = {
							aqua: [0, 255, 255],
							lime: [0, 255, 0],
							silver: [192, 192, 192],
							black: [0, 0, 0],
							maroon: [128, 0, 0],
							teal: [0, 128, 128],
							blue: [0, 0, 255],
							navy: [0, 0, 128],
							white: [255, 255, 255],
							fuchsia: [255, 0, 255],
							olive: [128, 128, 0],
							yellow: [255, 255, 0],
							orange: [255, 165, 0],
							gray: [128, 128, 128],
							purple: [128, 0, 128],
							green: [0, 128, 0],
							red: [255, 0, 0],
							pink: [255, 192, 203],
							cyan: [0, 255, 255],
							transparent: [255, 255, 255, 0]
						},
						_hue = function _hue(h, m1, m2) {
							h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
							return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
						},
						_parseColor = CSSPlugin.parseColor = function (v, toHSL) {
							var a, r, g, b, h, s, l, max, min, d, wasHSL;
							if (!v) {
								a = _colorLookup.black;
							} else if (typeof v === "number") {
								a = [v >> 16, v >> 8 & 255, v & 255];
							} else {
								if (v.charAt(v.length - 1) === ",") {
									v = v.substr(0, v.length - 1);
								}
								if (_colorLookup[v]) {
									a = _colorLookup[v];
								} else if (v.charAt(0) === "#") {
									if (v.length === 4) {
										r = v.charAt(1);
										g = v.charAt(2);
										b = v.charAt(3);
										v = "#" + r + r + g + g + b + b;
									}
									v = parseInt(v.substr(1), 16);
									a = [v >> 16, v >> 8 & 255, v & 255];
								} else if (v.substr(0, 3) === "hsl") {
									a = wasHSL = v.match(_numExp);
									if (!toHSL) {
										h = Number(a[0]) % 360 / 360;
										s = Number(a[1]) / 100;
										l = Number(a[2]) / 100;
										g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
										r = l * 2 - g;
										if (a.length > 3) {
											a[3] = Number(a[3]);
										}
										a[0] = _hue(h + 1 / 3, r, g);
										a[1] = _hue(h, r, g);
										a[2] = _hue(h - 1 / 3, r, g);
									} else if (v.indexOf("=") !== -1) {
										return v.match(_relNumExp);
									}
								} else {
									a = v.match(_numExp) || _colorLookup.transparent;
								}
								a[0] = Number(a[0]);
								a[1] = Number(a[1]);
								a[2] = Number(a[2]);
								if (a.length > 3) {
									a[3] = Number(a[3]);
								}
							}
							if (toHSL && !wasHSL) {
								r = a[0] / 255;
								g = a[1] / 255;
								b = a[2] / 255;
								max = Math.max(r, g, b);
								min = Math.min(r, g, b);
								l = (max + min) / 2;
								if (max === min) {
									h = s = 0;
								} else {
									d = max - min;
									s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
									h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
									h *= 60;
								}
								a[0] = h + 0.5 | 0;
								a[1] = s * 100 + 0.5 | 0;
								a[2] = l * 100 + 0.5 | 0;
							}
							return a;
						},
						_formatColors = function _formatColors(s, toHSL) {
							var colors = s.match(_colorExp) || [],
								charIndex = 0,
								parsed = "",
								i, color, temp;
							if (!colors.length) {
								return s;
							}
							for (i = 0; i < colors.length; i++) {
								color = colors[i];
								temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
								charIndex += temp.length + color.length;
								color = _parseColor(color, toHSL);
								if (color.length === 3) {
									color.push(1);
								}
								parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
							}
							return parsed + s.substr(charIndex);
						},
						_colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
					for (p in _colorLookup) {
						_colorExp += "|" + p + "\\b";
					}
					_colorExp = new RegExp(_colorExp + ")", "gi");
					CSSPlugin.colorStringFilter = function (a) {
						var combined = a[0] + " " + a[1],
							toHSL;
						if (_colorExp.test(combined)) {
							toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
							a[0] = _formatColors(a[0], toHSL);
							a[1] = _formatColors(a[1], toHSL);
						}
						_colorExp.lastIndex = 0;
					};
					if (!TweenLite.defaultStringFilter) {
						TweenLite.defaultStringFilter = CSSPlugin.colorStringFilter;
					}
					var _getFormatter = function _getFormatter(dflt, clr, collapsible, multi) {
						if (dflt == null) {
							return function (v) {
								return v;
							};
						}
						var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
							dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
							pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
							sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
							delim = dflt.indexOf(" ") !== -1 ? " " : ",",
							numVals = dVals.length,
							dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
							_formatter2;
						if (!numVals) {
							return function (v) {
								return v;
							};
						}
						if (clr) {
							_formatter2 = function formatter(v) {
								var color, vals, i, a;
								if (typeof v === "number") {
									v += dSfx;
								} else if (multi && _commasOutsideParenExp.test(v)) {
									a = v.replace(_commasOutsideParenExp, "|").split("|");
									for (i = 0; i < a.length; i++) {
										a[i] = _formatter2(a[i]);
									}
									return a.join(",");
								}
								color = (v.match(_colorExp) || [dColor])[0];
								vals = v.split(color).join("").match(_valuesExp) || [];
								i = vals.length;
								if (numVals > i--) {
									while (++i < numVals) {
										vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
									}
								}
								return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
							};
							return _formatter2;
						}
						_formatter2 = function _formatter(v) {
							var vals, a, i;
							if (typeof v === "number") {
								v += dSfx;
							} else if (multi && _commasOutsideParenExp.test(v)) {
								a = v.replace(_commasOutsideParenExp, "|").split("|");
								for (i = 0; i < a.length; i++) {
									a[i] = _formatter2(a[i]);
								}
								return a.join(",");
							}
							vals = v.match(_valuesExp) || [];
							i = vals.length;
							if (numVals > i--) {
								while (++i < numVals) {
									vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
								}
							}
							return pfx + vals.join(delim) + sfx;
						};
						return _formatter2;
					},
						_getEdgeParser = function _getEdgeParser(props) {
							props = props.split(",");
							return function (t, e, p, cssp, pt, plugin, vars) {
								var a = (e + "").split(" "),
									i;
								vars = {};
								for (i = 0; i < 4; i++) {
									vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
								}
								return cssp.parse(t, vars, pt, plugin);
							};
						},
						_setPluginRatio = _internals._setPluginRatio = function (v) {
							this.plugin.setRatio(v);
							var d = this.data,
								proxy = d.proxy,
								mpt = d.firstMPT,
								min = 0.000001,
								val, pt, i, str, p;
							while (mpt) {
								val = proxy[mpt.v];
								if (mpt.r) {
									val = mpt.r(val);
								} else if (val < min && val > -min) {
									val = 0;
								}
								mpt.t[mpt.p] = val;
								mpt = mpt._next;
							}
							if (d.autoRotate) {
								d.autoRotate.rotation = d.mod ? d.mod.call(this._tween, proxy.rotation, this.t, this._tween) : proxy.rotation;
							}
							if (v === 1 || v === 0) {
								mpt = d.firstMPT;
								p = v === 1 ? "e" : "b";
								while (mpt) {
									pt = mpt.t;
									if (!pt.type) {
										pt[p] = pt.s + pt.xs0;
									} else if (pt.type === 1) {
										str = pt.xs0 + pt.s + pt.xs1;
										for (i = 1; i < pt.l; i++) {
											str += pt["xn" + i] + pt["xs" + (i + 1)];
										}
										pt[p] = str;
									}
									mpt = mpt._next;
								}
							}
						},
						MiniPropTween = function MiniPropTween(t, p, v, next, r) {
							this.t = t;
							this.p = p;
							this.v = v;
							this.r = r;
							if (next) {
								next._prev = this;
								this._next = next;
							}
						},
						_parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
							var bpt = pt,
								start = {},
								end = {},
								transform = cssp._transform,
								oldForce = _forcePT,
								i, p, xp, mpt, firstPT;
							cssp._transform = null;
							_forcePT = vars;
							pt = firstPT = cssp.parse(t, vars, pt, plugin);
							_forcePT = oldForce;
							if (shallow) {
								cssp._transform = transform;
								if (bpt) {
									bpt._prev = null;
									if (bpt._prev) {
										bpt._prev._next = null;
									}
								}
							}
							while (pt && pt !== bpt) {
								if (pt.type <= 1) {
									p = pt.p;
									end[p] = pt.s + pt.c;
									start[p] = pt.s;
									if (!shallow) {
										mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
										pt.c = 0;
									}
									if (pt.type === 1) {
										i = pt.l;
										while (--i > 0) {
											xp = "xn" + i;
											p = pt.p + "_" + xp;
											end[p] = pt.data[xp];
											start[p] = pt[xp];
											if (!shallow) {
												mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
											}
										}
									}
								}
								pt = pt._next;
							}
							return {
								proxy: start,
								end: end,
								firstMPT: mpt,
								pt: firstPT
							};
						},
						CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
							this.t = t;
							this.p = p;
							this.s = s;
							this.c = c;
							this.n = n || p;
							if (!(t instanceof CSSPropTween)) {
								_overwriteProps.push(this.n);
							}
							this.r = !r ? r : typeof r === "function" ? r : Math.round;
							this.type = type || 0;
							if (pr) {
								this.pr = pr;
								_hasPriority = true;
							}
							this.b = b === undefined ? s : b;
							this.e = e === undefined ? s + c : e;
							if (next) {
								this._next = next;
								next._prev = this;
							}
						},
						_addNonTweeningNumericPT = function _addNonTweeningNumericPT(target, prop, start, end, next, overwriteProp) {
							var pt = new CSSPropTween(target, prop, start, end - start, next, -1, overwriteProp);
							pt.b = start;
							pt.e = pt.xs0 = end;
							return pt;
						},
						_parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
							b = b || dflt || "";
							if (typeof e === "function") {
								e = e(_index, _target);
							}
							pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
							e += "";
							if (clrs && _colorExp.test(e + b)) {
								e = [b, e];
								CSSPlugin.colorStringFilter(e);
								b = e[0];
								e = e[1];
							}
							var ba = b.split(", ").join(",").split(" "),
								ea = e.split(", ").join(",").split(" "),
								l = ba.length,
								autoRound = _autoRound !== false,
								i, xi, ni, bv, ev, bnums, enums, bn, hasAlpha, temp, cv, str, useHSL;
							if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
								if ((e + b).indexOf("rgb") !== -1 || (e + b).indexOf("hsl") !== -1) {
									ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
									ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
								} else {
									ba = ba.join(" ").split(",").join(", ").split(" ");
									ea = ea.join(" ").split(",").join(", ").split(" ");
								}
								l = ba.length;
							}
							if (l !== ea.length) {
								ba = (dflt || "").split(" ");
								l = ba.length;
							}
							pt.plugin = plugin;
							pt.setRatio = setRatio;
							_colorExp.lastIndex = 0;
							for (i = 0; i < l; i++) {
								bv = ba[i];
								ev = ea[i] + "";
								bn = parseFloat(bv);
								if (bn || bn === 0) {
									pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1 ? Math.round : false, true);
								} else if (clrs && _colorExp.test(bv)) {
									str = ev.indexOf(")") + 1;
									str = ")" + (str ? ev.substr(str) : "");
									useHSL = ev.indexOf("hsl") !== -1 && _supportsOpacity;
									temp = ev;
									bv = _parseColor(bv, useHSL);
									ev = _parseColor(ev, useHSL);
									hasAlpha = bv.length + ev.length > 6;
									if (hasAlpha && !_supportsOpacity && ev[3] === 0) {
										pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
										pt.e = pt.e.split(ea[i]).join("transparent");
									} else {
										if (!_supportsOpacity) {
											hasAlpha = false;
										}
										if (useHSL) {
											pt.appendXtra(temp.substr(0, temp.indexOf("hsl")) + (hasAlpha ? "hsla(" : "hsl("), bv[0], _parseChange(ev[0], bv[0]), ",", false, true).appendXtra("", bv[1], _parseChange(ev[1], bv[1]), "%,", false).appendXtra("", bv[2], _parseChange(ev[2], bv[2]), hasAlpha ? "%," : "%" + str, false);
										} else {
											pt.appendXtra(temp.substr(0, temp.indexOf("rgb")) + (hasAlpha ? "rgba(" : "rgb("), bv[0], ev[0] - bv[0], ",", Math.round, true).appendXtra("", bv[1], ev[1] - bv[1], ",", Math.round).appendXtra("", bv[2], ev[2] - bv[2], hasAlpha ? "," : str, Math.round);
										}
										if (hasAlpha) {
											bv = bv.length < 4 ? 1 : bv[3];
											pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
										}
									}
									_colorExp.lastIndex = 0;
								} else {
									bnums = bv.match(_numExp);
									if (!bnums) {
										pt["xs" + pt.l] += pt.l || pt["xs" + pt.l] ? " " + ev : ev;
									} else {
										enums = ev.match(_relNumExp);
										if (!enums || enums.length !== bnums.length) {
											return pt;
										}
										ni = 0;
										for (xi = 0; xi < bnums.length; xi++) {
											cv = bnums[xi];
											temp = bv.indexOf(cv, ni);
											pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px" ? Math.round : false, xi === 0);
											ni = temp + cv.length;
										}
										pt["xs" + pt.l] += bv.substr(ni);
									}
								}
							}
							if (e.indexOf("=") !== -1)
								if (pt.data) {
									str = pt.xs0 + pt.data.s;
									for (i = 1; i < pt.l; i++) {
										str += pt["xs" + i] + pt.data["xn" + i];
									}
									pt.e = str + pt["xs" + i];
								}
							if (!pt.l) {
								pt.type = -1;
								pt.xs0 = pt.e;
							}
							return pt.xfirst || pt;
						},
						i = 9;
					p = CSSPropTween.prototype;
					p.l = p.pr = 0;
					while (--i > 0) {
						p["xn" + i] = 0;
						p["xs" + i] = "";
					}
					p.xs0 = "";
					p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;
					p.appendXtra = function (pfx, s, c, sfx, r, pad) {
						var pt = this,
							l = pt.l;
						pt["xs" + l] += pad && (l || pt["xs" + l]) ? " " + pfx : pfx || "";
						if (!c)
							if (l !== 0 && !pt.plugin) {
								pt["xs" + l] += s + (sfx || "");
								return pt;
							}
						pt.l++;
						pt.type = pt.setRatio ? 2 : 1;
						pt["xs" + pt.l] = sfx || "";
						if (l > 0) {
							pt.data["xn" + l] = s + c;
							pt.rxp["xn" + l] = r;
							pt["xn" + l] = s;
							if (!pt.plugin) {
								pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
								pt.xfirst.xs0 = 0;
							}
							return pt;
						}
						pt.data = {
							s: s + c
						};
						pt.rxp = {};
						pt.s = s;
						pt.c = c;
						pt.r = r;
						return pt;
					};
					var SpecialProp = function SpecialProp(p, options) {
						options = options || {};
						this.p = options.prefix ? _checkPropPrefix(p) || p : p;
						_specialProps[p] = _specialProps[this.p] = this;
						this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
						if (options.parser) {
							this.parse = options.parser;
						}
						this.clrs = options.color;
						this.multi = options.multi;
						this.keyword = options.keyword;
						this.dflt = options.defaultValue;
						this.pr = options.priority || 0;
					},
						_registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
							if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== "object") {
								options = {
									parser: defaults
								};
							}
							var a = p.split(","),
								d = options.defaultValue,
								i, temp;
							defaults = defaults || [d];
							for (i = 0; i < a.length; i++) {
								options.prefix = i === 0 && options.prefix;
								options.defaultValue = defaults[i] || d;
								temp = new SpecialProp(a[i], options);
							}
						},
						_registerPluginProp = _internals._registerPluginProp = function (p) {
							if (!_specialProps[p]) {
								var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
								_registerComplexSpecialProp(p, {
									parser: function parser(t, e, p, cssp, pt, plugin, vars) {
										var pluginClass = _globals.com.greensock.plugins[pluginName];
										if (!pluginClass) {
											_log("Error: " + pluginName + " js file not loaded.");
											return pt;
										}
										pluginClass._cssRegister();
										return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
									}
								});
							}
						};
					p = SpecialProp.prototype;
					p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
						var kwd = this.keyword,
							i, ba, ea, l, bi, ei;
						if (this.multi)
							if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
								ba = b.replace(_commasOutsideParenExp, "|").split("|");
								ea = e.replace(_commasOutsideParenExp, "|").split("|");
							} else if (kwd) {
								ba = [b];
								ea = [e];
							}
						if (ea) {
							l = ea.length > ba.length ? ea.length : ba.length;
							for (i = 0; i < l; i++) {
								b = ba[i] = ba[i] || this.dflt;
								e = ea[i] = ea[i] || this.dflt;
								if (kwd) {
									bi = b.indexOf(kwd);
									ei = e.indexOf(kwd);
									if (bi !== ei) {
										if (ei === -1) {
											ba[i] = ba[i].split(kwd).join("");
										} else if (bi === -1) {
											ba[i] += " " + kwd;
										}
									}
								}
							}
							b = ba.join(", ");
							e = ea.join(", ");
						}
						return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
					};
					p.parse = function (t, e, p, cssp, pt, plugin, vars) {
						return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
					};
					CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
						_registerComplexSpecialProp(name, {
							parser: function parser(t, e, p, cssp, pt, plugin, vars) {
								var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
								rv.plugin = plugin;
								rv.setRatio = onInitTween(t, e, cssp._tween, p);
								return rv;
							},
							priority: priority
						});
					};
					CSSPlugin.useSVGTransformAttr = true;
					var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
						_transformProp = _checkPropPrefix("transform"),
						_transformPropCSS = _prefixCSS + "transform",
						_transformOriginProp = _checkPropPrefix("transformOrigin"),
						_supports3D = _checkPropPrefix("perspective") !== null,
						Transform = _internals.Transform = function () {
							this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
							this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto";
						},
						_SVGElement = _gsScope.SVGElement,
						_useSVGTransformAttr, _createSVG = function _createSVG(type, container, attributes) {
							var element = _doc.createElementNS("http://www.w3.org/2000/svg", type),
								reg = /([a-z])([A-Z])/g,
								p;
							for (p in attributes) {
								element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p]);
							}
							container.appendChild(element);
							return element;
						},
						_docElement = _doc.documentElement || {},
						_forceSVGTransformAttr = function () {
							var force = _ieVers || /Android/i.test(_agent) && !_gsScope.chrome,
								svg, rect, width;
							if (_doc.createElementNS && !force) {
								svg = _createSVG("svg", _docElement);
								rect = _createSVG("rect", svg, {
									width: 100,
									height: 50,
									x: 100
								});
								width = rect.getBoundingClientRect().width;
								rect.style[_transformOriginProp] = "50% 50%";
								rect.style[_transformProp] = "scaleX(0.5)";
								force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D);
								_docElement.removeChild(svg);
							}
							return force;
						}(),
						_parseSVGOrigin = function _parseSVGOrigin(e, local, decoratee, absolute, smoothOrigin, skipRecord) {
							var tm = e._gsTransform,
								m = _getMatrix(e, true),
								v, x, y, xOrigin, yOrigin, a, b, c, d, tx, ty, determinant, xOriginOld, yOriginOld;
							if (tm) {
								xOriginOld = tm.xOrigin;
								yOriginOld = tm.yOrigin;
							}
							if (!absolute || (v = absolute.split(" ")).length < 2) {
								b = e.getBBox();
								if (b.x === 0 && b.y === 0 && b.width + b.height === 0) {
									b = {
										x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
										y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
										width: 0,
										height: 0
									};
								}
								local = _parsePosition(local).split(" ");
								v = [(local[0].indexOf("%") !== -1 ? parseFloat(local[0]) / 100 * b.width : parseFloat(local[0])) + b.x, (local[1].indexOf("%") !== -1 ? parseFloat(local[1]) / 100 * b.height : parseFloat(local[1])) + b.y];
							}
							decoratee.xOrigin = xOrigin = parseFloat(v[0]);
							decoratee.yOrigin = yOrigin = parseFloat(v[1]);
							if (absolute && m !== _identity2DMatrix) {
								a = m[0];
								b = m[1];
								c = m[2];
								d = m[3];
								tx = m[4];
								ty = m[5];
								determinant = a * d - b * c;
								if (determinant) {
									x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
									y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
									xOrigin = decoratee.xOrigin = v[0] = x;
									yOrigin = decoratee.yOrigin = v[1] = y;
								}
							}
							if (tm) {
								if (skipRecord) {
									decoratee.xOffset = tm.xOffset;
									decoratee.yOffset = tm.yOffset;
									tm = decoratee;
								}
								if (smoothOrigin || smoothOrigin !== false && CSSPlugin.defaultSmoothOrigin !== false) {
									x = xOrigin - xOriginOld;
									y = yOrigin - yOriginOld;
									tm.xOffset += x * m[0] + y * m[2] - x;
									tm.yOffset += x * m[1] + y * m[3] - y;
								} else {
									tm.xOffset = tm.yOffset = 0;
								}
							}
							if (!skipRecord) {
								e.setAttribute("data-svg-origin", v.join(" "));
							}
						},
						_getBBoxHack = function _getBBoxHack(swapIfPossible) {
							var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
								oldParent = this.parentNode,
								oldSibling = this.nextSibling,
								oldCSS = this.style.cssText,
								bbox;
							_docElement.appendChild(svg);
							svg.appendChild(this);
							this.style.display = "block";
							if (swapIfPossible) {
								try {
									bbox = this.getBBox();
									this._originalGetBBox = this.getBBox;
									this.getBBox = _getBBoxHack;
								} catch (e) { }
							} else if (this._originalGetBBox) {
								bbox = this._originalGetBBox();
							}
							if (oldSibling) {
								oldParent.insertBefore(this, oldSibling);
							} else {
								oldParent.appendChild(this);
							}
							_docElement.removeChild(svg);
							this.style.cssText = oldCSS;
							return bbox;
						},
						_getBBox = function _getBBox(e) {
							try {
								return e.getBBox();
							} catch (error) {
								return _getBBoxHack.call(e, true);
							}
						},
						_isSVG = function _isSVG(e) {
							return !!(_SVGElement && e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
						},
						_identity2DMatrix = [1, 0, 0, 1, 0, 0],
						_getMatrix = function _getMatrix(e, force2D) {
							var tm = e._gsTransform || new Transform(),
								rnd = 100000,
								style = e.style,
								isDefault, s, m, n, dec, none;
							if (_transformProp) {
								s = _getStyle(e, _transformPropCSS, null, true);
							} else if (e.currentStyle) {
								s = e.currentStyle.filter.match(_ieGetMatrixExp);
								s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
							}
							isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
							if (_transformProp && ((none = !_getComputedStyle(e) || _getComputedStyle(e).display === "none") || !e.parentNode)) {
								if (none) {
									n = style.display;
									style.display = "block";
								}
								if (!e.parentNode) {
									dec = 1;
									_docElement.appendChild(e);
								}
								s = _getStyle(e, _transformPropCSS, null, true);
								isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)";
								if (n) {
									style.display = n;
								} else if (none) {
									_removeProp(style, "display");
								}
								if (dec) {
									_docElement.removeChild(e);
								}
							}
							if (tm.svg || e.getCTM && _isSVG(e)) {
								if (isDefault && (style[_transformProp] + "").indexOf("matrix") !== -1) {
									s = style[_transformProp];
									isDefault = 0;
								}
								m = e.getAttribute("transform");
								if (isDefault && m) {
									m = e.transform.baseVal.consolidate().matrix;
									s = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
									isDefault = 0;
								}
							}
							if (isDefault) {
								return _identity2DMatrix;
							}
							m = (s || "").match(_numExp) || [];
							i = m.length;
							while (--i > -1) {
								n = Number(m[i]);
								m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n;
							}
							return force2D && m.length > 6 ? [m[0], m[1], m[4], m[5], m[12], m[13]] : m;
						},
						_getTransform = _internals.getTransform = function (t, cs, rec, parse) {
							if (t._gsTransform && rec && !parse) {
								return t._gsTransform;
							}
							var tm = rec ? t._gsTransform || new Transform() : new Transform(),
								invX = tm.scaleX < 0,
								min = 0.00002,
								rnd = 100000,
								zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
								defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0,
								m, i, scaleX, scaleY, rotation, skewX;
							tm.svg = !!(t.getCTM && _isSVG(t));
							if (tm.svg) {
								_parseSVGOrigin(t, _getStyle(t, _transformOriginProp, cs, false, "50% 50%") + "", tm, t.getAttribute("data-svg-origin"));
								_useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr;
							}
							m = _getMatrix(t);
							if (m !== _identity2DMatrix) {
								if (m.length === 16) {
									var a11 = m[0],
										a21 = m[1],
										a31 = m[2],
										a41 = m[3],
										a12 = m[4],
										a22 = m[5],
										a32 = m[6],
										a42 = m[7],
										a13 = m[8],
										a23 = m[9],
										a33 = m[10],
										a14 = m[12],
										a24 = m[13],
										a34 = m[14],
										a43 = m[11],
										angle = Math.atan2(a32, a33),
										t1, t2, t3, t4, cos, sin;
									if (tm.zOrigin) {
										a34 = -tm.zOrigin;
										a14 = a13 * a34 - m[12];
										a24 = a23 * a34 - m[13];
										a34 = a33 * a34 + tm.zOrigin - m[14];
									}
									tm.rotationX = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(-angle);
										sin = Math.sin(-angle);
										t1 = a12 * cos + a13 * sin;
										t2 = a22 * cos + a23 * sin;
										t3 = a32 * cos + a33 * sin;
										a13 = a12 * -sin + a13 * cos;
										a23 = a22 * -sin + a23 * cos;
										a33 = a32 * -sin + a33 * cos;
										a43 = a42 * -sin + a43 * cos;
										a12 = t1;
										a22 = t2;
										a32 = t3;
									}
									angle = Math.atan2(-a31, a33);
									tm.rotationY = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(-angle);
										sin = Math.sin(-angle);
										t1 = a11 * cos - a13 * sin;
										t2 = a21 * cos - a23 * sin;
										t3 = a31 * cos - a33 * sin;
										a23 = a21 * sin + a23 * cos;
										a33 = a31 * sin + a33 * cos;
										a43 = a41 * sin + a43 * cos;
										a11 = t1;
										a21 = t2;
										a31 = t3;
									}
									angle = Math.atan2(a21, a11);
									tm.rotation = angle * _RAD2DEG;
									if (angle) {
										cos = Math.cos(angle);
										sin = Math.sin(angle);
										t1 = a11 * cos + a21 * sin;
										t2 = a12 * cos + a22 * sin;
										t3 = a13 * cos + a23 * sin;
										a21 = a21 * cos - a11 * sin;
										a22 = a22 * cos - a12 * sin;
										a23 = a23 * cos - a13 * sin;
										a11 = t1;
										a12 = t2;
										a13 = t3;
									}
									if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
										tm.rotationX = tm.rotation = 0;
										tm.rotationY = 180 - tm.rotationY;
									}
									angle = Math.atan2(a12, a22);
									tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31) * rnd + 0.5 | 0) / rnd;
									tm.scaleY = (Math.sqrt(a22 * a22 + a32 * a32) * rnd + 0.5 | 0) / rnd;
									tm.scaleZ = (Math.sqrt(a13 * a13 + a23 * a23 + a33 * a33) * rnd + 0.5 | 0) / rnd;
									a11 /= tm.scaleX;
									a12 /= tm.scaleY;
									a21 /= tm.scaleX;
									a22 /= tm.scaleY;
									if (Math.abs(angle) > min) {
										tm.skewX = angle * _RAD2DEG;
										a12 = 0;
										if (tm.skewType !== "simple") {
											tm.scaleY *= 1 / Math.cos(angle);
										}
									} else {
										tm.skewX = 0;
									}
									tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
									tm.x = a14;
									tm.y = a24;
									tm.z = a34;
									if (tm.svg) {
										tm.x -= tm.xOrigin - (tm.xOrigin * a11 - tm.yOrigin * a12);
										tm.y -= tm.yOrigin - (tm.yOrigin * a21 - tm.xOrigin * a22);
									}
								} else if (!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) {
									var k = m.length >= 6,
										a = k ? m[0] : 1,
										b = m[1] || 0,
										c = m[2] || 0,
										d = k ? m[3] : 1;
									tm.x = m[4] || 0;
									tm.y = m[5] || 0;
									scaleX = Math.sqrt(a * a + b * b);
									scaleY = Math.sqrt(d * d + c * c);
									rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0;
									skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
									tm.scaleX = scaleX;
									tm.scaleY = scaleY;
									tm.rotation = rotation;
									tm.skewX = skewX;
									if (_supports3D) {
										tm.rotationX = tm.rotationY = tm.z = 0;
										tm.perspective = defaultTransformPerspective;
										tm.scaleZ = 1;
									}
									if (tm.svg) {
										tm.x -= tm.xOrigin - (tm.xOrigin * a + tm.yOrigin * c);
										tm.y -= tm.yOrigin - (tm.xOrigin * b + tm.yOrigin * d);
									}
								}
								if (Math.abs(tm.skewX) > 90 && Math.abs(tm.skewX) < 270) {
									if (invX) {
										tm.scaleX *= -1;
										tm.skewX += tm.rotation <= 0 ? 180 : -180;
										tm.rotation += tm.rotation <= 0 ? 180 : -180;
									} else {
										tm.scaleY *= -1;
										tm.skewX += tm.skewX <= 0 ? 180 : -180;
									}
								}
								tm.zOrigin = zOrigin;
								for (i in tm) {
									if (tm[i] < min)
										if (tm[i] > -min) {
											tm[i] = 0;
										}
								}
							}
							if (rec) {
								t._gsTransform = tm;
								if (tm.svg) {
									if (_useSVGTransformAttr && t.style[_transformProp]) {
										TweenLite.delayedCall(0.001, function () {
											_removeProp(t.style, _transformProp);
										});
									} else if (!_useSVGTransformAttr && t.getAttribute("transform")) {
										TweenLite.delayedCall(0.001, function () {
											t.removeAttribute("transform");
										});
									}
								}
							}
							return tm;
						},
						_setIETransformRatio = function _setIETransformRatio(v) {
							var t = this.data,
								ang = -t.rotation * _DEG2RAD,
								skew = ang + t.skewX * _DEG2RAD,
								rnd = 100000,
								a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
								b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
								c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
								d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
								style = this.t.style,
								cs = this.t.currentStyle,
								filters, val;
							if (!cs) {
								return;
							}
							val = b;
							b = -c;
							c = -val;
							filters = cs.filter;
							style.filter = "";
							var w = this.t.offsetWidth,
								h = this.t.offsetHeight,
								clip = cs.position !== "absolute",
								m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
								ox = t.x + w * t.xPercent / 100,
								oy = t.y + h * t.yPercent / 100,
								dx, dy;
							if (t.ox != null) {
								dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
								dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
								ox += dx - (dx * a + dy * b);
								oy += dy - (dx * c + dy * d);
							}
							if (!clip) {
								m += ", sizingMethod='auto expand')";
							} else {
								dx = w / 2;
								dy = h / 2;
								m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
							}
							if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
								style.filter = filters.replace(_ieSetMatrixExp, m);
							} else {
								style.filter = m + " " + filters;
							}
							if (v === 0 || v === 1)
								if (a === 1)
									if (b === 0)
										if (c === 0)
											if (d === 1)
												if (!clip || m.indexOf("Dx=0, Dy=0") !== -1)
													if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)
														if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
															style.removeAttribute("filter");
														}
							if (!clip) {
								var mult = _ieVers < 8 ? 1 : -1,
									marg, prop, dif;
								dx = t.ieOffsetX || 0;
								dy = t.ieOffsetY || 0;
								t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
								t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
								for (i = 0; i < 4; i++) {
									prop = _margins[i];
									marg = cs[prop];
									val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
									if (val !== t[prop]) {
										dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY;
									} else {
										dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
									}
									style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
								}
							}
						},
						_setTransformRatio = _internals.set3DTransformRatio = _internals.setTransformRatio = function (v) {
							var t = this.data,
								style = this.t.style,
								angle = t.rotation,
								rotationX = t.rotationX,
								rotationY = t.rotationY,
								sx = t.scaleX,
								sy = t.scaleY,
								sz = t.scaleZ,
								x = t.x,
								y = t.y,
								z = t.z,
								isSVG = t.svg,
								perspective = t.perspective,
								force3D = t.force3D,
								skewY = t.skewY,
								skewX = t.skewX,
								t1, a11, a12, a13, a21, a22, a23, a31, a32, a33, a41, a42, a43, zOrigin, min, cos, sin, t2, transform, comma, zero, skew, rnd;
							if (skewY) {
								skewX += skewY;
								angle += skewY;
							}
							if (((v === 1 || v === 0) && force3D === "auto" && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !force3D) && !z && !perspective && !rotationY && !rotationX && sz === 1 || _useSVGTransformAttr && isSVG || !_supports3D) {
								if (angle || skewX || isSVG) {
									angle *= _DEG2RAD;
									skew = skewX * _DEG2RAD;
									rnd = 100000;
									a11 = Math.cos(angle) * sx;
									a21 = Math.sin(angle) * sx;
									a12 = Math.sin(angle - skew) * -sy;
									a22 = Math.cos(angle - skew) * sy;
									if (skew && t.skewType === "simple") {
										t1 = Math.tan(skew - skewY * _DEG2RAD);
										t1 = Math.sqrt(1 + t1 * t1);
										a12 *= t1;
										a22 *= t1;
										if (skewY) {
											t1 = Math.tan(skewY * _DEG2RAD);
											t1 = Math.sqrt(1 + t1 * t1);
											a11 *= t1;
											a21 *= t1;
										}
									}
									if (isSVG) {
										x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
										y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
										if (_useSVGTransformAttr && (t.xPercent || t.yPercent)) {
											min = this.t.getBBox();
											x += t.xPercent * 0.01 * min.width;
											y += t.yPercent * 0.01 * min.height;
										}
										min = 0.000001;
										if (x < min)
											if (x > -min) {
												x = 0;
											}
										if (y < min)
											if (y > -min) {
												y = 0;
											}
									}
									transform = (a11 * rnd | 0) / rnd + "," + (a21 * rnd | 0) / rnd + "," + (a12 * rnd | 0) / rnd + "," + (a22 * rnd | 0) / rnd + "," + x + "," + y + ")";
									if (isSVG && _useSVGTransformAttr) {
										this.t.setAttribute("transform", "matrix(" + transform);
									} else {
										style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + transform;
									}
								} else {
									style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")";
								}
								return;
							}
							if (_isFirefox) {
								min = 0.0001;
								if (sx < min && sx > -min) {
									sx = sz = 0.00002;
								}
								if (sy < min && sy > -min) {
									sy = sz = 0.00002;
								}
								if (perspective && !t.z && !t.rotationX && !t.rotationY) {
									perspective = 0;
								}
							}
							if (angle || skewX) {
								angle *= _DEG2RAD;
								cos = a11 = Math.cos(angle);
								sin = a21 = Math.sin(angle);
								if (skewX) {
									angle -= skewX * _DEG2RAD;
									cos = Math.cos(angle);
									sin = Math.sin(angle);
									if (t.skewType === "simple") {
										t1 = Math.tan((skewX - skewY) * _DEG2RAD);
										t1 = Math.sqrt(1 + t1 * t1);
										cos *= t1;
										sin *= t1;
										if (t.skewY) {
											t1 = Math.tan(skewY * _DEG2RAD);
											t1 = Math.sqrt(1 + t1 * t1);
											a11 *= t1;
											a21 *= t1;
										}
									}
								}
								a12 = -sin;
								a22 = cos;
							} else if (!rotationY && !rotationX && sz === 1 && !perspective && !isSVG) {
								style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
								return;
							} else {
								a11 = a22 = 1;
								a12 = a21 = 0;
							}
							a33 = 1;
							a13 = a23 = a31 = a32 = a41 = a42 = 0;
							a43 = perspective ? -1 / perspective : 0;
							zOrigin = t.zOrigin;
							min = 0.000001;
							comma = ",";
							zero = "0";
							angle = rotationY * _DEG2RAD;
							if (angle) {
								cos = Math.cos(angle);
								sin = Math.sin(angle);
								a31 = -sin;
								a41 = a43 * -sin;
								a13 = a11 * sin;
								a23 = a21 * sin;
								a33 = cos;
								a43 *= cos;
								a11 *= cos;
								a21 *= cos;
							}
							angle = rotationX * _DEG2RAD;
							if (angle) {
								cos = Math.cos(angle);
								sin = Math.sin(angle);
								t1 = a12 * cos + a13 * sin;
								t2 = a22 * cos + a23 * sin;
								a32 = a33 * sin;
								a42 = a43 * sin;
								a13 = a12 * -sin + a13 * cos;
								a23 = a22 * -sin + a23 * cos;
								a33 = a33 * cos;
								a43 = a43 * cos;
								a12 = t1;
								a22 = t2;
							}
							if (sz !== 1) {
								a13 *= sz;
								a23 *= sz;
								a33 *= sz;
								a43 *= sz;
							}
							if (sy !== 1) {
								a12 *= sy;
								a22 *= sy;
								a32 *= sy;
								a42 *= sy;
							}
							if (sx !== 1) {
								a11 *= sx;
								a21 *= sx;
								a31 *= sx;
								a41 *= sx;
							}
							if (zOrigin || isSVG) {
								if (zOrigin) {
									x += a13 * -zOrigin;
									y += a23 * -zOrigin;
									z += a33 * -zOrigin + zOrigin;
								}
								if (isSVG) {
									x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12) + t.xOffset;
									y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22) + t.yOffset;
								}
								if (x < min && x > -min) {
									x = zero;
								}
								if (y < min && y > -min) {
									y = zero;
								}
								if (z < min && z > -min) {
									z = 0;
								}
							}
							transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d(";
							transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31);
							transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22);
							if (rotationX || rotationY || sz !== 1) {
								transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13);
								transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma;
							} else {
								transform += ",0,0,0,0,1,0,";
							}
							transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")";
							style[_transformProp] = transform;
						};
					p = Transform.prototype;
					p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = p.xOffset = p.yOffset = 0;
					p.scaleX = p.scaleY = p.scaleZ = 1;
					_registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
						parser: function parser(t, e, parsingProp, cssp, pt, plugin, vars) {
							if (cssp._lastParsedTransform === vars) {
								return pt;
							}
							cssp._lastParsedTransform = vars;
							var scaleFunc = vars.scale && typeof vars.scale === "function" ? vars.scale : 0,
								swapFunc;
							if (typeof vars[parsingProp] === "function") {
								swapFunc = vars[parsingProp];
								vars[parsingProp] = e;
							}
							if (scaleFunc) {
								vars.scale = scaleFunc(_index, t);
							}
							var originalGSTransform = t._gsTransform,
								style = t.style,
								min = 0.000001,
								i = _transformProps.length,
								v = vars,
								endRotations = {},
								transformOriginString = "transformOrigin",
								m1 = _getTransform(t, _cs, true, v.parseTransform),
								orig = v.transform && (typeof v.transform === "function" ? v.transform(_index, _target) : v.transform),
								m2, copy, has3D, hasChange, dr, x, y, matrix, p;
							m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType;
							cssp._transform = m1;
							if (orig && typeof orig === "string" && _transformProp) {
								copy = _tempDiv.style;
								copy[_transformProp] = orig;
								copy.display = "block";
								copy.position = "absolute";
								if (orig.indexOf("%") !== -1) {
									copy.width = _getStyle(t, "width");
									copy.height = _getStyle(t, "height");
								}
								_doc.body.appendChild(_tempDiv);
								m2 = _getTransform(_tempDiv, null, false);
								if (m1.skewType === "simple") {
									m2.scaleY *= Math.cos(m2.skewX * _DEG2RAD);
								}
								if (m1.svg) {
									x = m1.xOrigin;
									y = m1.yOrigin;
									m2.x -= m1.xOffset;
									m2.y -= m1.yOffset;
									if (v.transformOrigin || v.svgOrigin) {
										orig = {};
										_parseSVGOrigin(t, _parsePosition(v.transformOrigin), orig, v.svgOrigin, v.smoothOrigin, true);
										x = orig.xOrigin;
										y = orig.yOrigin;
										m2.x -= orig.xOffset - m1.xOffset;
										m2.y -= orig.yOffset - m1.yOffset;
									}
									if (x || y) {
										matrix = _getMatrix(_tempDiv, true);
										m2.x -= x - (x * matrix[0] + y * matrix[2]);
										m2.y -= y - (x * matrix[1] + y * matrix[3]);
									}
								}
								_doc.body.removeChild(_tempDiv);
								if (!m2.perspective) {
									m2.perspective = m1.perspective;
								}
								if (v.xPercent != null) {
									m2.xPercent = _parseVal(v.xPercent, m1.xPercent);
								}
								if (v.yPercent != null) {
									m2.yPercent = _parseVal(v.yPercent, m1.yPercent);
								}
							} else if ((typeof v === "undefined" ? "undefined" : _typeof(v)) === "object") {
								m2 = {
									scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
									scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
									scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
									x: _parseVal(v.x, m1.x),
									y: _parseVal(v.y, m1.y),
									z: _parseVal(v.z, m1.z),
									xPercent: _parseVal(v.xPercent, m1.xPercent),
									yPercent: _parseVal(v.yPercent, m1.yPercent),
									perspective: _parseVal(v.transformPerspective, m1.perspective)
								};
								dr = v.directionalRotation;
								if (dr != null) {
									if ((typeof dr === "undefined" ? "undefined" : _typeof(dr)) === "object") {
										for (copy in dr) {
											v[copy] = dr[copy];
										}
									} else {
										v.rotation = dr;
									}
								}
								if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
									m2.x = 0;
									m2.xPercent = _parseVal(v.x, m1.xPercent);
								}
								if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
									m2.y = 0;
									m2.yPercent = _parseVal(v.y, m1.yPercent);
								}
								m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
								if (_supports3D) {
									m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
									m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
								}
								m2.skewX = _parseAngle(v.skewX, m1.skewX);
								m2.skewY = _parseAngle(v.skewY, m1.skewY);
							}
							if (_supports3D && v.force3D != null) {
								m1.force3D = v.force3D;
								hasChange = true;
							}
							has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
							if (!has3D && v.scale != null) {
								m2.scaleZ = 1;
							}
							while (--i > -1) {
								p = _transformProps[i];
								orig = m2[p] - m1[p];
								if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
									hasChange = true;
									pt = new CSSPropTween(m1, p, m1[p], orig, pt);
									if (p in endRotations) {
										pt.e = endRotations[p];
									}
									pt.xs0 = 0;
									pt.plugin = plugin;
									cssp._overwriteProps.push(pt.n);
								}
							}
							orig = v.transformOrigin;
							if (m1.svg && (orig || v.svgOrigin)) {
								x = m1.xOffset;
								y = m1.yOffset;
								_parseSVGOrigin(t, _parsePosition(orig), m2, v.svgOrigin, v.smoothOrigin);
								pt = _addNonTweeningNumericPT(m1, "xOrigin", (originalGSTransform ? m1 : m2).xOrigin, m2.xOrigin, pt, transformOriginString);
								pt = _addNonTweeningNumericPT(m1, "yOrigin", (originalGSTransform ? m1 : m2).yOrigin, m2.yOrigin, pt, transformOriginString);
								if (x !== m1.xOffset || y !== m1.yOffset) {
									pt = _addNonTweeningNumericPT(m1, "xOffset", originalGSTransform ? x : m1.xOffset, m1.xOffset, pt, transformOriginString);
									pt = _addNonTweeningNumericPT(m1, "yOffset", originalGSTransform ? y : m1.yOffset, m1.yOffset, pt, transformOriginString);
								}
								orig = "0px 0px";
							}
							if (orig || _supports3D && has3D && m1.zOrigin) {
								if (_transformProp) {
									hasChange = true;
									p = _transformOriginProp;
									orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + "";
									pt = new CSSPropTween(style, p, 0, 0, pt, -1, transformOriginString);
									pt.b = style[p];
									pt.plugin = plugin;
									if (_supports3D) {
										copy = m1.zOrigin;
										orig = orig.split(" ");
										m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0;
										pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px";
										pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n);
										pt.b = copy;
										pt.xs0 = pt.e = m1.zOrigin;
									} else {
										pt.xs0 = pt.e = orig;
									}
								} else {
									_parsePosition(orig + "", m1);
								}
							}
							if (hasChange) {
								cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2;
							}
							if (swapFunc) {
								vars[parsingProp] = swapFunc;
							}
							if (scaleFunc) {
								vars.scale = scaleFunc;
							}
							return pt;
						},
						prefix: true
					});
					_registerComplexSpecialProp("boxShadow", {
						defaultValue: "0px 0px 0px 0px #999",
						prefix: true,
						color: true,
						multi: true,
						keyword: "inset"
					});
					_registerComplexSpecialProp("borderRadius", {
						defaultValue: "0px",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							e = this.format(e);
							var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
								style = t.style,
								ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em;
							w = parseFloat(t.offsetWidth);
							h = parseFloat(t.offsetHeight);
							ea1 = e.split(" ");
							for (i = 0; i < props.length; i++) {
								if (this.p.indexOf("border")) {
									props[i] = _checkPropPrefix(props[i]);
								}
								bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
								if (bs.indexOf(" ") !== -1) {
									bs2 = bs.split(" ");
									bs = bs2[0];
									bs2 = bs2[1];
								}
								es = es2 = ea1[i];
								bn = parseFloat(bs);
								bsfx = bs.substr((bn + "").length);
								rel = es.charAt(1) === "=";
								if (rel) {
									en = parseInt(es.charAt(0) + "1", 10);
									es = es.substr(2);
									en *= parseFloat(es);
									esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
								} else {
									en = parseFloat(es);
									esfx = es.substr((en + "").length);
								}
								if (esfx === "") {
									esfx = _suffixMap[p] || bsfx;
								}
								if (esfx !== bsfx) {
									hn = _convertToPixels(t, "borderLeft", bn, bsfx);
									vn = _convertToPixels(t, "borderTop", bn, bsfx);
									if (esfx === "%") {
										bs = hn / w * 100 + "%";
										bs2 = vn / h * 100 + "%";
									} else if (esfx === "em") {
										em = _convertToPixels(t, "borderLeft", 1, "em");
										bs = hn / em + "em";
										bs2 = vn / em + "em";
									} else {
										bs = hn + "px";
										bs2 = vn + "px";
									}
									if (rel) {
										es = parseFloat(bs) + en + esfx;
										es2 = parseFloat(bs2) + en + esfx;
									}
								}
								pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
							}
							return pt;
						},
						prefix: true,
						formatter: _getFormatter("0px 0px 0px 0px", false, true)
					});
					_registerComplexSpecialProp("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
						defaultValue: "0px",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							return _parseComplex(t.style, p, this.format(_getStyle(t, p, _cs, false, "0px 0px")), this.format(e), false, "0px", pt);
						},
						prefix: true,
						formatter: _getFormatter("0px 0px", false, true)
					});
					_registerComplexSpecialProp("backgroundPosition", {
						defaultValue: "0 0",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							var bp = "background-position",
								cs = _cs || _getComputedStyle(t, null),
								bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
								es = this.format(e),
								ba, ea, i, pct, overlap, src;
							if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1) && es.split(",").length < 2) {
								src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
								if (src && src !== "none") {
									ba = bs.split(" ");
									ea = es.split(" ");
									_tempImg.setAttribute("src", src);
									i = 2;
									while (--i > -1) {
										bs = ba[i];
										pct = bs.indexOf("%") !== -1;
										if (pct !== (ea[i].indexOf("%") !== -1)) {
											overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
											ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
										}
									}
									bs = ba.join(" ");
								}
							}
							return this.parseComplex(t.style, bs, es, pt, plugin);
						},
						formatter: _parsePosition
					});
					_registerComplexSpecialProp("backgroundSize", {
						defaultValue: "0 0",
						formatter: function formatter(v) {
							v += "";
							return v.substr(0, 2) === "co" ? v : _parsePosition(v.indexOf(" ") === -1 ? v + " " + v : v);
						}
					});
					_registerComplexSpecialProp("perspective", {
						defaultValue: "0px",
						prefix: true
					});
					_registerComplexSpecialProp("perspectiveOrigin", {
						defaultValue: "50% 50%",
						prefix: true
					});
					_registerComplexSpecialProp("transformStyle", {
						prefix: true
					});
					_registerComplexSpecialProp("backfaceVisibility", {
						prefix: true
					});
					_registerComplexSpecialProp("userSelect", {
						prefix: true
					});
					_registerComplexSpecialProp("margin", {
						parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
					});
					_registerComplexSpecialProp("padding", {
						parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
					});
					_registerComplexSpecialProp("clip", {
						defaultValue: "rect(0px,0px,0px,0px)",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							var b, cs, delim;
							if (_ieVers < 9) {
								cs = t.currentStyle;
								delim = _ieVers < 8 ? " " : ",";
								b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
								e = this.format(e).split(",").join(delim);
							} else {
								b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
								e = this.format(e);
							}
							return this.parseComplex(t.style, b, e, pt, plugin);
						}
					});
					_registerComplexSpecialProp("textShadow", {
						defaultValue: "0px 0px 0px #999",
						color: true,
						multi: true
					});
					_registerComplexSpecialProp("autoRound,strictUnits", {
						parser: function parser(t, e, p, cssp, pt) {
							return pt;
						}
					});
					_registerComplexSpecialProp("border", {
						defaultValue: "0px solid #000",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							var bw = _getStyle(t, "borderTopWidth", _cs, false, "0px"),
								end = this.format(e).split(" "),
								esfx = end[0].replace(_suffixExp, "");
							if (esfx !== "px") {
								bw = parseFloat(bw) / _convertToPixels(t, "borderTopWidth", 1, esfx) + esfx;
							}
							return this.parseComplex(t.style, this.format(bw + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), end.join(" "), pt, plugin);
						},
						color: true,
						formatter: function formatter(v) {
							var a = v.split(" ");
							return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
						}
					});
					_registerComplexSpecialProp("borderWidth", {
						parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
					});
					_registerComplexSpecialProp("float,cssFloat,styleFloat", {
						parser: function parser(t, e, p, cssp, pt, plugin) {
							var s = t.style,
								prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
							return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
						}
					});
					var _setIEOpacityRatio = function _setIEOpacityRatio(v) {
						var t = this.t,
							filters = t.filter || _getStyle(this.data, "filter") || "",
							val = this.s + this.c * v | 0,
							skip;
						if (val === 100) {
							if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
								t.removeAttribute("filter");
								skip = !_getStyle(this.data, "filter");
							} else {
								t.filter = filters.replace(_alphaFilterExp, "");
								skip = true;
							}
						}
						if (!skip) {
							if (this.xn1) {
								t.filter = filters = filters || "alpha(opacity=" + val + ")";
							}
							if (filters.indexOf("pacity") === -1) {
								if (val !== 0 || !this.xn1) {
									t.filter = filters + " alpha(opacity=" + val + ")";
								}
							} else {
								t.filter = filters.replace(_opacityExp, "opacity=" + val);
							}
						}
					};
					_registerComplexSpecialProp("opacity,alpha,autoAlpha", {
						defaultValue: "1",
						parser: function parser(t, e, p, cssp, pt, plugin) {
							var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
								style = t.style,
								isAutoAlpha = p === "autoAlpha";
							if (typeof e === "string" && e.charAt(1) === "=") {
								e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
							}
							if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
								b = 0;
							}
							if (_supportsOpacity) {
								pt = new CSSPropTween(style, "opacity", b, e - b, pt);
							} else {
								pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
								pt.xn1 = isAutoAlpha ? 1 : 0;
								style.zoom = 1;
								pt.type = 2;
								pt.b = "alpha(opacity=" + pt.s + ")";
								pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
								pt.data = t;
								pt.plugin = plugin;
								pt.setRatio = _setIEOpacityRatio;
							}
							if (isAutoAlpha) {
								pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
								pt.xs0 = "inherit";
								cssp._overwriteProps.push(pt.n);
								cssp._overwriteProps.push(p);
							}
							return pt;
						}
					});
					var _removeProp = function _removeProp(s, p) {
						if (p) {
							if (s.removeProperty) {
								if (p.substr(0, 2) === "ms" || p.substr(0, 6) === "webkit") {
									p = "-" + p;
								}
								s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
							} else {
								s.removeAttribute(p);
							}
						}
					},
						_setClassNameRatio = function _setClassNameRatio(v) {
							this.t._gsClassPT = this;
							if (v === 1 || v === 0) {
								this.t.setAttribute("class", v === 0 ? this.b : this.e);
								var mpt = this.data,
									s = this.t.style;
								while (mpt) {
									if (!mpt.v) {
										_removeProp(s, mpt.p);
									} else {
										s[mpt.p] = mpt.v;
									}
									mpt = mpt._next;
								}
								if (v === 1 && this.t._gsClassPT === this) {
									this.t._gsClassPT = null;
								}
							} else if (this.t.getAttribute("class") !== this.e) {
								this.t.setAttribute("class", this.e);
							}
						};
					_registerComplexSpecialProp("className", {
						parser: function parser(t, e, p, cssp, pt, plugin, vars) {
							var b = t.getAttribute("class") || "",
								cssText = t.style.cssText,
								difData, bs, cnpt, cnptLookup, mpt;
							pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
							pt.setRatio = _setClassNameRatio;
							pt.pr = -11;
							_hasPriority = true;
							pt.b = b;
							bs = _getAllStyles(t, _cs);
							cnpt = t._gsClassPT;
							if (cnpt) {
								cnptLookup = {};
								mpt = cnpt.data;
								while (mpt) {
									cnptLookup[mpt.p] = 1;
									mpt = mpt._next;
								}
								cnpt.setRatio(1);
							}
							t._gsClassPT = pt;
							pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
							t.setAttribute("class", pt.e);
							difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
							t.setAttribute("class", b);
							pt.data = difData.firstMPT;
							t.style.cssText = cssText;
							pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin);
							return pt;
						}
					});
					var _setClearPropsRatio = function _setClearPropsRatio(v) {
						if (v === 1 || v === 0)
							if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
								var s = this.t.style,
									transformParse = _specialProps.transform.parse,
									a, p, i, clearTransform, transform;
								if (this.e === "all") {
									s.cssText = "";
									clearTransform = true;
								} else {
									a = this.e.split(" ").join("").split(",");
									i = a.length;
									while (--i > -1) {
										p = a[i];
										if (_specialProps[p]) {
											if (_specialProps[p].parse === transformParse) {
												clearTransform = true;
											} else {
												p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p;
											}
										}
										_removeProp(s, p);
									}
								}
								if (clearTransform) {
									_removeProp(s, _transformProp);
									transform = this.t._gsTransform;
									if (transform) {
										if (transform.svg) {
											this.t.removeAttribute("data-svg-origin");
											this.t.removeAttribute("transform");
										}
										delete this.t._gsTransform;
									}
								}
							}
					};
					_registerComplexSpecialProp("clearProps", {
						parser: function parser(t, e, p, cssp, pt) {
							pt = new CSSPropTween(t, p, 0, 0, pt, 2);
							pt.setRatio = _setClearPropsRatio;
							pt.e = e;
							pt.pr = -10;
							pt.data = cssp._tween;
							_hasPriority = true;
							return pt;
						}
					});
					p = "bezier,throwProps,physicsProps,physics2D".split(",");
					i = p.length;
					while (i--) {
						_registerPluginProp(p[i]);
					}
					p = CSSPlugin.prototype;
					p._firstPT = p._lastParsedTransform = p._transform = null;
					p._onInitTween = function (target, vars, tween, index) {
						if (!target.nodeType) {
							return false;
						}
						this._target = _target = target;
						this._tween = tween;
						this._vars = vars;
						_index = index;
						_autoRound = vars.autoRound;
						_hasPriority = false;
						_suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
						_cs = _getComputedStyle(target, "");
						_overwriteProps = this._overwriteProps;
						var style = target.style,
							v, pt, pt2, first, last, next, zIndex, tpt, threeD;
						if (_reqSafariFix)
							if (style.zIndex === "") {
								v = _getStyle(target, "zIndex", _cs);
								if (v === "auto" || v === "") {
									this._addLazySet(style, "zIndex", 0);
								}
							}
						if (typeof vars === "string") {
							first = style.cssText;
							v = _getAllStyles(target, _cs);
							style.cssText = first + ";" + vars;
							v = _cssDif(target, v, _getAllStyles(target)).difs;
							if (!_supportsOpacity && _opacityValExp.test(vars)) {
								v.opacity = parseFloat(RegExp.$1);
							}
							vars = v;
							style.cssText = first;
						}
						if (vars.className) {
							this._firstPT = pt = _specialProps.className.parse(target, vars.className, "className", this, null, null, vars);
						} else {
							this._firstPT = pt = this.parse(target, vars, null);
						}
						if (this._transformType) {
							threeD = this._transformType === 3;
							if (!_transformProp) {
								style.zoom = 1;
							} else if (_isSafari) {
								_reqSafariFix = true;
								if (style.zIndex === "") {
									zIndex = _getStyle(target, "zIndex", _cs);
									if (zIndex === "auto" || zIndex === "") {
										this._addLazySet(style, "zIndex", 0);
									}
								}
								if (_isSafariLT6) {
									this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"));
								}
							}
							pt2 = pt;
							while (pt2 && pt2._next) {
								pt2 = pt2._next;
							}
							tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
							this._linkCSSP(tpt, null, pt2);
							tpt.setRatio = _transformProp ? _setTransformRatio : _setIETransformRatio;
							tpt.data = this._transform || _getTransform(target, _cs, true);
							tpt.tween = tween;
							tpt.pr = -1;
							_overwriteProps.pop();
						}
						if (_hasPriority) {
							while (pt) {
								next = pt._next;
								pt2 = first;
								while (pt2 && pt2.pr > pt.pr) {
									pt2 = pt2._next;
								}
								if (pt._prev = pt2 ? pt2._prev : last) {
									pt._prev._next = pt;
								} else {
									first = pt;
								}
								if (pt._next = pt2) {
									pt2._prev = pt;
								} else {
									last = pt;
								}
								pt = next;
							}
							this._firstPT = first;
						}
						return true;
					};
					p.parse = function (target, vars, pt, plugin) {
						var style = target.style,
							p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel;
						for (p in vars) {
							es = vars[p];
							if (typeof es === "function") {
								es = es(_index, _target);
							}
							sp = _specialProps[p];
							if (sp) {
								pt = sp.parse(target, es, p, this, pt, plugin, vars);
							} else if (p.substr(0, 2) === "--") {
								this._tween._propLookup[p] = this._addTween.call(this._tween, target.style, "setProperty", _getComputedStyle(target).getPropertyValue(p) + "", es + "", p, false, p);
								continue;
							} else {
								bs = _getStyle(target, p, _cs) + "";
								isStr = typeof es === "string";
								if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
									if (!isStr) {
										es = _parseColor(es);
										es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
									}
									pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
								} else if (isStr && _complexExp.test(es)) {
									pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
								} else {
									bn = parseFloat(bs);
									bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : "";
									if (bs === "" || bs === "auto") {
										if (p === "width" || p === "height") {
											bn = _getDimension(target, p, _cs);
											bsfx = "px";
										} else if (p === "left" || p === "top") {
											bn = _calculateOffset(target, p, _cs);
											bsfx = "px";
										} else {
											bn = p !== "opacity" ? 0 : 1;
											bsfx = "";
										}
									}
									rel = isStr && es.charAt(1) === "=";
									if (rel) {
										en = parseInt(es.charAt(0) + "1", 10);
										es = es.substr(2);
										en *= parseFloat(es);
										esfx = es.replace(_suffixExp, "");
									} else {
										en = parseFloat(es);
										esfx = isStr ? es.replace(_suffixExp, "") : "";
									}
									if (esfx === "") {
										esfx = p in _suffixMap ? _suffixMap[p] : bsfx;
									}
									es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p];
									if (bsfx !== esfx)
										if (esfx !== "" || p === "lineHeight")
											if (en || en === 0)
												if (bn) {
													bn = _convertToPixels(target, p, bn, bsfx);
													if (esfx === "%") {
														bn /= _convertToPixels(target, p, 100, "%") / 100;
														if (vars.strictUnits !== true) {
															bs = bn + "%";
														}
													} else if (esfx === "em" || esfx === "rem" || esfx === "vw" || esfx === "vh") {
														bn /= _convertToPixels(target, p, 1, esfx);
													} else if (esfx !== "px") {
														en = _convertToPixels(target, p, en, esfx);
														esfx = "px";
													}
													if (rel)
														if (en || en === 0) {
															es = en + bn + esfx;
														}
												}
									if (rel) {
										en += bn;
									}
									if ((bn || bn === 0) && (en || en === 0)) {
										pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
										pt.xs0 = esfx;
									} else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
										_log("invalid " + p + " tween value: " + vars[p]);
									} else {
										pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
										pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es;
									}
								}
							}
							if (plugin)
								if (pt && !pt.plugin) {
									pt.plugin = plugin;
								}
						}
						return pt;
					};
					p.setRatio = function (v) {
						var pt = this._firstPT,
							min = 0.000001,
							val, str, i;
						if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
							while (pt) {
								if (pt.type !== 2) {
									if (pt.r && pt.type !== -1) {
										val = pt.r(pt.s + pt.c);
										if (!pt.type) {
											pt.t[pt.p] = val + pt.xs0;
										} else if (pt.type === 1) {
											i = pt.l;
											str = pt.xs0 + val + pt.xs1;
											for (i = 1; i < pt.l; i++) {
												str += pt["xn" + i] + pt["xs" + (i + 1)];
											}
											pt.t[pt.p] = str;
										}
									} else {
										pt.t[pt.p] = pt.e;
									}
								} else {
									pt.setRatio(v);
								}
								pt = pt._next;
							}
						} else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
							while (pt) {
								val = pt.c * v + pt.s;
								if (pt.r) {
									val = pt.r(val);
								} else if (val < min)
									if (val > -min) {
										val = 0;
									}
								if (!pt.type) {
									pt.t[pt.p] = val + pt.xs0;
								} else if (pt.type === 1) {
									i = pt.l;
									if (i === 2) {
										pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
									} else if (i === 3) {
										pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
									} else if (i === 4) {
										pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
									} else if (i === 5) {
										pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
									} else {
										str = pt.xs0 + val + pt.xs1;
										for (i = 1; i < pt.l; i++) {
											str += pt["xn" + i] + pt["xs" + (i + 1)];
										}
										pt.t[pt.p] = str;
									}
								} else if (pt.type === -1) {
									pt.t[pt.p] = pt.xs0;
								} else if (pt.setRatio) {
									pt.setRatio(v);
								}
								pt = pt._next;
							}
						} else {
							while (pt) {
								if (pt.type !== 2) {
									pt.t[pt.p] = pt.b;
								} else {
									pt.setRatio(v);
								}
								pt = pt._next;
							}
						}
					};
					p._enableTransforms = function (threeD) {
						this._transform = this._transform || _getTransform(this._target, _cs, true);
						this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2;
					};
					var lazySet = function lazySet(v) {
						this.t[this.p] = this.e;
						this.data._linkCSSP(this, this._next, null, true);
					};
					p._addLazySet = function (t, p, v) {
						var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2);
						pt.e = v;
						pt.setRatio = lazySet;
						pt.data = this;
					};
					p._linkCSSP = function (pt, next, prev, remove) {
						if (pt) {
							if (next) {
								next._prev = pt;
							}
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = pt._next;
							} else if (this._firstPT === pt) {
								this._firstPT = pt._next;
								remove = true;
							}
							if (prev) {
								prev._next = pt;
							} else if (!remove && this._firstPT === null) {
								this._firstPT = pt;
							}
							pt._next = next;
							pt._prev = prev;
						}
						return pt;
					};
					p._mod = function (lookup) {
						var pt = this._firstPT;
						while (pt) {
							if (typeof lookup[pt.p] === "function") {
								pt.r = lookup[pt.p];
							}
							pt = pt._next;
						}
					};
					p._kill = function (lookup) {
						var copy = lookup,
							pt, p, xfirst;
						if (lookup.autoAlpha || lookup.alpha) {
							copy = {};
							for (p in lookup) {
								copy[p] = lookup[p];
							}
							copy.opacity = 1;
							if (copy.autoAlpha) {
								copy.visibility = 1;
							}
						}
						if (lookup.className && (pt = this._classNamePT)) {
							xfirst = pt.xfirst;
							if (xfirst && xfirst._prev) {
								this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev);
							} else if (xfirst === this._firstPT) {
								this._firstPT = pt._next;
							}
							if (pt._next) {
								this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
							}
							this._classNamePT = null;
						}
						pt = this._firstPT;
						while (pt) {
							if (pt.plugin && pt.plugin !== p && pt.plugin._kill) {
								pt.plugin._kill(lookup);
								p = pt.plugin;
							}
							pt = pt._next;
						}
						return TweenPlugin.prototype._kill.call(this, copy);
					};
					var _getChildStyles = function _getChildStyles(e, props, targets) {
						var children, i, child, type;
						if (e.slice) {
							i = e.length;
							while (--i > -1) {
								_getChildStyles(e[i], props, targets);
							}
							return;
						}
						children = e.childNodes;
						i = children.length;
						while (--i > -1) {
							child = children[i];
							type = child.type;
							if (child.style) {
								props.push(_getAllStyles(child));
								if (targets) {
									targets.push(child);
								}
							}
							if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
								_getChildStyles(child, props, targets);
							}
						}
					};
					CSSPlugin.cascadeTo = function (target, duration, vars) {
						var tween = TweenLite.to(target, duration, vars),
							results = [tween],
							b = [],
							e = [],
							targets = [],
							_reservedProps = TweenLite._internals.reservedProps,
							i, difs, p, from;
						target = tween._targets || tween.target;
						_getChildStyles(target, b, targets);
						tween.render(duration, true, true);
						_getChildStyles(target, e);
						tween.render(0, true, true);
						tween._enabled(true);
						i = targets.length;
						while (--i > -1) {
							difs = _cssDif(targets[i], b[i], e[i]);
							if (difs.firstMPT) {
								difs = difs.difs;
								for (p in vars) {
									if (_reservedProps[p]) {
										difs[p] = vars[p];
									}
								}
								from = {};
								for (p in difs) {
									from[p] = b[i][p];
								}
								results.push(TweenLite.fromTo(targets[i], duration, from, difs));
							}
						}
						return results;
					};
					TweenPlugin.activate([CSSPlugin]);
					return CSSPlugin;
				}, true);
				(function () {
					var RoundPropsPlugin = _gsScope._gsDefine.plugin({
						propName: "roundProps",
						version: "1.7.0",
						priority: -1,
						API: 2,
						init: function init(target, value, tween) {
							this._tween = tween;
							return true;
						}
					}),
						_getRoundFunc = function _getRoundFunc(v) {
							var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1;
							return function (n) {
								return (Math.round(n / v) * v * p | 0) / p;
							};
						},
						_roundLinkedList = function _roundLinkedList(node, mod) {
							while (node) {
								if (!node.f && !node.blob) {
									node.m = mod || Math.round;
								}
								node = node._next;
							}
						},
						p = RoundPropsPlugin.prototype;
					p._onInitAllProps = function () {
						var tween = this._tween,
							rp = tween.vars.roundProps,
							lookup = {},
							rpt = tween._propLookup.roundProps,
							pt, next, i, p;
						if ((typeof rp === "undefined" ? "undefined" : _typeof(rp)) === "object" && !rp.push) {
							for (p in rp) {
								lookup[p] = _getRoundFunc(rp[p]);
							}
						} else {
							if (typeof rp === "string") {
								rp = rp.split(",");
							}
							i = rp.length;
							while (--i > -1) {
								lookup[rp[i]] = Math.round;
							}
						}
						for (p in lookup) {
							pt = tween._firstPT;
							while (pt) {
								next = pt._next;
								if (pt.pg) {
									pt.t._mod(lookup);
								} else if (pt.n === p) {
									if (pt.f === 2 && pt.t) {
										_roundLinkedList(pt.t._firstPT, lookup[p]);
									} else {
										this._add(pt.t, p, pt.s, pt.c, lookup[p]);
										if (next) {
											next._prev = pt._prev;
										}
										if (pt._prev) {
											pt._prev._next = next;
										} else if (tween._firstPT === pt) {
											tween._firstPT = next;
										}
										pt._next = pt._prev = null;
										tween._propLookup[p] = rpt;
									}
								}
								pt = next;
							}
						}
						return false;
					};
					p._add = function (target, p, s, c, mod) {
						this._addTween(target, p, s, s + c, p, mod || Math.round);
						this._overwriteProps.push(p);
					};
				})();
				(function () {
					_gsScope._gsDefine.plugin({
						propName: "attr",
						API: 2,
						version: "0.6.1",
						init: function init(target, value, tween, index) {
							var p, end;
							if (typeof target.setAttribute !== "function") {
								return false;
							}
							for (p in value) {
								end = value[p];
								if (typeof end === "function") {
									end = end(index, target);
								}
								this._addTween(target, "setAttribute", target.getAttribute(p) + "", end + "", p, false, p);
								this._overwriteProps.push(p);
							}
							return true;
						}
					});
				})();
				_gsScope._gsDefine.plugin({
					propName: "directionalRotation",
					version: "0.3.1",
					API: 2,
					init: function init(target, value, tween, index) {
						if ((typeof value === "undefined" ? "undefined" : _typeof(value)) !== "object") {
							value = {
								rotation: value
							};
						}
						this.finals = {};
						var cap = value.useRadians === true ? Math.PI * 2 : 360,
							min = 0.000001,
							p, v, start, end, dif, split;
						for (p in value) {
							if (p !== "useRadians") {
								end = value[p];
								if (typeof end === "function") {
									end = end(index, target);
								}
								split = (end + "").split("_");
								v = split[0];
								start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
								end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
								dif = end - start;
								if (split.length) {
									v = split.join("_");
									if (v.indexOf("short") !== -1) {
										dif = dif % cap;
										if (dif !== dif % (cap / 2)) {
											dif = dif < 0 ? dif + cap : dif - cap;
										}
									}
									if (v.indexOf("_cw") !== -1 && dif < 0) {
										dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
									} else if (v.indexOf("ccw") !== -1 && dif > 0) {
										dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
									}
								}
								if (dif > min || dif < -min) {
									this._addTween(target, p, start, start + dif, p);
									this._overwriteProps.push(p);
								}
							}
						}
						return true;
					},
					set: function set(ratio) {
						var pt;
						if (ratio !== 1) {
							this._super.setRatio.call(this, ratio);
						} else {
							pt = this._firstPT;
							while (pt) {
								if (pt.f) {
									pt.t[pt.p](this.finals[pt.p]);
								} else {
									pt.t[pt.p] = this.finals[pt.p];
								}
								pt = pt._next;
							}
						}
					}
				})._autoCSS = true;
				_gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {
					var w = _gsScope.GreenSockGlobals || _gsScope,
						gs = w.com.greensock,
						_2PI = Math.PI * 2,
						_HALF_PI = Math.PI / 2,
						_class = gs._class,
						_create = function _create(n, f) {
							var C = _class("easing." + n, function () { }, true),
								p = C.prototype = new Ease();
							p.constructor = C;
							p.getRatio = f;
							return C;
						},
						_easeReg = Ease.register || function () { },
						_wrap = function _wrap(name, EaseOut, EaseIn, EaseInOut, aliases) {
							var C = _class("easing." + name, {
								easeOut: new EaseOut(),
								easeIn: new EaseIn(),
								easeInOut: new EaseInOut()
							}, true);
							_easeReg(C, name);
							return C;
						},
						EasePoint = function EasePoint(time, value, next) {
							this.t = time;
							this.v = value;
							if (next) {
								this.next = next;
								next.prev = this;
								this.c = next.v - value;
								this.gap = next.t - time;
							}
						},
						_createBack = function _createBack(n, f) {
							var C = _class("easing." + n, function (overshoot) {
								this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
								this._p2 = this._p1 * 1.525;
							}, true),
								p = C.prototype = new Ease();
							p.constructor = C;
							p.getRatio = f;
							p.config = function (overshoot) {
								return new C(overshoot);
							};
							return C;
						},
						Back = _wrap("Back", _createBack("BackOut", function (p) {
							return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
						}), _createBack("BackIn", function (p) {
							return p * p * ((this._p1 + 1) * p - this._p1);
						}), _createBack("BackInOut", function (p) {
							return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
						})),
						SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
							power = power || power === 0 ? power : 0.7;
							if (linearRatio == null) {
								linearRatio = 0.7;
							} else if (linearRatio > 1) {
								linearRatio = 1;
							}
							this._p = linearRatio !== 1 ? power : 0;
							this._p1 = (1 - linearRatio) / 2;
							this._p2 = linearRatio;
							this._p3 = this._p1 + this._p2;
							this._calcEnd = yoyoMode === true;
						}, true),
						p = SlowMo.prototype = new Ease(),
						SteppedEase, ExpoScaleEase, RoughEase, _createElastic;
					p.constructor = SlowMo;
					p.getRatio = function (p) {
						var r = p + (0.5 - p) * this._p;
						if (p < this._p1) {
							return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
						} else if (p > this._p3) {
							return this._calcEnd ? p === 1 ? 0 : 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
						}
						return this._calcEnd ? 1 : r;
					};
					SlowMo.ease = new SlowMo(0.7, 0.7);
					p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
						return new SlowMo(linearRatio, power, yoyoMode);
					};
					SteppedEase = _class("easing.SteppedEase", function (steps, immediateStart) {
						steps = steps || 1;
						this._p1 = 1 / steps;
						this._p2 = steps + (immediateStart ? 0 : 1);
						this._p3 = immediateStart ? 1 : 0;
					}, true);
					p = SteppedEase.prototype = new Ease();
					p.constructor = SteppedEase;
					p.getRatio = function (p) {
						if (p < 0) {
							p = 0;
						} else if (p >= 1) {
							p = 0.999999999;
						}
						return ((this._p2 * p | 0) + this._p3) * this._p1;
					};
					p.config = SteppedEase.config = function (steps, immediateStart) {
						return new SteppedEase(steps, immediateStart);
					};
					ExpoScaleEase = _class("easing.ExpoScaleEase", function (start, end, ease) {
						this._p1 = Math.log(end / start);
						this._p2 = end - start;
						this._p3 = start;
						this._ease = ease;
					}, true);
					p = ExpoScaleEase.prototype = new Ease();
					p.constructor = ExpoScaleEase;
					p.getRatio = function (p) {
						if (this._ease) {
							p = this._ease.getRatio(p);
						}
						return (this._p3 * Math.exp(this._p1 * p) - this._p3) / this._p2;
					};
					p.config = ExpoScaleEase.config = function (start, end, ease) {
						return new ExpoScaleEase(start, end, ease);
					};
					RoughEase = _class("easing.RoughEase", function (vars) {
						vars = vars || {};
						var taper = vars.taper || "none",
							a = [],
							cnt = 0,
							points = (vars.points || 20) | 0,
							i = points,
							randomize = vars.randomize !== false,
							clamp = vars.clamp === true,
							template = vars.template instanceof Ease ? vars.template : null,
							strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
							x, y, bump, invX, obj, pnt;
						while (--i > -1) {
							x = randomize ? Math.random() : 1 / points * i;
							y = template ? template.getRatio(x) : x;
							if (taper === "none") {
								bump = strength;
							} else if (taper === "out") {
								invX = 1 - x;
								bump = invX * invX * strength;
							} else if (taper === "in") {
								bump = x * x * strength;
							} else if (x < 0.5) {
								invX = x * 2;
								bump = invX * invX * 0.5 * strength;
							} else {
								invX = (1 - x) * 2;
								bump = invX * invX * 0.5 * strength;
							}
							if (randomize) {
								y += Math.random() * bump - bump * 0.5;
							} else if (i % 2) {
								y += bump * 0.5;
							} else {
								y -= bump * 0.5;
							}
							if (clamp) {
								if (y > 1) {
									y = 1;
								} else if (y < 0) {
									y = 0;
								}
							}
							a[cnt++] = {
								x: x,
								y: y
							};
						}
						a.sort(function (a, b) {
							return a.x - b.x;
						});
						pnt = new EasePoint(1, 1, null);
						i = points;
						while (--i > -1) {
							obj = a[i];
							pnt = new EasePoint(obj.x, obj.y, pnt);
						}
						this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
					}, true);
					p = RoughEase.prototype = new Ease();
					p.constructor = RoughEase;
					p.getRatio = function (p) {
						var pnt = this._prev;
						if (p > pnt.t) {
							while (pnt.next && p >= pnt.t) {
								pnt = pnt.next;
							}
							pnt = pnt.prev;
						} else {
							while (pnt.prev && p <= pnt.t) {
								pnt = pnt.prev;
							}
						}
						this._prev = pnt;
						return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
					};
					p.config = function (vars) {
						return new RoughEase(vars);
					};
					RoughEase.ease = new RoughEase();
					_wrap("Bounce", _create("BounceOut", function (p) {
						if (p < 1 / 2.75) {
							return 7.5625 * p * p;
						} else if (p < 2 / 2.75) {
							return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
						} else if (p < 2.5 / 2.75) {
							return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
						}
						return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
					}), _create("BounceIn", function (p) {
						if ((p = 1 - p) < 1 / 2.75) {
							return 1 - 7.5625 * p * p;
						} else if (p < 2 / 2.75) {
							return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
						} else if (p < 2.5 / 2.75) {
							return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
						}
						return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
					}), _create("BounceInOut", function (p) {
						var invert = p < 0.5;
						if (invert) {
							p = 1 - p * 2;
						} else {
							p = p * 2 - 1;
						}
						if (p < 1 / 2.75) {
							p = 7.5625 * p * p;
						} else if (p < 2 / 2.75) {
							p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
						} else if (p < 2.5 / 2.75) {
							p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
						} else {
							p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
						}
						return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
					}));
					_wrap("Circ", _create("CircOut", function (p) {
						return Math.sqrt(1 - (p = p - 1) * p);
					}), _create("CircIn", function (p) {
						return -(Math.sqrt(1 - p * p) - 1);
					}), _create("CircInOut", function (p) {
						return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
					}));
					_createElastic = function _createElastic(n, f, def) {
						var C = _class("easing." + n, function (amplitude, period) {
							this._p1 = amplitude >= 1 ? amplitude : 1;
							this._p2 = (period || def) / (amplitude < 1 ? amplitude : 1);
							this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
							this._p2 = _2PI / this._p2;
						}, true),
							p = C.prototype = new Ease();
						p.constructor = C;
						p.getRatio = f;
						p.config = function (amplitude, period) {
							return new C(amplitude, period);
						};
						return C;
					};
					_wrap("Elastic", _createElastic("ElasticOut", function (p) {
						return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * this._p2) + 1;
					}, 0.3), _createElastic("ElasticIn", function (p) {
						return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2));
					}, 0.3), _createElastic("ElasticInOut", function (p) {
						return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * this._p2) * 0.5 + 1;
					}, 0.45));
					_wrap("Expo", _create("ExpoOut", function (p) {
						return 1 - Math.pow(2, -10 * p);
					}), _create("ExpoIn", function (p) {
						return Math.pow(2, 10 * (p - 1)) - 0.001;
					}), _create("ExpoInOut", function (p) {
						return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
					}));
					_wrap("Sine", _create("SineOut", function (p) {
						return Math.sin(p * _HALF_PI);
					}), _create("SineIn", function (p) {
						return -Math.cos(p * _HALF_PI) + 1;
					}), _create("SineInOut", function (p) {
						return -0.5 * (Math.cos(Math.PI * p) - 1);
					}));
					_class("easing.EaseLookup", {
						find: function find(s) {
							return Ease.map[s];
						}
					}, true);
					_easeReg(w.SlowMo, "SlowMo", "ease,");
					_easeReg(RoughEase, "RoughEase", "ease,");
					_easeReg(SteppedEase, "SteppedEase", "ease,");
					return Back;
				}, true);
			});
			if (_gsScope._gsDefine) {
				_gsScope._gsQueue.pop()();
			}
			(function (window, moduleName) {
				"use strict";
				var _exports = {},
					_doc = window.document,
					_globals = window.GreenSockGlobals = window.GreenSockGlobals || window,
					existingModule = _globals[moduleName];
				if (existingModule) {
					if (typeof module !== "undefined" && module.exports) {
						module.exports = existingModule;
					}
					return existingModule;
				}
				var _namespace = function _namespace(ns) {
					var a = ns.split("."),
						p = _globals,
						i;
					for (i = 0; i < a.length; i++) {
						p[a[i]] = p = p[a[i]] || {};
					}
					return p;
				},
					gs = _namespace("com.greensock"),
					_tinyNum = 0.0000000001,
					_slice = function _slice(a) {
						var b = [],
							l = a.length,
							i;
						for (i = 0; i !== l; b.push(a[i++])) { }
						return b;
					},
					_emptyFunc = function _emptyFunc() { },
					_isArray = function () {
						var toString = Object.prototype.toString,
							array = toString.call([]);
						return function (obj) {
							return obj != null && (obj instanceof Array || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && !!obj.push && toString.call(obj) === array);
						};
					}(),
					a, i, p, _ticker, _tickerActive, _defLookup = {},
					Definition = function Definition(ns, dependencies, func, global) {
						this.sc = _defLookup[ns] ? _defLookup[ns].sc : [];
						_defLookup[ns] = this;
						this.gsClass = null;
						this.func = func;
						var _classes = [];
						this.check = function (init) {
							var i = dependencies.length,
								missing = i,
								cur, a, n, cl;
							while (--i > -1) {
								if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
									_classes[i] = cur.gsClass;
									missing--;
								} else if (init) {
									cur.sc.push(this);
								}
							}
							if (missing === 0 && func) {
								a = ("com.greensock." + ns).split(".");
								n = a.pop();
								cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);
								if (global) {
									_globals[n] = _exports[n] = cl;
									if (typeof module !== "undefined" && module.exports) {
										if (ns === moduleName) {
											module.exports = _exports[moduleName] = cl;
											for (i in _exports) {
												cl[i] = _exports[i];
											}
										} else if (_exports[moduleName]) {
											_exports[moduleName][n] = cl;
										}
									} else if (true) {
										!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
											return cl;
										}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
									}
								}
								for (i = 0; i < this.sc.length; i++) {
									this.sc[i].check();
								}
							}
						};
						this.check(true);
					},
					_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
						return new Definition(ns, dependencies, func, global);
					},
					_class = gs._class = function (ns, func, global) {
						func = func || function () { };
						_gsDefine(ns, [], function () {
							return func;
						}, global);
						return func;
					};
				_gsDefine.globals = _globals;
				var _baseParams = [0, 0, 1, 1],
					Ease = _class("easing.Ease", function (func, extraParams, type, power) {
						this._func = func;
						this._type = type || 0;
						this._power = power || 0;
						this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
					}, true),
					_easeMap = Ease.map = {},
					_easeReg = Ease.register = function (ease, names, types, create) {
						var na = names.split(","),
							i = na.length,
							ta = (types || "easeIn,easeOut,easeInOut").split(","),
							e, name, j, type;
						while (--i > -1) {
							name = na[i];
							e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
							j = ta.length;
							while (--j > -1) {
								type = ta[j];
								_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
							}
						}
					};
				p = Ease.prototype;
				p._calcEnd = false;
				p.getRatio = function (p) {
					if (this._func) {
						this._params[0] = p;
						return this._func.apply(null, this._params);
					}
					var t = this._type,
						pw = this._power,
						r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
					if (pw === 1) {
						r *= r;
					} else if (pw === 2) {
						r *= r * r;
					} else if (pw === 3) {
						r *= r * r * r;
					} else if (pw === 4) {
						r *= r * r * r * r;
					}
					return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
				};
				a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
				i = a.length;
				while (--i > -1) {
					p = a[i] + ",Power" + i;
					_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
					_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
					_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
				}
				_easeMap.linear = gs.easing.Linear.easeIn;
				_easeMap.swing = gs.easing.Quad.easeInOut;
				var EventDispatcher = _class("events.EventDispatcher", function (target) {
					this._listeners = {};
					this._eventTarget = target || this;
				});
				p = EventDispatcher.prototype;
				p.addEventListener = function (type, callback, scope, useParam, priority) {
					priority = priority || 0;
					var list = this._listeners[type],
						index = 0,
						listener, i;
					if (this === _ticker && !_tickerActive) {
						_ticker.wake();
					}
					if (list == null) {
						this._listeners[type] = list = [];
					}
					i = list.length;
					while (--i > -1) {
						listener = list[i];
						if (listener.c === callback && listener.s === scope) {
							list.splice(i, 1);
						} else if (index === 0 && listener.pr < priority) {
							index = i + 1;
						}
					}
					list.splice(index, 0, {
						c: callback,
						s: scope,
						up: useParam,
						pr: priority
					});
				};
				p.removeEventListener = function (type, callback) {
					var list = this._listeners[type],
						i;
					if (list) {
						i = list.length;
						while (--i > -1) {
							if (list[i].c === callback) {
								list.splice(i, 1);
								return;
							}
						}
					}
				};
				p.dispatchEvent = function (type) {
					var list = this._listeners[type],
						i, t, listener;
					if (list) {
						i = list.length;
						if (i > 1) {
							list = list.slice(0);
						}
						t = this._eventTarget;
						while (--i > -1) {
							listener = list[i];
							if (listener) {
								if (listener.up) {
									listener.c.call(listener.s || t, {
										type: type,
										target: t
									});
								} else {
									listener.c.call(listener.s || t);
								}
							}
						}
					}
				};
				var _reqAnimFrame = window.requestAnimationFrame,
					_cancelAnimFrame = window.cancelAnimationFrame,
					_getTime = Date.now || function () {
						return new Date().getTime();
					},
					_lastUpdate = _getTime();
				a = ["ms", "moz", "webkit", "o"];
				i = a.length;
				while (--i > -1 && !_reqAnimFrame) {
					_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
					_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
				}
				_class("Ticker", function (fps, useRAF) {
					var _self = this,
						_startTime = _getTime(),
						_useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
						_lagThreshold = 500,
						_adjustedLag = 33,
						_tickWord = "tick",
						_fps, _req, _id, _gap, _nextTime, _tick = function _tick(manual) {
							var elapsed = _getTime() - _lastUpdate,
								overlap, dispatch;
							if (elapsed > _lagThreshold) {
								_startTime += elapsed - _adjustedLag;
							}
							_lastUpdate += elapsed;
							_self.time = (_lastUpdate - _startTime) / 1000;
							overlap = _self.time - _nextTime;
							if (!_fps || overlap > 0 || manual === true) {
								_self.frame++;
								_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
								dispatch = true;
							}
							if (manual !== true) {
								_id = _req(_tick);
							}
							if (dispatch) {
								_self.dispatchEvent(_tickWord);
							}
						};
					EventDispatcher.call(_self);
					_self.time = _self.frame = 0;
					_self.tick = function () {
						_tick(true);
					};
					_self.lagSmoothing = function (threshold, adjustedLag) {
						if (!arguments.length) {
							return _lagThreshold < 1 / _tinyNum;
						}
						_lagThreshold = threshold || 1 / _tinyNum;
						_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
					};
					_self.sleep = function () {
						if (_id == null) {
							return;
						}
						if (!_useRAF || !_cancelAnimFrame) {
							clearTimeout(_id);
						} else {
							_cancelAnimFrame(_id);
						}
						_req = _emptyFunc;
						_id = null;
						if (_self === _ticker) {
							_tickerActive = false;
						}
					};
					_self.wake = function (seamless) {
						if (_id !== null) {
							_self.sleep();
						} else if (seamless) {
							_startTime += -_lastUpdate + (_lastUpdate = _getTime());
						} else if (_self.frame > 10) {
							_lastUpdate = _getTime() - _lagThreshold + 5;
						}
						_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
							return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
						} : _reqAnimFrame;
						if (_self === _ticker) {
							_tickerActive = true;
						}
						_tick(2);
					};
					_self.fps = function (value) {
						if (!arguments.length) {
							return _fps;
						}
						_fps = value;
						_gap = 1 / (_fps || 60);
						_nextTime = this.time + _gap;
						_self.wake();
					};
					_self.useRAF = function (value) {
						if (!arguments.length) {
							return _useRAF;
						}
						_self.sleep();
						_useRAF = value;
						_self.fps(_fps);
					};
					_self.fps(fps);
					setTimeout(function () {
						if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
							_self.useRAF(false);
						}
					}, 1500);
				});
				p = gs.Ticker.prototype = new gs.events.EventDispatcher();
				p.constructor = gs.Ticker;
				var Animation = _class("core.Animation", function (duration, vars) {
					this.vars = vars = vars || {};
					this._duration = this._totalDuration = duration || 0;
					this._delay = Number(vars.delay) || 0;
					this._timeScale = 1;
					this._active = vars.immediateRender === true;
					this.data = vars.data;
					this._reversed = vars.reversed === true;
					if (!_rootTimeline) {
						return;
					}
					if (!_tickerActive) {
						_ticker.wake();
					}
					var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
					tl.add(this, tl._time);
					if (this.vars.paused) {
						this.paused(true);
					}
				});
				_ticker = Animation.ticker = new gs.Ticker();
				p = Animation.prototype;
				p._dirty = p._gc = p._initted = p._paused = false;
				p._totalTime = p._time = 0;
				p._rawPrevTime = -1;
				p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
				p._paused = false;
				var _checkTimeout = function _checkTimeout() {
					if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
						_ticker.wake();
					}
					var t = setTimeout(_checkTimeout, 2000);
					if (t.unref) {
						t.unref();
					}
				};
				_checkTimeout();
				p.play = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from, suppressEvents);
					}
					return this.reversed(false).paused(false);
				};
				p.pause = function (atTime, suppressEvents) {
					if (atTime != null) {
						this.seek(atTime, suppressEvents);
					}
					return this.paused(true);
				};
				p.resume = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from, suppressEvents);
					}
					return this.paused(false);
				};
				p.seek = function (time, suppressEvents) {
					return this.totalTime(Number(time), suppressEvents !== false);
				};
				p.restart = function (includeDelay, suppressEvents) {
					return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
				};
				p.reverse = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from || this.totalDuration(), suppressEvents);
					}
					return this.reversed(true).paused(false);
				};
				p.render = function (time, suppressEvents, force) { };
				p.invalidate = function () {
					this._time = this._totalTime = 0;
					this._initted = this._gc = false;
					this._rawPrevTime = -1;
					if (this._gc || !this.timeline) {
						this._enabled(true);
					}
					return this;
				};
				p.isActive = function () {
					var tl = this._timeline,
						startTime = this._startTime,
						rawTime;
					return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001;
				};
				p._enabled = function (enabled, ignoreTimeline) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					this._gc = !enabled;
					this._active = this.isActive();
					if (ignoreTimeline !== true) {
						if (enabled && !this.timeline) {
							this._timeline.add(this, this._startTime - this._delay);
						} else if (!enabled && this.timeline) {
							this._timeline._remove(this, true);
						}
					}
					return false;
				};
				p._kill = function (vars, target) {
					return this._enabled(false, false);
				};
				p.kill = function (vars, target) {
					this._kill(vars, target);
					return this;
				};
				p._uncache = function (includeSelf) {
					var tween = includeSelf ? this : this.timeline;
					while (tween) {
						tween._dirty = true;
						tween = tween.timeline;
					}
					return this;
				};
				p._swapSelfInParams = function (params) {
					var i = params.length,
						copy = params.concat();
					while (--i > -1) {
						if (params[i] === "{self}") {
							copy[i] = this;
						}
					}
					return copy;
				};
				p._callback = function (type) {
					var v = this.vars,
						callback = v[type],
						params = v[type + "Params"],
						scope = v[type + "Scope"] || v.callbackScope || this,
						l = params ? params.length : 0;
					switch (l) {
						case 0:
							callback.call(scope);
							break;
						case 1:
							callback.call(scope, params[0]);
							break;
						case 2:
							callback.call(scope, params[0], params[1]);
							break;
						default:
							callback.apply(scope, params);
					}
				};
				p.eventCallback = function (type, callback, params, scope) {
					if ((type || "").substr(0, 2) === "on") {
						var v = this.vars;
						if (arguments.length === 1) {
							return v[type];
						}
						if (callback == null) {
							delete v[type];
						} else {
							v[type] = callback;
							v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
							v[type + "Scope"] = scope;
						}
						if (type === "onUpdate") {
							this._onUpdate = callback;
						}
					}
					return this;
				};
				p.delay = function (value) {
					if (!arguments.length) {
						return this._delay;
					}
					if (this._timeline.smoothChildTiming) {
						this.startTime(this._startTime + value - this._delay);
					}
					this._delay = value;
					return this;
				};
				p.duration = function (value) {
					if (!arguments.length) {
						this._dirty = false;
						return this._duration;
					}
					this._duration = this._totalDuration = value;
					this._uncache(true);
					if (this._timeline.smoothChildTiming)
						if (this._time > 0)
							if (this._time < this._duration)
								if (value !== 0) {
									this.totalTime(this._totalTime * (value / this._duration), true);
								}
					return this;
				};
				p.totalDuration = function (value) {
					this._dirty = false;
					return !arguments.length ? this._totalDuration : this.duration(value);
				};
				p.time = function (value, suppressEvents) {
					if (!arguments.length) {
						return this._time;
					}
					if (this._dirty) {
						this.totalDuration();
					}
					return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
				};
				p.totalTime = function (time, suppressEvents, uncapped) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					if (!arguments.length) {
						return this._totalTime;
					}
					if (this._timeline) {
						if (time < 0 && !uncapped) {
							time += this.totalDuration();
						}
						if (this._timeline.smoothChildTiming) {
							if (this._dirty) {
								this.totalDuration();
							}
							var totalDuration = this._totalDuration,
								tl = this._timeline;
							if (time > totalDuration && !uncapped) {
								time = totalDuration;
							}
							this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
							if (!tl._dirty) {
								this._uncache(false);
							}
							if (tl._timeline) {
								while (tl._timeline) {
									if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
										tl.totalTime(tl._totalTime, true);
									}
									tl = tl._timeline;
								}
							}
						}
						if (this._gc) {
							this._enabled(true, false);
						}
						if (this._totalTime !== time || this._duration === 0) {
							if (_lazyTweens.length) {
								_lazyRender();
							}
							this.render(time, suppressEvents, false);
							if (_lazyTweens.length) {
								_lazyRender();
							}
						}
					}
					return this;
				};
				p.progress = p.totalProgress = function (value, suppressEvents) {
					var duration = this.duration();
					return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
				};
				p.startTime = function (value) {
					if (!arguments.length) {
						return this._startTime;
					}
					if (value !== this._startTime) {
						this._startTime = value;
						if (this.timeline)
							if (this.timeline._sortChildren) {
								this.timeline.add(this, value - this._delay);
							}
					}
					return this;
				};
				p.endTime = function (includeRepeats) {
					return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
				};
				p.timeScale = function (value) {
					if (!arguments.length) {
						return this._timeScale;
					}
					var pauseTime, t;
					value = value || _tinyNum;
					if (this._timeline && this._timeline.smoothChildTiming) {
						pauseTime = this._pauseTime;
						t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
						this._startTime = t - (t - this._startTime) * this._timeScale / value;
					}
					this._timeScale = value;
					t = this.timeline;
					while (t && t.timeline) {
						t._dirty = true;
						t.totalDuration();
						t = t.timeline;
					}
					return this;
				};
				p.reversed = function (value) {
					if (!arguments.length) {
						return this._reversed;
					}
					if (value != this._reversed) {
						this._reversed = value;
						this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
					}
					return this;
				};
				p.paused = function (value) {
					if (!arguments.length) {
						return this._paused;
					}
					var tl = this._timeline,
						raw, elapsed;
					if (value != this._paused)
						if (tl) {
							if (!_tickerActive && !value) {
								_ticker.wake();
							}
							raw = tl.rawTime();
							elapsed = raw - this._pauseTime;
							if (!value && tl.smoothChildTiming) {
								this._startTime += elapsed;
								this._uncache(false);
							}
							this._pauseTime = value ? raw : null;
							this._paused = value;
							this._active = this.isActive();
							if (!value && elapsed !== 0 && this._initted && this.duration()) {
								raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
								this.render(raw, raw === this._totalTime, true);
							}
						}
					if (this._gc && !value) {
						this._enabled(true, false);
					}
					return this;
				};
				var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
					Animation.call(this, 0, vars);
					this.autoRemoveChildren = this.smoothChildTiming = true;
				});
				p = SimpleTimeline.prototype = new Animation();
				p.constructor = SimpleTimeline;
				p.kill()._gc = false;
				p._first = p._last = p._recent = null;
				p._sortChildren = false;
				p.add = p.insert = function (child, position, align, stagger) {
					var prevTween, st;
					child._startTime = Number(position || 0) + child._delay;
					if (child._paused)
						if (this !== child._timeline) {
							child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
						}
					if (child.timeline) {
						child.timeline._remove(child, true);
					}
					child.timeline = child._timeline = this;
					if (child._gc) {
						child._enabled(true, true);
					}
					prevTween = this._last;
					if (this._sortChildren) {
						st = child._startTime;
						while (prevTween && prevTween._startTime > st) {
							prevTween = prevTween._prev;
						}
					}
					if (prevTween) {
						child._next = prevTween._next;
						prevTween._next = child;
					} else {
						child._next = this._first;
						this._first = child;
					}
					if (child._next) {
						child._next._prev = child;
					} else {
						this._last = child;
					}
					child._prev = prevTween;
					this._recent = child;
					if (this._timeline) {
						this._uncache(true);
					}
					return this;
				};
				p._remove = function (tween, skipDisable) {
					if (tween.timeline === this) {
						if (!skipDisable) {
							tween._enabled(false, true);
						}
						if (tween._prev) {
							tween._prev._next = tween._next;
						} else if (this._first === tween) {
							this._first = tween._next;
						}
						if (tween._next) {
							tween._next._prev = tween._prev;
						} else if (this._last === tween) {
							this._last = tween._prev;
						}
						tween._next = tween._prev = tween.timeline = null;
						if (tween === this._recent) {
							this._recent = this._last;
						}
						if (this._timeline) {
							this._uncache(true);
						}
					}
					return this;
				};
				p.render = function (time, suppressEvents, force) {
					var tween = this._first,
						next;
					this._totalTime = this._time = this._rawPrevTime = time;
					while (tween) {
						next = tween._next;
						if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
							}
						}
						tween = next;
					}
				};
				p.rawTime = function () {
					if (!_tickerActive) {
						_ticker.wake();
					}
					return this._totalTime;
				};
				var TweenLite = _class("TweenLite", function (target, duration, vars) {
					Animation.call(this, duration, vars);
					this.render = TweenLite.prototype.render;
					if (target == null) {
						throw "Cannot tween a null target.";
					}
					this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
					var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
						overwrite = this.vars.overwrite,
						i, targ, targets;
					this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];
					if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
						this._targets = targets = _slice(target);
						this._propLookup = [];
						this._siblings = [];
						for (i = 0; i < targets.length; i++) {
							targ = targets[i];
							if (!targ) {
								targets.splice(i--, 1);
								continue;
							} else if (typeof targ === "string") {
								targ = targets[i--] = TweenLite.selector(targ);
								if (typeof targ === "string") {
									targets.splice(i + 1, 1);
								}
								continue;
							} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
								targets.splice(i--, 1);
								this._targets = targets = targets.concat(_slice(targ));
								continue;
							}
							this._siblings[i] = _register(targ, this, false);
							if (overwrite === 1)
								if (this._siblings[i].length > 1) {
									_applyOverwrite(targ, this, null, 1, this._siblings[i]);
								}
						}
					} else {
						this._propLookup = {};
						this._siblings = _register(target, this, false);
						if (overwrite === 1)
							if (this._siblings.length > 1) {
								_applyOverwrite(target, this, null, 1, this._siblings);
							}
					}
					if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
						this._time = -_tinyNum;
						this.render(Math.min(0, -this._delay));
					}
				}, true),
					_isSelector = function _isSelector(v) {
						return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType);
					},
					_autoCSS = function _autoCSS(vars, target) {
						var css = {},
							p;
						for (p in vars) {
							if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
								css[p] = vars[p];
								delete vars[p];
							}
						}
						vars.css = css;
					};
				p = TweenLite.prototype = new Animation();
				p.constructor = TweenLite;
				p.kill()._gc = false;
				p.ratio = 0;
				p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
				p._notifyPluginsOfEnabled = p._lazy = false;
				TweenLite.version = "2.0.1";
				TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
				TweenLite.defaultOverwrite = "auto";
				TweenLite.ticker = _ticker;
				TweenLite.autoSleep = 120;
				TweenLite.lagSmoothing = function (threshold, adjustedLag) {
					_ticker.lagSmoothing(threshold, adjustedLag);
				};
				TweenLite.selector = window.$ || window.jQuery || function (e) {
					var selector = window.$ || window.jQuery;
					if (selector) {
						TweenLite.selector = selector;
						return selector(e);
					}
					if (!_doc) {
						_doc = window.document;
					}
					return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
				};
				var _lazyTweens = [],
					_lazyLookup = {},
					_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
					_relExp = /[\+-]=-?[\.\d]/,
					_setRatio = function _setRatio(v) {
						var pt = this._firstPT,
							min = 0.000001,
							val;
						while (pt) {
							val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;
							if (pt.m) {
								val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
							} else if (val < min)
								if (val > -min && !pt.blob) {
									val = 0;
								}
							if (!pt.f) {
								pt.t[pt.p] = val;
							} else if (pt.fp) {
								pt.t[pt.p](pt.fp, val);
							} else {
								pt.t[pt.p](val);
							}
							pt = pt._next;
						}
					},
					_blobDif = function _blobDif(start, end, filter, pt) {
						var a = [],
							charIndex = 0,
							s = "",
							color = 0,
							startNums, endNums, num, i, l, nonNumbers, currentNum;
						a.start = start;
						a.end = end;
						start = a[0] = start + "";
						end = a[1] = end + "";
						if (filter) {
							filter(a);
							start = a[0];
							end = a[1];
						}
						a.length = 0;
						startNums = start.match(_numbersExp) || [];
						endNums = end.match(_numbersExp) || [];
						if (pt) {
							pt._next = null;
							pt.blob = 1;
							a._firstPT = a._applyPT = pt;
						}
						l = endNums.length;
						for (i = 0; i < l; i++) {
							currentNum = endNums[i];
							nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
							s += nonNumbers || !i ? nonNumbers : ",";
							charIndex += nonNumbers.length;
							if (color) {
								color = (color + 1) % 5;
							} else if (nonNumbers.substr(-5) === "rgba(") {
								color = 1;
							}
							if (currentNum === startNums[i] || startNums.length <= i) {
								s += currentNum;
							} else {
								if (s) {
									a.push(s);
									s = "";
								}
								num = parseFloat(startNums[i]);
								a.push(num);
								a._firstPT = {
									_next: a._firstPT,
									t: a,
									p: a.length - 1,
									s: num,
									c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
									f: 0,
									m: color && color < 4 ? Math.round : 0
								};
							}
							charIndex += currentNum.length;
						}
						s += end.substr(charIndex);
						if (s) {
							a.push(s);
						}
						a.setRatio = _setRatio;
						if (_relExp.test(end)) {
							a.end = null;
						}
						return a;
					},
					_addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
						if (typeof end === "function") {
							end = end(index || 0, target);
						}
						var type = _typeof(target[prop]),
							getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
							s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
							isRelative = typeof end === "string" && end.charAt(1) === "=",
							pt = {
								t: target,
								p: prop,
								s: s,
								f: type === "function",
								pg: 0,
								n: overwriteProp || prop,
								m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
								pr: 0,
								c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
							},
							blob;
						if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
							if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
								pt.fp = funcParam;
								blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
								pt = {
									t: blob,
									p: "setRatio",
									s: 0,
									c: 1,
									f: 2,
									pg: 0,
									n: overwriteProp || prop,
									pr: 0,
									m: 0
								};
							} else {
								pt.s = parseFloat(s);
								if (!isRelative) {
									pt.c = parseFloat(end) - pt.s || 0;
								}
							}
						}
						if (pt.c) {
							if (pt._next = this._firstPT) {
								pt._next._prev = pt;
							}
							this._firstPT = pt;
							return pt;
						}
					},
					_internals = TweenLite._internals = {
						isArray: _isArray,
						isSelector: _isSelector,
						lazyTweens: _lazyTweens,
						blobDif: _blobDif
					},
					_plugins = TweenLite._plugins = {},
					_tweenLookup = _internals.tweenLookup = {},
					_tweenLookupNum = 0,
					_reservedProps = _internals.reservedProps = {
						ease: 1,
						delay: 1,
						overwrite: 1,
						onComplete: 1,
						onCompleteParams: 1,
						onCompleteScope: 1,
						useFrames: 1,
						runBackwards: 1,
						startAt: 1,
						onUpdate: 1,
						onUpdateParams: 1,
						onUpdateScope: 1,
						onStart: 1,
						onStartParams: 1,
						onStartScope: 1,
						onReverseComplete: 1,
						onReverseCompleteParams: 1,
						onReverseCompleteScope: 1,
						onRepeat: 1,
						onRepeatParams: 1,
						onRepeatScope: 1,
						easeParams: 1,
						yoyo: 1,
						immediateRender: 1,
						repeat: 1,
						repeatDelay: 1,
						data: 1,
						paused: 1,
						reversed: 1,
						autoCSS: 1,
						lazy: 1,
						onOverwrite: 1,
						callbackScope: 1,
						stringFilter: 1,
						id: 1,
						yoyoEase: 1
					},
					_overwriteLookup = {
						none: 0,
						all: 1,
						auto: 2,
						concurrent: 3,
						allOnStart: 4,
						preexisting: 5,
						"true": 1,
						"false": 0
					},
					_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
					_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
					_nextGCFrame = 30,
					_lazyRender = _internals.lazyRender = function () {
						var i = _lazyTweens.length,
							tween;
						_lazyLookup = {};
						while (--i > -1) {
							tween = _lazyTweens[i];
							if (tween && tween._lazy !== false) {
								tween.render(tween._lazy[0], tween._lazy[1], true);
								tween._lazy = false;
							}
						}
						_lazyTweens.length = 0;
					};
				_rootTimeline._startTime = _ticker.time;
				_rootFramesTimeline._startTime = _ticker.frame;
				_rootTimeline._active = _rootFramesTimeline._active = true;
				setTimeout(_lazyRender, 1);
				Animation._updateRoot = TweenLite.render = function () {
					var i, a, p;
					if (_lazyTweens.length) {
						_lazyRender();
					}
					_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
					_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
					if (_lazyTweens.length) {
						_lazyRender();
					}
					if (_ticker.frame >= _nextGCFrame) {
						_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
						for (p in _tweenLookup) {
							a = _tweenLookup[p].tweens;
							i = a.length;
							while (--i > -1) {
								if (a[i]._gc) {
									a.splice(i, 1);
								}
							}
							if (a.length === 0) {
								delete _tweenLookup[p];
							}
						}
						p = _rootTimeline._first;
						if (!p || p._paused)
							if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
								while (p && p._paused) {
									p = p._next;
								}
								if (!p) {
									_ticker.sleep();
								}
							}
					}
				};
				_ticker.addEventListener("tick", Animation._updateRoot);
				var _register = function _register(target, tween, scrub) {
					var id = target._gsTweenID,
						a, i;
					if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
						_tweenLookup[id] = {
							target: target,
							tweens: []
						};
					}
					if (tween) {
						a = _tweenLookup[id].tweens;
						a[i = a.length] = tween;
						if (scrub) {
							while (--i > -1) {
								if (a[i] === tween) {
									a.splice(i, 1);
								}
							}
						}
					}
					return _tweenLookup[id].tweens;
				},
					_onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
						var func = overwrittenTween.vars.onOverwrite,
							r1, r2;
						if (func) {
							r1 = func(overwrittenTween, overwritingTween, target, killedProps);
						}
						func = TweenLite.onOverwrite;
						if (func) {
							r2 = func(overwrittenTween, overwritingTween, target, killedProps);
						}
						return r1 !== false && r2 !== false;
					},
					_applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
						var i, changed, curTween, l;
						if (mode === 1 || mode >= 4) {
							l = siblings.length;
							for (i = 0; i < l; i++) {
								if ((curTween = siblings[i]) !== tween) {
									if (!curTween._gc) {
										if (curTween._kill(null, target, tween)) {
											changed = true;
										}
									}
								} else if (mode === 5) {
									break;
								}
							}
							return changed;
						}
						var startTime = tween._startTime + _tinyNum,
							overlaps = [],
							oCount = 0,
							zeroDur = tween._duration === 0,
							globalStart;
						i = siblings.length;
						while (--i > -1) {
							if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) { } else if (curTween._timeline !== tween._timeline) {
								globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
								if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
									overlaps[oCount++] = curTween;
								}
							} else if (curTween._startTime <= startTime)
								if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
									if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
										overlaps[oCount++] = curTween;
									}
						}
						i = oCount;
						while (--i > -1) {
							curTween = overlaps[i];
							if (mode === 2)
								if (curTween._kill(props, target, tween)) {
									changed = true;
								}
							if (mode !== 2 || !curTween._firstPT && curTween._initted) {
								if (mode !== 2 && !_onOverwrite(curTween, tween)) {
									continue;
								}
								if (curTween._enabled(false, false)) {
									changed = true;
								}
							}
						}
						return changed;
					},
					_checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
						var tl = tween._timeline,
							ts = tl._timeScale,
							t = tween._startTime;
						while (tl._timeline) {
							t += tl._startTime;
							ts *= tl._timeScale;
							if (tl._paused) {
								return -100;
							}
							tl = tl._timeline;
						}
						t /= ts;
						return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
					};
				p._init = function () {
					var v = this.vars,
						op = this._overwrittenProps,
						dur = this._duration,
						immediate = !!v.immediateRender,
						ease = v.ease,
						i, initPlugins, pt, p, startVars, l;
					if (v.startAt) {
						if (this._startAt) {
							this._startAt.render(-1, true);
							this._startAt.kill();
						}
						startVars = {};
						for (p in v.startAt) {
							startVars[p] = v.startAt[p];
						}
						startVars.data = "isStart";
						startVars.overwrite = false;
						startVars.immediateRender = true;
						startVars.lazy = immediate && v.lazy !== false;
						startVars.startAt = startVars.delay = null;
						startVars.onUpdate = v.onUpdate;
						startVars.onUpdateParams = v.onUpdateParams;
						startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
						this._startAt = TweenLite.to(this.target || {}, 0, startVars);
						if (immediate) {
							if (this._time > 0) {
								this._startAt = null;
							} else if (dur !== 0) {
								return;
							}
						}
					} else if (v.runBackwards && dur !== 0) {
						if (this._startAt) {
							this._startAt.render(-1, true);
							this._startAt.kill();
							this._startAt = null;
						} else {
							if (this._time !== 0) {
								immediate = false;
							}
							pt = {};
							for (p in v) {
								if (!_reservedProps[p] || p === "autoCSS") {
									pt[p] = v[p];
								}
							}
							pt.overwrite = 0;
							pt.data = "isFromStart";
							pt.lazy = immediate && v.lazy !== false;
							pt.immediateRender = immediate;
							this._startAt = TweenLite.to(this.target, 0, pt);
							if (!immediate) {
								this._startAt._init();
								this._startAt._enabled(false);
								if (this.vars.immediateRender) {
									this._startAt = null;
								}
							} else if (this._time === 0) {
								return;
							}
						}
					}
					this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
					if (v.easeParams instanceof Array && ease.config) {
						this._ease = ease.config.apply(ease, v.easeParams);
					}
					this._easeType = this._ease._type;
					this._easePower = this._ease._power;
					this._firstPT = null;
					if (this._targets) {
						l = this._targets.length;
						for (i = 0; i < l; i++) {
							if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
								initPlugins = true;
							}
						}
					} else {
						initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
					}
					if (initPlugins) {
						TweenLite._onPluginEvent("_onInitAllProps", this);
					}
					if (op)
						if (!this._firstPT)
							if (typeof this.target !== "function") {
								this._enabled(false, false);
							}
					if (v.runBackwards) {
						pt = this._firstPT;
						while (pt) {
							pt.s += pt.c;
							pt.c = -pt.c;
							pt = pt._next;
						}
					}
					this._onUpdate = v.onUpdate;
					this._initted = true;
				};
				p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
					var p, i, initPlugins, plugin, pt, v;
					if (target == null) {
						return false;
					}
					if (_lazyLookup[target._gsTweenID]) {
						_lazyRender();
					}
					if (!this.vars.css)
						if (target.style)
							if (target !== window && target.nodeType)
								if (_plugins.css)
									if (this.vars.autoCSS !== false) {
										_autoCSS(this.vars, target);
									}
					for (p in this.vars) {
						v = this.vars[p];
						if (_reservedProps[p]) {
							if (v)
								if (v instanceof Array || v.push && _isArray(v))
									if (v.join("").indexOf("{self}") !== -1) {
										this.vars[p] = v = this._swapSelfInParams(v, this);
									}
						} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
							this._firstPT = pt = {
								_next: this._firstPT,
								t: plugin,
								p: "setRatio",
								s: 0,
								c: 1,
								f: 1,
								n: p,
								pg: 1,
								pr: plugin._priority,
								m: 0
							};
							i = plugin._overwriteProps.length;
							while (--i > -1) {
								propLookup[plugin._overwriteProps[i]] = this._firstPT;
							}
							if (plugin._priority || plugin._onInitAllProps) {
								initPlugins = true;
							}
							if (plugin._onDisable || plugin._onEnable) {
								this._notifyPluginsOfEnabled = true;
							}
							if (pt._next) {
								pt._next._prev = pt;
							}
						} else {
							propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
						}
					}
					if (overwrittenProps)
						if (this._kill(overwrittenProps, target)) {
							return this._initProps(target, propLookup, siblings, overwrittenProps, index);
						}
					if (this._overwrite > 1)
						if (this._firstPT)
							if (siblings.length > 1)
								if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
									this._kill(propLookup, target);
									return this._initProps(target, propLookup, siblings, overwrittenProps, index);
								}
					if (this._firstPT)
						if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
							_lazyLookup[target._gsTweenID] = true;
						}
					return initPlugins;
				};
				p.render = function (time, suppressEvents, force) {
					var prevTime = this._time,
						duration = this._duration,
						prevRawPrevTime = this._rawPrevTime,
						isComplete, callback, pt, rawPrevTime;
					if (time >= duration - 0.0000001 && time >= 0) {
						this._totalTime = this._time = duration;
						this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
						if (!this._reversed) {
							isComplete = true;
							callback = "onComplete";
							force = force || this._timeline.autoRemoveChildren;
						}
						if (duration === 0)
							if (this._initted || !this.vars.lazy || force) {
								if (this._startTime === this._timeline._duration) {
									time = 0;
								}
								if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause")
									if (prevRawPrevTime !== time) {
										force = true;
										if (prevRawPrevTime > _tinyNum) {
											callback = "onReverseComplete";
										}
									}
								this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
							}
					} else if (time < 0.0000001) {
						this._totalTime = this._time = 0;
						this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
						if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
							callback = "onReverseComplete";
							isComplete = this._reversed;
						}
						if (time < 0) {
							this._active = false;
							if (duration === 0)
								if (this._initted || !this.vars.lazy || force) {
									if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
										force = true;
									}
									this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
								}
						}
						if (!this._initted || this._startAt && this._startAt.progress()) {
							force = true;
						}
					} else {
						this._totalTime = this._time = time;
						if (this._easeType) {
							var r = time / duration,
								type = this._easeType,
								pow = this._easePower;
							if (type === 1 || type === 3 && r >= 0.5) {
								r = 1 - r;
							}
							if (type === 3) {
								r *= 2;
							}
							if (pow === 1) {
								r *= r;
							} else if (pow === 2) {
								r *= r * r;
							} else if (pow === 3) {
								r *= r * r * r;
							} else if (pow === 4) {
								r *= r * r * r * r;
							}
							if (type === 1) {
								this.ratio = 1 - r;
							} else if (type === 2) {
								this.ratio = r;
							} else if (time / duration < 0.5) {
								this.ratio = r / 2;
							} else {
								this.ratio = 1 - r / 2;
							}
						} else {
							this.ratio = this._ease.getRatio(time / duration);
						}
					}
					if (this._time === prevTime && !force) {
						return;
					} else if (!this._initted) {
						this._init();
						if (!this._initted || this._gc) {
							return;
						} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
							this._time = this._totalTime = prevTime;
							this._rawPrevTime = prevRawPrevTime;
							_lazyTweens.push(this);
							this._lazy = [time, suppressEvents];
							return;
						}
						if (this._time && !isComplete) {
							this.ratio = this._ease.getRatio(this._time / duration);
						} else if (isComplete && this._ease._calcEnd) {
							this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
						}
					}
					if (this._lazy !== false) {
						this._lazy = false;
					}
					if (!this._active)
						if (!this._paused && this._time !== prevTime && time >= 0) {
							this._active = true;
						}
					if (prevTime === 0) {
						if (this._startAt) {
							if (time >= 0) {
								this._startAt.render(time, true, force);
							} else if (!callback) {
								callback = "_dummyGS";
							}
						}
						if (this.vars.onStart)
							if (this._time !== 0 || duration === 0)
								if (!suppressEvents) {
									this._callback("onStart");
								}
					}
					pt = this._firstPT;
					while (pt) {
						if (pt.f) {
							pt.t[pt.p](pt.c * this.ratio + pt.s);
						} else {
							pt.t[pt.p] = pt.c * this.ratio + pt.s;
						}
						pt = pt._next;
					}
					if (this._onUpdate) {
						if (time < 0)
							if (this._startAt && time !== -0.0001) {
								this._startAt.render(time, true, force);
							}
						if (!suppressEvents)
							if (this._time !== prevTime || isComplete || force) {
								this._callback("onUpdate");
							}
					}
					if (callback)
						if (!this._gc || force) {
							if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
								this._startAt.render(time, true, force);
							}
							if (isComplete) {
								if (this._timeline.autoRemoveChildren) {
									this._enabled(false, false);
								}
								this._active = false;
							}
							if (!suppressEvents && this.vars[callback]) {
								this._callback(callback);
							}
							if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
								this._rawPrevTime = 0;
							}
						}
				};
				p._kill = function (vars, target, overwritingTween) {
					if (vars === "all") {
						vars = null;
					}
					if (vars == null)
						if (target == null || target === this.target) {
							this._lazy = false;
							return this._enabled(false, false);
						}
					target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
					var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
						i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
					if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
						i = target.length;
						while (--i > -1) {
							if (this._kill(vars, target[i], overwritingTween)) {
								changed = true;
							}
						}
					} else {
						if (this._targets) {
							i = this._targets.length;
							while (--i > -1) {
								if (target === this._targets[i]) {
									propLookup = this._propLookup[i] || {};
									this._overwrittenProps = this._overwrittenProps || [];
									overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
									break;
								}
							}
						} else if (target !== this.target) {
							return false;
						} else {
							propLookup = this._propLookup;
							overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
						}
						if (propLookup) {
							killProps = vars || propLookup;
							record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && ((typeof vars === "undefined" ? "undefined" : _typeof(vars)) !== "object" || !vars._tempKill);
							if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
								for (p in killProps) {
									if (propLookup[p]) {
										if (!killed) {
											killed = [];
										}
										killed.push(p);
									}
								}
								if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
									return false;
								}
							}
							for (p in killProps) {
								if (pt = propLookup[p]) {
									if (simultaneousOverwrite) {
										if (pt.f) {
											pt.t[pt.p](pt.s);
										} else {
											pt.t[pt.p] = pt.s;
										}
										changed = true;
									}
									if (pt.pg && pt.t._kill(killProps)) {
										changed = true;
									}
									if (!pt.pg || pt.t._overwriteProps.length === 0) {
										if (pt._prev) {
											pt._prev._next = pt._next;
										} else if (pt === this._firstPT) {
											this._firstPT = pt._next;
										}
										if (pt._next) {
											pt._next._prev = pt._prev;
										}
										pt._next = pt._prev = null;
									}
									delete propLookup[p];
								}
								if (record) {
									overwrittenProps[p] = 1;
								}
							}
							if (!this._firstPT && this._initted) {
								this._enabled(false, false);
							}
						}
					}
					return changed;
				};
				p.invalidate = function () {
					if (this._notifyPluginsOfEnabled) {
						TweenLite._onPluginEvent("_onDisable", this);
					}
					this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
					this._notifyPluginsOfEnabled = this._active = this._lazy = false;
					this._propLookup = this._targets ? {} : [];
					Animation.prototype.invalidate.call(this);
					if (this.vars.immediateRender) {
						this._time = -_tinyNum;
						this.render(Math.min(0, -this._delay));
					}
					return this;
				};
				p._enabled = function (enabled, ignoreTimeline) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					if (enabled && this._gc) {
						var targets = this._targets,
							i;
						if (targets) {
							i = targets.length;
							while (--i > -1) {
								this._siblings[i] = _register(targets[i], this, true);
							}
						} else {
							this._siblings = _register(this.target, this, true);
						}
					}
					Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
					if (this._notifyPluginsOfEnabled)
						if (this._firstPT) {
							return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
						}
					return false;
				};
				TweenLite.to = function (target, duration, vars) {
					return new TweenLite(target, duration, vars);
				};
				TweenLite.from = function (target, duration, vars) {
					vars.runBackwards = true;
					vars.immediateRender = vars.immediateRender != false;
					return new TweenLite(target, duration, vars);
				};
				TweenLite.fromTo = function (target, duration, fromVars, toVars) {
					toVars.startAt = fromVars;
					toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
					return new TweenLite(target, duration, toVars);
				};
				TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
					return new TweenLite(callback, 0, {
						delay: delay,
						onComplete: callback,
						onCompleteParams: params,
						callbackScope: scope,
						onReverseComplete: callback,
						onReverseCompleteParams: params,
						immediateRender: false,
						lazy: false,
						useFrames: useFrames,
						overwrite: 0
					});
				};
				TweenLite.set = function (target, vars) {
					return new TweenLite(target, 0, vars);
				};
				TweenLite.getTweensOf = function (target, onlyActive) {
					if (target == null) {
						return [];
					}
					target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
					var i, a, j, t;
					if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
						i = target.length;
						a = [];
						while (--i > -1) {
							a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
						}
						i = a.length;
						while (--i > -1) {
							t = a[i];
							j = i;
							while (--j > -1) {
								if (t === a[j]) {
									a.splice(i, 1);
								}
							}
						}
					} else if (target._gsTweenID) {
						a = _register(target).concat();
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc || onlyActive && !a[i].isActive()) {
								a.splice(i, 1);
							}
						}
					}
					return a || [];
				};
				TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
					if ((typeof onlyActive === "undefined" ? "undefined" : _typeof(onlyActive)) === "object") {
						vars = onlyActive;
						onlyActive = false;
					}
					var a = TweenLite.getTweensOf(target, onlyActive),
						i = a.length;
					while (--i > -1) {
						a[i]._kill(vars, target);
					}
				};
				var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);
				p = TweenPlugin.prototype;
				TweenPlugin.version = "1.19.0";
				TweenPlugin.API = 2;
				p._firstPT = null;
				p._addTween = _addPropTween;
				p.setRatio = _setRatio;
				p._kill = function (lookup) {
					var a = this._overwriteProps,
						pt = this._firstPT,
						i;
					if (lookup[this._propName] != null) {
						this._overwriteProps = [];
					} else {
						i = a.length;
						while (--i > -1) {
							if (lookup[a[i]] != null) {
								a.splice(i, 1);
							}
						}
					}
					while (pt) {
						if (lookup[pt.n] != null) {
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = pt._next;
								pt._prev = null;
							} else if (this._firstPT === pt) {
								this._firstPT = pt._next;
							}
						}
						pt = pt._next;
					}
					return false;
				};
				p._mod = p._roundProps = function (lookup) {
					var pt = this._firstPT,
						val;
					while (pt) {
						val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];
						if (val && typeof val === "function") {
							if (pt.f === 2) {
								pt.t._applyPT.m = val;
							} else {
								pt.m = val;
							}
						}
						pt = pt._next;
					}
				};
				TweenLite._onPluginEvent = function (type, tween) {
					var pt = tween._firstPT,
						changed, pt2, first, last, next;
					if (type === "_onInitAllProps") {
						while (pt) {
							next = pt._next;
							pt2 = first;
							while (pt2 && pt2.pr > pt.pr) {
								pt2 = pt2._next;
							}
							if (pt._prev = pt2 ? pt2._prev : last) {
								pt._prev._next = pt;
							} else {
								first = pt;
							}
							if (pt._next = pt2) {
								pt2._prev = pt;
							} else {
								last = pt;
							}
							pt = next;
						}
						pt = tween._firstPT = first;
					}
					while (pt) {
						if (pt.pg)
							if (typeof pt.t[type] === "function")
								if (pt.t[type]()) {
									changed = true;
								}
						pt = pt._next;
					}
					return changed;
				};
				TweenPlugin.activate = function (plugins) {
					var i = plugins.length;
					while (--i > -1) {
						if (plugins[i].API === TweenPlugin.API) {
							_plugins[new plugins[i]()._propName] = plugins[i];
						}
					}
					return true;
				};
				_gsDefine.plugin = function (config) {
					if (!config || !config.propName || !config.init || !config.API) {
						throw "illegal plugin definition.";
					}
					var propName = config.propName,
						priority = config.priority || 0,
						overwriteProps = config.overwriteProps,
						map = {
							init: "_onInitTween",
							set: "setRatio",
							kill: "_kill",
							round: "_mod",
							mod: "_mod",
							initAll: "_onInitAllProps"
						},
						Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
							TweenPlugin.call(this, propName, priority);
							this._overwriteProps = overwriteProps || [];
						}, config.global === true),
						p = Plugin.prototype = new TweenPlugin(propName),
						prop;
					p.constructor = Plugin;
					Plugin.API = config.API;
					for (prop in map) {
						if (typeof config[prop] === "function") {
							p[map[prop]] = config[prop];
						}
					}
					Plugin.version = config.version;
					TweenPlugin.activate([Plugin]);
					return Plugin;
				};
				a = window._gsQueue;
				if (a) {
					for (i = 0; i < a.length; i++) {
						a[i]();
					}
					for (p in _defLookup) {
						if (!_defLookup[p].func) {
							window.console.log("GSAP encountered missing dependency: " + p);
						}
					}
				}
				_tickerActive = false;
			})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : undefined || window, "TweenMax");
		}.call(exports, __webpack_require__(1)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (global) {
			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
				return typeof obj;
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
			};
			/*!
			 * VERSION: 2.0.1
			 * DATE: 2018-05-30
			 * UPDATES AND DOCS AT: http://greensock.com
			 *
			 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
			 * This work is subject to the terms at http://greensock.com/standard-license or for
			 * Club GreenSock members, the software agreement that was issued with your membership.
			 * 
			 * @author: Jack Doyle, jack@greensock.com
			 */
			(function (window, moduleName) {
				"use strict";
				var _exports = {},
					_doc = window.document,
					_globals = window.GreenSockGlobals = window.GreenSockGlobals || window,
					existingModule = _globals[moduleName];
				if (existingModule) {
					if (typeof module !== "undefined" && module.exports) {
						module.exports = existingModule;
					}
					return existingModule;
				}
				var _namespace = function _namespace(ns) {
					var a = ns.split("."),
						p = _globals,
						i;
					for (i = 0; i < a.length; i++) {
						p[a[i]] = p = p[a[i]] || {};
					}
					return p;
				},
					gs = _namespace("com.greensock"),
					_tinyNum = 0.0000000001,
					_slice = function _slice(a) {
						var b = [],
							l = a.length,
							i;
						for (i = 0; i !== l; b.push(a[i++])) { }
						return b;
					},
					_emptyFunc = function _emptyFunc() { },
					_isArray = function () {
						var toString = Object.prototype.toString,
							array = toString.call([]);
						return function (obj) {
							return obj != null && (obj instanceof Array || (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && !!obj.push && toString.call(obj) === array);
						};
					}(),
					a, i, p, _ticker, _tickerActive, _defLookup = {},
					Definition = function Definition(ns, dependencies, func, global) {
						this.sc = _defLookup[ns] ? _defLookup[ns].sc : [];
						_defLookup[ns] = this;
						this.gsClass = null;
						this.func = func;
						var _classes = [];
						this.check = function (init) {
							var i = dependencies.length,
								missing = i,
								cur, a, n, cl;
							while (--i > -1) {
								if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
									_classes[i] = cur.gsClass;
									missing--;
								} else if (init) {
									cur.sc.push(this);
								}
							}
							if (missing === 0 && func) {
								a = ("com.greensock." + ns).split(".");
								n = a.pop();
								cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);
								if (global) {
									_globals[n] = _exports[n] = cl;
									if (typeof module !== "undefined" && module.exports) {
										if (ns === moduleName) {
											module.exports = _exports[moduleName] = cl;
											for (i in _exports) {
												cl[i] = _exports[i];
											}
										} else if (_exports[moduleName]) {
											_exports[moduleName][n] = cl;
										}
									} else if (true) {
										!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
											return cl;
										}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
									}
								}
								for (i = 0; i < this.sc.length; i++) {
									this.sc[i].check();
								}
							}
						};
						this.check(true);
					},
					_gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
						return new Definition(ns, dependencies, func, global);
					},
					_class = gs._class = function (ns, func, global) {
						func = func || function () { };
						_gsDefine(ns, [], function () {
							return func;
						}, global);
						return func;
					};
				_gsDefine.globals = _globals;
				var _baseParams = [0, 0, 1, 1],
					Ease = _class("easing.Ease", function (func, extraParams, type, power) {
						this._func = func;
						this._type = type || 0;
						this._power = power || 0;
						this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
					}, true),
					_easeMap = Ease.map = {},
					_easeReg = Ease.register = function (ease, names, types, create) {
						var na = names.split(","),
							i = na.length,
							ta = (types || "easeIn,easeOut,easeInOut").split(","),
							e, name, j, type;
						while (--i > -1) {
							name = na[i];
							e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
							j = ta.length;
							while (--j > -1) {
								type = ta[j];
								_easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
							}
						}
					};
				p = Ease.prototype;
				p._calcEnd = false;
				p.getRatio = function (p) {
					if (this._func) {
						this._params[0] = p;
						return this._func.apply(null, this._params);
					}
					var t = this._type,
						pw = this._power,
						r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
					if (pw === 1) {
						r *= r;
					} else if (pw === 2) {
						r *= r * r;
					} else if (pw === 3) {
						r *= r * r * r;
					} else if (pw === 4) {
						r *= r * r * r * r;
					}
					return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
				};
				a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
				i = a.length;
				while (--i > -1) {
					p = a[i] + ",Power" + i;
					_easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
					_easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
					_easeReg(new Ease(null, null, 3, i), p, "easeInOut");
				}
				_easeMap.linear = gs.easing.Linear.easeIn;
				_easeMap.swing = gs.easing.Quad.easeInOut;
				var EventDispatcher = _class("events.EventDispatcher", function (target) {
					this._listeners = {};
					this._eventTarget = target || this;
				});
				p = EventDispatcher.prototype;
				p.addEventListener = function (type, callback, scope, useParam, priority) {
					priority = priority || 0;
					var list = this._listeners[type],
						index = 0,
						listener, i;
					if (this === _ticker && !_tickerActive) {
						_ticker.wake();
					}
					if (list == null) {
						this._listeners[type] = list = [];
					}
					i = list.length;
					while (--i > -1) {
						listener = list[i];
						if (listener.c === callback && listener.s === scope) {
							list.splice(i, 1);
						} else if (index === 0 && listener.pr < priority) {
							index = i + 1;
						}
					}
					list.splice(index, 0, {
						c: callback,
						s: scope,
						up: useParam,
						pr: priority
					});
				};
				p.removeEventListener = function (type, callback) {
					var list = this._listeners[type],
						i;
					if (list) {
						i = list.length;
						while (--i > -1) {
							if (list[i].c === callback) {
								list.splice(i, 1);
								return;
							}
						}
					}
				};
				p.dispatchEvent = function (type) {
					var list = this._listeners[type],
						i, t, listener;
					if (list) {
						i = list.length;
						if (i > 1) {
							list = list.slice(0);
						}
						t = this._eventTarget;
						while (--i > -1) {
							listener = list[i];
							if (listener) {
								if (listener.up) {
									listener.c.call(listener.s || t, {
										type: type,
										target: t
									});
								} else {
									listener.c.call(listener.s || t);
								}
							}
						}
					}
				};
				var _reqAnimFrame = window.requestAnimationFrame,
					_cancelAnimFrame = window.cancelAnimationFrame,
					_getTime = Date.now || function () {
						return new Date().getTime();
					},
					_lastUpdate = _getTime();
				a = ["ms", "moz", "webkit", "o"];
				i = a.length;
				while (--i > -1 && !_reqAnimFrame) {
					_reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
					_cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
				}
				_class("Ticker", function (fps, useRAF) {
					var _self = this,
						_startTime = _getTime(),
						_useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
						_lagThreshold = 500,
						_adjustedLag = 33,
						_tickWord = "tick",
						_fps, _req, _id, _gap, _nextTime, _tick = function _tick(manual) {
							var elapsed = _getTime() - _lastUpdate,
								overlap, dispatch;
							if (elapsed > _lagThreshold) {
								_startTime += elapsed - _adjustedLag;
							}
							_lastUpdate += elapsed;
							_self.time = (_lastUpdate - _startTime) / 1000;
							overlap = _self.time - _nextTime;
							if (!_fps || overlap > 0 || manual === true) {
								_self.frame++;
								_nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
								dispatch = true;
							}
							if (manual !== true) {
								_id = _req(_tick);
							}
							if (dispatch) {
								_self.dispatchEvent(_tickWord);
							}
						};
					EventDispatcher.call(_self);
					_self.time = _self.frame = 0;
					_self.tick = function () {
						_tick(true);
					};
					_self.lagSmoothing = function (threshold, adjustedLag) {
						if (!arguments.length) {
							return _lagThreshold < 1 / _tinyNum;
						}
						_lagThreshold = threshold || 1 / _tinyNum;
						_adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
					};
					_self.sleep = function () {
						if (_id == null) {
							return;
						}
						if (!_useRAF || !_cancelAnimFrame) {
							clearTimeout(_id);
						} else {
							_cancelAnimFrame(_id);
						}
						_req = _emptyFunc;
						_id = null;
						if (_self === _ticker) {
							_tickerActive = false;
						}
					};
					_self.wake = function (seamless) {
						if (_id !== null) {
							_self.sleep();
						} else if (seamless) {
							_startTime += -_lastUpdate + (_lastUpdate = _getTime());
						} else if (_self.frame > 10) {
							_lastUpdate = _getTime() - _lagThreshold + 5;
						}
						_req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
							return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
						} : _reqAnimFrame;
						if (_self === _ticker) {
							_tickerActive = true;
						}
						_tick(2);
					};
					_self.fps = function (value) {
						if (!arguments.length) {
							return _fps;
						}
						_fps = value;
						_gap = 1 / (_fps || 60);
						_nextTime = this.time + _gap;
						_self.wake();
					};
					_self.useRAF = function (value) {
						if (!arguments.length) {
							return _useRAF;
						}
						_self.sleep();
						_useRAF = value;
						_self.fps(_fps);
					};
					_self.fps(fps);
					setTimeout(function () {
						if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
							_self.useRAF(false);
						}
					}, 1500);
				});
				p = gs.Ticker.prototype = new gs.events.EventDispatcher();
				p.constructor = gs.Ticker;
				var Animation = _class("core.Animation", function (duration, vars) {
					this.vars = vars = vars || {};
					this._duration = this._totalDuration = duration || 0;
					this._delay = Number(vars.delay) || 0;
					this._timeScale = 1;
					this._active = vars.immediateRender === true;
					this.data = vars.data;
					this._reversed = vars.reversed === true;
					if (!_rootTimeline) {
						return;
					}
					if (!_tickerActive) {
						_ticker.wake();
					}
					var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
					tl.add(this, tl._time);
					if (this.vars.paused) {
						this.paused(true);
					}
				});
				_ticker = Animation.ticker = new gs.Ticker();
				p = Animation.prototype;
				p._dirty = p._gc = p._initted = p._paused = false;
				p._totalTime = p._time = 0;
				p._rawPrevTime = -1;
				p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
				p._paused = false;
				var _checkTimeout = function _checkTimeout() {
					if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
						_ticker.wake();
					}
					var t = setTimeout(_checkTimeout, 2000);
					if (t.unref) {
						t.unref();
					}
				};
				_checkTimeout();
				p.play = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from, suppressEvents);
					}
					return this.reversed(false).paused(false);
				};
				p.pause = function (atTime, suppressEvents) {
					if (atTime != null) {
						this.seek(atTime, suppressEvents);
					}
					return this.paused(true);
				};
				p.resume = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from, suppressEvents);
					}
					return this.paused(false);
				};
				p.seek = function (time, suppressEvents) {
					return this.totalTime(Number(time), suppressEvents !== false);
				};
				p.restart = function (includeDelay, suppressEvents) {
					return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
				};
				p.reverse = function (from, suppressEvents) {
					if (from != null) {
						this.seek(from || this.totalDuration(), suppressEvents);
					}
					return this.reversed(true).paused(false);
				};
				p.render = function (time, suppressEvents, force) { };
				p.invalidate = function () {
					this._time = this._totalTime = 0;
					this._initted = this._gc = false;
					this._rawPrevTime = -1;
					if (this._gc || !this.timeline) {
						this._enabled(true);
					}
					return this;
				};
				p.isActive = function () {
					var tl = this._timeline,
						startTime = this._startTime,
						rawTime;
					return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - 0.0000001;
				};
				p._enabled = function (enabled, ignoreTimeline) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					this._gc = !enabled;
					this._active = this.isActive();
					if (ignoreTimeline !== true) {
						if (enabled && !this.timeline) {
							this._timeline.add(this, this._startTime - this._delay);
						} else if (!enabled && this.timeline) {
							this._timeline._remove(this, true);
						}
					}
					return false;
				};
				p._kill = function (vars, target) {
					return this._enabled(false, false);
				};
				p.kill = function (vars, target) {
					this._kill(vars, target);
					return this;
				};
				p._uncache = function (includeSelf) {
					var tween = includeSelf ? this : this.timeline;
					while (tween) {
						tween._dirty = true;
						tween = tween.timeline;
					}
					return this;
				};
				p._swapSelfInParams = function (params) {
					var i = params.length,
						copy = params.concat();
					while (--i > -1) {
						if (params[i] === "{self}") {
							copy[i] = this;
						}
					}
					return copy;
				};
				p._callback = function (type) {
					var v = this.vars,
						callback = v[type],
						params = v[type + "Params"],
						scope = v[type + "Scope"] || v.callbackScope || this,
						l = params ? params.length : 0;
					switch (l) {
						case 0:
							callback.call(scope);
							break;
						case 1:
							callback.call(scope, params[0]);
							break;
						case 2:
							callback.call(scope, params[0], params[1]);
							break;
						default:
							callback.apply(scope, params);
					}
				};
				p.eventCallback = function (type, callback, params, scope) {
					if ((type || "").substr(0, 2) === "on") {
						var v = this.vars;
						if (arguments.length === 1) {
							return v[type];
						}
						if (callback == null) {
							delete v[type];
						} else {
							v[type] = callback;
							v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
							v[type + "Scope"] = scope;
						}
						if (type === "onUpdate") {
							this._onUpdate = callback;
						}
					}
					return this;
				};
				p.delay = function (value) {
					if (!arguments.length) {
						return this._delay;
					}
					if (this._timeline.smoothChildTiming) {
						this.startTime(this._startTime + value - this._delay);
					}
					this._delay = value;
					return this;
				};
				p.duration = function (value) {
					if (!arguments.length) {
						this._dirty = false;
						return this._duration;
					}
					this._duration = this._totalDuration = value;
					this._uncache(true);
					if (this._timeline.smoothChildTiming)
						if (this._time > 0)
							if (this._time < this._duration)
								if (value !== 0) {
									this.totalTime(this._totalTime * (value / this._duration), true);
								}
					return this;
				};
				p.totalDuration = function (value) {
					this._dirty = false;
					return !arguments.length ? this._totalDuration : this.duration(value);
				};
				p.time = function (value, suppressEvents) {
					if (!arguments.length) {
						return this._time;
					}
					if (this._dirty) {
						this.totalDuration();
					}
					return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
				};
				p.totalTime = function (time, suppressEvents, uncapped) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					if (!arguments.length) {
						return this._totalTime;
					}
					if (this._timeline) {
						if (time < 0 && !uncapped) {
							time += this.totalDuration();
						}
						if (this._timeline.smoothChildTiming) {
							if (this._dirty) {
								this.totalDuration();
							}
							var totalDuration = this._totalDuration,
								tl = this._timeline;
							if (time > totalDuration && !uncapped) {
								time = totalDuration;
							}
							this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
							if (!tl._dirty) {
								this._uncache(false);
							}
							if (tl._timeline) {
								while (tl._timeline) {
									if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
										tl.totalTime(tl._totalTime, true);
									}
									tl = tl._timeline;
								}
							}
						}
						if (this._gc) {
							this._enabled(true, false);
						}
						if (this._totalTime !== time || this._duration === 0) {
							if (_lazyTweens.length) {
								_lazyRender();
							}
							this.render(time, suppressEvents, false);
							if (_lazyTweens.length) {
								_lazyRender();
							}
						}
					}
					return this;
				};
				p.progress = p.totalProgress = function (value, suppressEvents) {
					var duration = this.duration();
					return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
				};
				p.startTime = function (value) {
					if (!arguments.length) {
						return this._startTime;
					}
					if (value !== this._startTime) {
						this._startTime = value;
						if (this.timeline)
							if (this.timeline._sortChildren) {
								this.timeline.add(this, value - this._delay);
							}
					}
					return this;
				};
				p.endTime = function (includeRepeats) {
					return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
				};
				p.timeScale = function (value) {
					if (!arguments.length) {
						return this._timeScale;
					}
					var pauseTime, t;
					value = value || _tinyNum;
					if (this._timeline && this._timeline.smoothChildTiming) {
						pauseTime = this._pauseTime;
						t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
						this._startTime = t - (t - this._startTime) * this._timeScale / value;
					}
					this._timeScale = value;
					t = this.timeline;
					while (t && t.timeline) {
						t._dirty = true;
						t.totalDuration();
						t = t.timeline;
					}
					return this;
				};
				p.reversed = function (value) {
					if (!arguments.length) {
						return this._reversed;
					}
					if (value != this._reversed) {
						this._reversed = value;
						this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
					}
					return this;
				};
				p.paused = function (value) {
					if (!arguments.length) {
						return this._paused;
					}
					var tl = this._timeline,
						raw, elapsed;
					if (value != this._paused)
						if (tl) {
							if (!_tickerActive && !value) {
								_ticker.wake();
							}
							raw = tl.rawTime();
							elapsed = raw - this._pauseTime;
							if (!value && tl.smoothChildTiming) {
								this._startTime += elapsed;
								this._uncache(false);
							}
							this._pauseTime = value ? raw : null;
							this._paused = value;
							this._active = this.isActive();
							if (!value && elapsed !== 0 && this._initted && this.duration()) {
								raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
								this.render(raw, raw === this._totalTime, true);
							}
						}
					if (this._gc && !value) {
						this._enabled(true, false);
					}
					return this;
				};
				var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
					Animation.call(this, 0, vars);
					this.autoRemoveChildren = this.smoothChildTiming = true;
				});
				p = SimpleTimeline.prototype = new Animation();
				p.constructor = SimpleTimeline;
				p.kill()._gc = false;
				p._first = p._last = p._recent = null;
				p._sortChildren = false;
				p.add = p.insert = function (child, position, align, stagger) {
					var prevTween, st;
					child._startTime = Number(position || 0) + child._delay;
					if (child._paused)
						if (this !== child._timeline) {
							child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
						}
					if (child.timeline) {
						child.timeline._remove(child, true);
					}
					child.timeline = child._timeline = this;
					if (child._gc) {
						child._enabled(true, true);
					}
					prevTween = this._last;
					if (this._sortChildren) {
						st = child._startTime;
						while (prevTween && prevTween._startTime > st) {
							prevTween = prevTween._prev;
						}
					}
					if (prevTween) {
						child._next = prevTween._next;
						prevTween._next = child;
					} else {
						child._next = this._first;
						this._first = child;
					}
					if (child._next) {
						child._next._prev = child;
					} else {
						this._last = child;
					}
					child._prev = prevTween;
					this._recent = child;
					if (this._timeline) {
						this._uncache(true);
					}
					return this;
				};
				p._remove = function (tween, skipDisable) {
					if (tween.timeline === this) {
						if (!skipDisable) {
							tween._enabled(false, true);
						}
						if (tween._prev) {
							tween._prev._next = tween._next;
						} else if (this._first === tween) {
							this._first = tween._next;
						}
						if (tween._next) {
							tween._next._prev = tween._prev;
						} else if (this._last === tween) {
							this._last = tween._prev;
						}
						tween._next = tween._prev = tween.timeline = null;
						if (tween === this._recent) {
							this._recent = this._last;
						}
						if (this._timeline) {
							this._uncache(true);
						}
					}
					return this;
				};
				p.render = function (time, suppressEvents, force) {
					var tween = this._first,
						next;
					this._totalTime = this._time = this._rawPrevTime = time;
					while (tween) {
						next = tween._next;
						if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
							if (!tween._reversed) {
								tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
							} else {
								tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
							}
						}
						tween = next;
					}
				};
				p.rawTime = function () {
					if (!_tickerActive) {
						_ticker.wake();
					}
					return this._totalTime;
				};
				var TweenLite = _class("TweenLite", function (target, duration, vars) {
					Animation.call(this, duration, vars);
					this.render = TweenLite.prototype.render;
					if (target == null) {
						throw "Cannot tween a null target.";
					}
					this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
					var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
						overwrite = this.vars.overwrite,
						i, targ, targets;
					this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];
					if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
						this._targets = targets = _slice(target);
						this._propLookup = [];
						this._siblings = [];
						for (i = 0; i < targets.length; i++) {
							targ = targets[i];
							if (!targ) {
								targets.splice(i--, 1);
								continue;
							} else if (typeof targ === "string") {
								targ = targets[i--] = TweenLite.selector(targ);
								if (typeof targ === "string") {
									targets.splice(i + 1, 1);
								}
								continue;
							} else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
								targets.splice(i--, 1);
								this._targets = targets = targets.concat(_slice(targ));
								continue;
							}
							this._siblings[i] = _register(targ, this, false);
							if (overwrite === 1)
								if (this._siblings[i].length > 1) {
									_applyOverwrite(targ, this, null, 1, this._siblings[i]);
								}
						}
					} else {
						this._propLookup = {};
						this._siblings = _register(target, this, false);
						if (overwrite === 1)
							if (this._siblings.length > 1) {
								_applyOverwrite(target, this, null, 1, this._siblings);
							}
					}
					if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
						this._time = -_tinyNum;
						this.render(Math.min(0, -this._delay));
					}
				}, true),
					_isSelector = function _isSelector(v) {
						return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType);
					},
					_autoCSS = function _autoCSS(vars, target) {
						var css = {},
							p;
						for (p in vars) {
							if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
								css[p] = vars[p];
								delete vars[p];
							}
						}
						vars.css = css;
					};
				p = TweenLite.prototype = new Animation();
				p.constructor = TweenLite;
				p.kill()._gc = false;
				p.ratio = 0;
				p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
				p._notifyPluginsOfEnabled = p._lazy = false;
				TweenLite.version = "2.0.1";
				TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
				TweenLite.defaultOverwrite = "auto";
				TweenLite.ticker = _ticker;
				TweenLite.autoSleep = 120;
				TweenLite.lagSmoothing = function (threshold, adjustedLag) {
					_ticker.lagSmoothing(threshold, adjustedLag);
				};
				TweenLite.selector = window.$ || window.jQuery || function (e) {
					var selector = window.$ || window.jQuery;
					if (selector) {
						TweenLite.selector = selector;
						return selector(e);
					}
					if (!_doc) {
						_doc = window.document;
					}
					return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
				};
				var _lazyTweens = [],
					_lazyLookup = {},
					_numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
					_relExp = /[\+-]=-?[\.\d]/,
					_setRatio = function _setRatio(v) {
						var pt = this._firstPT,
							min = 0.000001,
							val;
						while (pt) {
							val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;
							if (pt.m) {
								val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
							} else if (val < min)
								if (val > -min && !pt.blob) {
									val = 0;
								}
							if (!pt.f) {
								pt.t[pt.p] = val;
							} else if (pt.fp) {
								pt.t[pt.p](pt.fp, val);
							} else {
								pt.t[pt.p](val);
							}
							pt = pt._next;
						}
					},
					_blobDif = function _blobDif(start, end, filter, pt) {
						var a = [],
							charIndex = 0,
							s = "",
							color = 0,
							startNums, endNums, num, i, l, nonNumbers, currentNum;
						a.start = start;
						a.end = end;
						start = a[0] = start + "";
						end = a[1] = end + "";
						if (filter) {
							filter(a);
							start = a[0];
							end = a[1];
						}
						a.length = 0;
						startNums = start.match(_numbersExp) || [];
						endNums = end.match(_numbersExp) || [];
						if (pt) {
							pt._next = null;
							pt.blob = 1;
							a._firstPT = a._applyPT = pt;
						}
						l = endNums.length;
						for (i = 0; i < l; i++) {
							currentNum = endNums[i];
							nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
							s += nonNumbers || !i ? nonNumbers : ",";
							charIndex += nonNumbers.length;
							if (color) {
								color = (color + 1) % 5;
							} else if (nonNumbers.substr(-5) === "rgba(") {
								color = 1;
							}
							if (currentNum === startNums[i] || startNums.length <= i) {
								s += currentNum;
							} else {
								if (s) {
									a.push(s);
									s = "";
								}
								num = parseFloat(startNums[i]);
								a.push(num);
								a._firstPT = {
									_next: a._firstPT,
									t: a,
									p: a.length - 1,
									s: num,
									c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
									f: 0,
									m: color && color < 4 ? Math.round : 0
								};
							}
							charIndex += currentNum.length;
						}
						s += end.substr(charIndex);
						if (s) {
							a.push(s);
						}
						a.setRatio = _setRatio;
						if (_relExp.test(end)) {
							a.end = null;
						}
						return a;
					},
					_addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
						if (typeof end === "function") {
							end = end(index || 0, target);
						}
						var type = _typeof(target[prop]),
							getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
							s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
							isRelative = typeof end === "string" && end.charAt(1) === "=",
							pt = {
								t: target,
								p: prop,
								s: s,
								f: type === "function",
								pg: 0,
								n: overwriteProp || prop,
								m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
								pr: 0,
								c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
							},
							blob;
						if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
							if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
								pt.fp = funcParam;
								blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
								pt = {
									t: blob,
									p: "setRatio",
									s: 0,
									c: 1,
									f: 2,
									pg: 0,
									n: overwriteProp || prop,
									pr: 0,
									m: 0
								};
							} else {
								pt.s = parseFloat(s);
								if (!isRelative) {
									pt.c = parseFloat(end) - pt.s || 0;
								}
							}
						}
						if (pt.c) {
							if (pt._next = this._firstPT) {
								pt._next._prev = pt;
							}
							this._firstPT = pt;
							return pt;
						}
					},
					_internals = TweenLite._internals = {
						isArray: _isArray,
						isSelector: _isSelector,
						lazyTweens: _lazyTweens,
						blobDif: _blobDif
					},
					_plugins = TweenLite._plugins = {},
					_tweenLookup = _internals.tweenLookup = {},
					_tweenLookupNum = 0,
					_reservedProps = _internals.reservedProps = {
						ease: 1,
						delay: 1,
						overwrite: 1,
						onComplete: 1,
						onCompleteParams: 1,
						onCompleteScope: 1,
						useFrames: 1,
						runBackwards: 1,
						startAt: 1,
						onUpdate: 1,
						onUpdateParams: 1,
						onUpdateScope: 1,
						onStart: 1,
						onStartParams: 1,
						onStartScope: 1,
						onReverseComplete: 1,
						onReverseCompleteParams: 1,
						onReverseCompleteScope: 1,
						onRepeat: 1,
						onRepeatParams: 1,
						onRepeatScope: 1,
						easeParams: 1,
						yoyo: 1,
						immediateRender: 1,
						repeat: 1,
						repeatDelay: 1,
						data: 1,
						paused: 1,
						reversed: 1,
						autoCSS: 1,
						lazy: 1,
						onOverwrite: 1,
						callbackScope: 1,
						stringFilter: 1,
						id: 1,
						yoyoEase: 1
					},
					_overwriteLookup = {
						none: 0,
						all: 1,
						auto: 2,
						concurrent: 3,
						allOnStart: 4,
						preexisting: 5,
						"true": 1,
						"false": 0
					},
					_rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
					_rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
					_nextGCFrame = 30,
					_lazyRender = _internals.lazyRender = function () {
						var i = _lazyTweens.length,
							tween;
						_lazyLookup = {};
						while (--i > -1) {
							tween = _lazyTweens[i];
							if (tween && tween._lazy !== false) {
								tween.render(tween._lazy[0], tween._lazy[1], true);
								tween._lazy = false;
							}
						}
						_lazyTweens.length = 0;
					};
				_rootTimeline._startTime = _ticker.time;
				_rootFramesTimeline._startTime = _ticker.frame;
				_rootTimeline._active = _rootFramesTimeline._active = true;
				setTimeout(_lazyRender, 1);
				Animation._updateRoot = TweenLite.render = function () {
					var i, a, p;
					if (_lazyTweens.length) {
						_lazyRender();
					}
					_rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
					_rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
					if (_lazyTweens.length) {
						_lazyRender();
					}
					if (_ticker.frame >= _nextGCFrame) {
						_nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
						for (p in _tweenLookup) {
							a = _tweenLookup[p].tweens;
							i = a.length;
							while (--i > -1) {
								if (a[i]._gc) {
									a.splice(i, 1);
								}
							}
							if (a.length === 0) {
								delete _tweenLookup[p];
							}
						}
						p = _rootTimeline._first;
						if (!p || p._paused)
							if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
								while (p && p._paused) {
									p = p._next;
								}
								if (!p) {
									_ticker.sleep();
								}
							}
					}
				};
				_ticker.addEventListener("tick", Animation._updateRoot);
				var _register = function _register(target, tween, scrub) {
					var id = target._gsTweenID,
						a, i;
					if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
						_tweenLookup[id] = {
							target: target,
							tweens: []
						};
					}
					if (tween) {
						a = _tweenLookup[id].tweens;
						a[i = a.length] = tween;
						if (scrub) {
							while (--i > -1) {
								if (a[i] === tween) {
									a.splice(i, 1);
								}
							}
						}
					}
					return _tweenLookup[id].tweens;
				},
					_onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
						var func = overwrittenTween.vars.onOverwrite,
							r1, r2;
						if (func) {
							r1 = func(overwrittenTween, overwritingTween, target, killedProps);
						}
						func = TweenLite.onOverwrite;
						if (func) {
							r2 = func(overwrittenTween, overwritingTween, target, killedProps);
						}
						return r1 !== false && r2 !== false;
					},
					_applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
						var i, changed, curTween, l;
						if (mode === 1 || mode >= 4) {
							l = siblings.length;
							for (i = 0; i < l; i++) {
								if ((curTween = siblings[i]) !== tween) {
									if (!curTween._gc) {
										if (curTween._kill(null, target, tween)) {
											changed = true;
										}
									}
								} else if (mode === 5) {
									break;
								}
							}
							return changed;
						}
						var startTime = tween._startTime + _tinyNum,
							overlaps = [],
							oCount = 0,
							zeroDur = tween._duration === 0,
							globalStart;
						i = siblings.length;
						while (--i > -1) {
							if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) { } else if (curTween._timeline !== tween._timeline) {
								globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
								if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
									overlaps[oCount++] = curTween;
								}
							} else if (curTween._startTime <= startTime)
								if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
									if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
										overlaps[oCount++] = curTween;
									}
						}
						i = oCount;
						while (--i > -1) {
							curTween = overlaps[i];
							if (mode === 2)
								if (curTween._kill(props, target, tween)) {
									changed = true;
								}
							if (mode !== 2 || !curTween._firstPT && curTween._initted) {
								if (mode !== 2 && !_onOverwrite(curTween, tween)) {
									continue;
								}
								if (curTween._enabled(false, false)) {
									changed = true;
								}
							}
						}
						return changed;
					},
					_checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
						var tl = tween._timeline,
							ts = tl._timeScale,
							t = tween._startTime;
						while (tl._timeline) {
							t += tl._startTime;
							ts *= tl._timeScale;
							if (tl._paused) {
								return -100;
							}
							tl = tl._timeline;
						}
						t /= ts;
						return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
					};
				p._init = function () {
					var v = this.vars,
						op = this._overwrittenProps,
						dur = this._duration,
						immediate = !!v.immediateRender,
						ease = v.ease,
						i, initPlugins, pt, p, startVars, l;
					if (v.startAt) {
						if (this._startAt) {
							this._startAt.render(-1, true);
							this._startAt.kill();
						}
						startVars = {};
						for (p in v.startAt) {
							startVars[p] = v.startAt[p];
						}
						startVars.data = "isStart";
						startVars.overwrite = false;
						startVars.immediateRender = true;
						startVars.lazy = immediate && v.lazy !== false;
						startVars.startAt = startVars.delay = null;
						startVars.onUpdate = v.onUpdate;
						startVars.onUpdateParams = v.onUpdateParams;
						startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
						this._startAt = TweenLite.to(this.target || {}, 0, startVars);
						if (immediate) {
							if (this._time > 0) {
								this._startAt = null;
							} else if (dur !== 0) {
								return;
							}
						}
					} else if (v.runBackwards && dur !== 0) {
						if (this._startAt) {
							this._startAt.render(-1, true);
							this._startAt.kill();
							this._startAt = null;
						} else {
							if (this._time !== 0) {
								immediate = false;
							}
							pt = {};
							for (p in v) {
								if (!_reservedProps[p] || p === "autoCSS") {
									pt[p] = v[p];
								}
							}
							pt.overwrite = 0;
							pt.data = "isFromStart";
							pt.lazy = immediate && v.lazy !== false;
							pt.immediateRender = immediate;
							this._startAt = TweenLite.to(this.target, 0, pt);
							if (!immediate) {
								this._startAt._init();
								this._startAt._enabled(false);
								if (this.vars.immediateRender) {
									this._startAt = null;
								}
							} else if (this._time === 0) {
								return;
							}
						}
					}
					this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
					if (v.easeParams instanceof Array && ease.config) {
						this._ease = ease.config.apply(ease, v.easeParams);
					}
					this._easeType = this._ease._type;
					this._easePower = this._ease._power;
					this._firstPT = null;
					if (this._targets) {
						l = this._targets.length;
						for (i = 0; i < l; i++) {
							if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
								initPlugins = true;
							}
						}
					} else {
						initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
					}
					if (initPlugins) {
						TweenLite._onPluginEvent("_onInitAllProps", this);
					}
					if (op)
						if (!this._firstPT)
							if (typeof this.target !== "function") {
								this._enabled(false, false);
							}
					if (v.runBackwards) {
						pt = this._firstPT;
						while (pt) {
							pt.s += pt.c;
							pt.c = -pt.c;
							pt = pt._next;
						}
					}
					this._onUpdate = v.onUpdate;
					this._initted = true;
				};
				p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
					var p, i, initPlugins, plugin, pt, v;
					if (target == null) {
						return false;
					}
					if (_lazyLookup[target._gsTweenID]) {
						_lazyRender();
					}
					if (!this.vars.css)
						if (target.style)
							if (target !== window && target.nodeType)
								if (_plugins.css)
									if (this.vars.autoCSS !== false) {
										_autoCSS(this.vars, target);
									}
					for (p in this.vars) {
						v = this.vars[p];
						if (_reservedProps[p]) {
							if (v)
								if (v instanceof Array || v.push && _isArray(v))
									if (v.join("").indexOf("{self}") !== -1) {
										this.vars[p] = v = this._swapSelfInParams(v, this);
									}
						} else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
							this._firstPT = pt = {
								_next: this._firstPT,
								t: plugin,
								p: "setRatio",
								s: 0,
								c: 1,
								f: 1,
								n: p,
								pg: 1,
								pr: plugin._priority,
								m: 0
							};
							i = plugin._overwriteProps.length;
							while (--i > -1) {
								propLookup[plugin._overwriteProps[i]] = this._firstPT;
							}
							if (plugin._priority || plugin._onInitAllProps) {
								initPlugins = true;
							}
							if (plugin._onDisable || plugin._onEnable) {
								this._notifyPluginsOfEnabled = true;
							}
							if (pt._next) {
								pt._next._prev = pt;
							}
						} else {
							propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
						}
					}
					if (overwrittenProps)
						if (this._kill(overwrittenProps, target)) {
							return this._initProps(target, propLookup, siblings, overwrittenProps, index);
						}
					if (this._overwrite > 1)
						if (this._firstPT)
							if (siblings.length > 1)
								if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
									this._kill(propLookup, target);
									return this._initProps(target, propLookup, siblings, overwrittenProps, index);
								}
					if (this._firstPT)
						if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
							_lazyLookup[target._gsTweenID] = true;
						}
					return initPlugins;
				};
				p.render = function (time, suppressEvents, force) {
					var prevTime = this._time,
						duration = this._duration,
						prevRawPrevTime = this._rawPrevTime,
						isComplete, callback, pt, rawPrevTime;
					if (time >= duration - 0.0000001 && time >= 0) {
						this._totalTime = this._time = duration;
						this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
						if (!this._reversed) {
							isComplete = true;
							callback = "onComplete";
							force = force || this._timeline.autoRemoveChildren;
						}
						if (duration === 0)
							if (this._initted || !this.vars.lazy || force) {
								if (this._startTime === this._timeline._duration) {
									time = 0;
								}
								if (prevRawPrevTime < 0 || time <= 0 && time >= -0.0000001 || prevRawPrevTime === _tinyNum && this.data !== "isPause")
									if (prevRawPrevTime !== time) {
										force = true;
										if (prevRawPrevTime > _tinyNum) {
											callback = "onReverseComplete";
										}
									}
								this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
							}
					} else if (time < 0.0000001) {
						this._totalTime = this._time = 0;
						this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
						if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
							callback = "onReverseComplete";
							isComplete = this._reversed;
						}
						if (time < 0) {
							this._active = false;
							if (duration === 0)
								if (this._initted || !this.vars.lazy || force) {
									if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
										force = true;
									}
									this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum;
								}
						}
						if (!this._initted || this._startAt && this._startAt.progress()) {
							force = true;
						}
					} else {
						this._totalTime = this._time = time;
						if (this._easeType) {
							var r = time / duration,
								type = this._easeType,
								pow = this._easePower;
							if (type === 1 || type === 3 && r >= 0.5) {
								r = 1 - r;
							}
							if (type === 3) {
								r *= 2;
							}
							if (pow === 1) {
								r *= r;
							} else if (pow === 2) {
								r *= r * r;
							} else if (pow === 3) {
								r *= r * r * r;
							} else if (pow === 4) {
								r *= r * r * r * r;
							}
							if (type === 1) {
								this.ratio = 1 - r;
							} else if (type === 2) {
								this.ratio = r;
							} else if (time / duration < 0.5) {
								this.ratio = r / 2;
							} else {
								this.ratio = 1 - r / 2;
							}
						} else {
							this.ratio = this._ease.getRatio(time / duration);
						}
					}
					if (this._time === prevTime && !force) {
						return;
					} else if (!this._initted) {
						this._init();
						if (!this._initted || this._gc) {
							return;
						} else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
							this._time = this._totalTime = prevTime;
							this._rawPrevTime = prevRawPrevTime;
							_lazyTweens.push(this);
							this._lazy = [time, suppressEvents];
							return;
						}
						if (this._time && !isComplete) {
							this.ratio = this._ease.getRatio(this._time / duration);
						} else if (isComplete && this._ease._calcEnd) {
							this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
						}
					}
					if (this._lazy !== false) {
						this._lazy = false;
					}
					if (!this._active)
						if (!this._paused && this._time !== prevTime && time >= 0) {
							this._active = true;
						}
					if (prevTime === 0) {
						if (this._startAt) {
							if (time >= 0) {
								this._startAt.render(time, true, force);
							} else if (!callback) {
								callback = "_dummyGS";
							}
						}
						if (this.vars.onStart)
							if (this._time !== 0 || duration === 0)
								if (!suppressEvents) {
									this._callback("onStart");
								}
					}
					pt = this._firstPT;
					while (pt) {
						if (pt.f) {
							pt.t[pt.p](pt.c * this.ratio + pt.s);
						} else {
							pt.t[pt.p] = pt.c * this.ratio + pt.s;
						}
						pt = pt._next;
					}
					if (this._onUpdate) {
						if (time < 0)
							if (this._startAt && time !== -0.0001) {
								this._startAt.render(time, true, force);
							}
						if (!suppressEvents)
							if (this._time !== prevTime || isComplete || force) {
								this._callback("onUpdate");
							}
					}
					if (callback)
						if (!this._gc || force) {
							if (time < 0 && this._startAt && !this._onUpdate && time !== -0.0001) {
								this._startAt.render(time, true, force);
							}
							if (isComplete) {
								if (this._timeline.autoRemoveChildren) {
									this._enabled(false, false);
								}
								this._active = false;
							}
							if (!suppressEvents && this.vars[callback]) {
								this._callback(callback);
							}
							if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
								this._rawPrevTime = 0;
							}
						}
				};
				p._kill = function (vars, target, overwritingTween) {
					if (vars === "all") {
						vars = null;
					}
					if (vars == null)
						if (target == null || target === this.target) {
							this._lazy = false;
							return this._enabled(false, false);
						}
					target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
					var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
						i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed;
					if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
						i = target.length;
						while (--i > -1) {
							if (this._kill(vars, target[i], overwritingTween)) {
								changed = true;
							}
						}
					} else {
						if (this._targets) {
							i = this._targets.length;
							while (--i > -1) {
								if (target === this._targets[i]) {
									propLookup = this._propLookup[i] || {};
									this._overwrittenProps = this._overwrittenProps || [];
									overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
									break;
								}
							}
						} else if (target !== this.target) {
							return false;
						} else {
							propLookup = this._propLookup;
							overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
						}
						if (propLookup) {
							killProps = vars || propLookup;
							record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && ((typeof vars === "undefined" ? "undefined" : _typeof(vars)) !== "object" || !vars._tempKill);
							if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
								for (p in killProps) {
									if (propLookup[p]) {
										if (!killed) {
											killed = [];
										}
										killed.push(p);
									}
								}
								if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
									return false;
								}
							}
							for (p in killProps) {
								if (pt = propLookup[p]) {
									if (simultaneousOverwrite) {
										if (pt.f) {
											pt.t[pt.p](pt.s);
										} else {
											pt.t[pt.p] = pt.s;
										}
										changed = true;
									}
									if (pt.pg && pt.t._kill(killProps)) {
										changed = true;
									}
									if (!pt.pg || pt.t._overwriteProps.length === 0) {
										if (pt._prev) {
											pt._prev._next = pt._next;
										} else if (pt === this._firstPT) {
											this._firstPT = pt._next;
										}
										if (pt._next) {
											pt._next._prev = pt._prev;
										}
										pt._next = pt._prev = null;
									}
									delete propLookup[p];
								}
								if (record) {
									overwrittenProps[p] = 1;
								}
							}
							if (!this._firstPT && this._initted) {
								this._enabled(false, false);
							}
						}
					}
					return changed;
				};
				p.invalidate = function () {
					if (this._notifyPluginsOfEnabled) {
						TweenLite._onPluginEvent("_onDisable", this);
					}
					this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
					this._notifyPluginsOfEnabled = this._active = this._lazy = false;
					this._propLookup = this._targets ? {} : [];
					Animation.prototype.invalidate.call(this);
					if (this.vars.immediateRender) {
						this._time = -_tinyNum;
						this.render(Math.min(0, -this._delay));
					}
					return this;
				};
				p._enabled = function (enabled, ignoreTimeline) {
					if (!_tickerActive) {
						_ticker.wake();
					}
					if (enabled && this._gc) {
						var targets = this._targets,
							i;
						if (targets) {
							i = targets.length;
							while (--i > -1) {
								this._siblings[i] = _register(targets[i], this, true);
							}
						} else {
							this._siblings = _register(this.target, this, true);
						}
					}
					Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
					if (this._notifyPluginsOfEnabled)
						if (this._firstPT) {
							return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
						}
					return false;
				};
				TweenLite.to = function (target, duration, vars) {
					return new TweenLite(target, duration, vars);
				};
				TweenLite.from = function (target, duration, vars) {
					vars.runBackwards = true;
					vars.immediateRender = vars.immediateRender != false;
					return new TweenLite(target, duration, vars);
				};
				TweenLite.fromTo = function (target, duration, fromVars, toVars) {
					toVars.startAt = fromVars;
					toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
					return new TweenLite(target, duration, toVars);
				};
				TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
					return new TweenLite(callback, 0, {
						delay: delay,
						onComplete: callback,
						onCompleteParams: params,
						callbackScope: scope,
						onReverseComplete: callback,
						onReverseCompleteParams: params,
						immediateRender: false,
						lazy: false,
						useFrames: useFrames,
						overwrite: 0
					});
				};
				TweenLite.set = function (target, vars) {
					return new TweenLite(target, 0, vars);
				};
				TweenLite.getTweensOf = function (target, onlyActive) {
					if (target == null) {
						return [];
					}
					target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
					var i, a, j, t;
					if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
						i = target.length;
						a = [];
						while (--i > -1) {
							a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
						}
						i = a.length;
						while (--i > -1) {
							t = a[i];
							j = i;
							while (--j > -1) {
								if (t === a[j]) {
									a.splice(i, 1);
								}
							}
						}
					} else if (target._gsTweenID) {
						a = _register(target).concat();
						i = a.length;
						while (--i > -1) {
							if (a[i]._gc || onlyActive && !a[i].isActive()) {
								a.splice(i, 1);
							}
						}
					}
					return a || [];
				};
				TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
					if ((typeof onlyActive === "undefined" ? "undefined" : _typeof(onlyActive)) === "object") {
						vars = onlyActive;
						onlyActive = false;
					}
					var a = TweenLite.getTweensOf(target, onlyActive),
						i = a.length;
					while (--i > -1) {
						a[i]._kill(vars, target);
					}
				};
				var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
					this._overwriteProps = (props || "").split(",");
					this._propName = this._overwriteProps[0];
					this._priority = priority || 0;
					this._super = TweenPlugin.prototype;
				}, true);
				p = TweenPlugin.prototype;
				TweenPlugin.version = "1.19.0";
				TweenPlugin.API = 2;
				p._firstPT = null;
				p._addTween = _addPropTween;
				p.setRatio = _setRatio;
				p._kill = function (lookup) {
					var a = this._overwriteProps,
						pt = this._firstPT,
						i;
					if (lookup[this._propName] != null) {
						this._overwriteProps = [];
					} else {
						i = a.length;
						while (--i > -1) {
							if (lookup[a[i]] != null) {
								a.splice(i, 1);
							}
						}
					}
					while (pt) {
						if (lookup[pt.n] != null) {
							if (pt._next) {
								pt._next._prev = pt._prev;
							}
							if (pt._prev) {
								pt._prev._next = pt._next;
								pt._prev = null;
							} else if (this._firstPT === pt) {
								this._firstPT = pt._next;
							}
						}
						pt = pt._next;
					}
					return false;
				};
				p._mod = p._roundProps = function (lookup) {
					var pt = this._firstPT,
						val;
					while (pt) {
						val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];
						if (val && typeof val === "function") {
							if (pt.f === 2) {
								pt.t._applyPT.m = val;
							} else {
								pt.m = val;
							}
						}
						pt = pt._next;
					}
				};
				TweenLite._onPluginEvent = function (type, tween) {
					var pt = tween._firstPT,
						changed, pt2, first, last, next;
					if (type === "_onInitAllProps") {
						while (pt) {
							next = pt._next;
							pt2 = first;
							while (pt2 && pt2.pr > pt.pr) {
								pt2 = pt2._next;
							}
							if (pt._prev = pt2 ? pt2._prev : last) {
								pt._prev._next = pt;
							} else {
								first = pt;
							}
							if (pt._next = pt2) {
								pt2._prev = pt;
							} else {
								last = pt;
							}
							pt = next;
						}
						pt = tween._firstPT = first;
					}
					while (pt) {
						if (pt.pg)
							if (typeof pt.t[type] === "function")
								if (pt.t[type]()) {
									changed = true;
								}
						pt = pt._next;
					}
					return changed;
				};
				TweenPlugin.activate = function (plugins) {
					var i = plugins.length;
					while (--i > -1) {
						if (plugins[i].API === TweenPlugin.API) {
							_plugins[new plugins[i]()._propName] = plugins[i];
						}
					}
					return true;
				};
				_gsDefine.plugin = function (config) {
					if (!config || !config.propName || !config.init || !config.API) {
						throw "illegal plugin definition.";
					}
					var propName = config.propName,
						priority = config.priority || 0,
						overwriteProps = config.overwriteProps,
						map = {
							init: "_onInitTween",
							set: "setRatio",
							kill: "_kill",
							round: "_mod",
							mod: "_mod",
							initAll: "_onInitAllProps"
						},
						Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
							TweenPlugin.call(this, propName, priority);
							this._overwriteProps = overwriteProps || [];
						}, config.global === true),
						p = Plugin.prototype = new TweenPlugin(propName),
						prop;
					p.constructor = Plugin;
					Plugin.API = config.API;
					for (prop in map) {
						if (typeof config[prop] === "function") {
							p[map[prop]] = config[prop];
						}
					}
					Plugin.version = config.version;
					TweenPlugin.activate([Plugin]);
					return Plugin;
				};
				a = window._gsQueue;
				if (a) {
					for (i = 0; i < a.length; i++) {
						a[i]();
					}
					for (p in _defLookup) {
						if (!_defLookup[p].func) {
							window.console.log("GSAP encountered missing dependency: " + p);
						}
					}
				}
				_tickerActive = false;
			})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : undefined || window, "TweenLite");
		}.call(exports, __webpack_require__(1)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		/*!
		 * jQuery Mousewheel 3.1.13
		 *
		 * Copyright jQuery Foundation and other contributors
		 * Released under the MIT license
		 * http://jquery.org/license
		 */
		(function (factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				module.exports = factory;
			} else {
				factory(jQuery);
			}
		})(function ($) {
			var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
				toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
				slice = Array.prototype.slice,
				nullLowestDeltaTimeout, lowestDelta;
			if ($.event.fixHooks) {
				for (var i = toFix.length; i;) {
					$.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
				}
			}
			var special = $.event.special.mousewheel = {
				version: '3.1.12',
				setup: function setup() {
					if (this.addEventListener) {
						for (var i = toBind.length; i;) {
							this.addEventListener(toBind[--i], handler, false);
						}
					} else {
						this.onmousewheel = handler;
					}
					$.data(this, 'mousewheel-line-height', special.getLineHeight(this));
					$.data(this, 'mousewheel-page-height', special.getPageHeight(this));
				},
				teardown: function teardown() {
					if (this.removeEventListener) {
						for (var i = toBind.length; i;) {
							this.removeEventListener(toBind[--i], handler, false);
						}
					} else {
						this.onmousewheel = null;
					}
					$.removeData(this, 'mousewheel-line-height');
					$.removeData(this, 'mousewheel-page-height');
				},
				getLineHeight: function getLineHeight(elem) {
					var $elem = $(elem),
						$parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
					if (!$parent.length) {
						$parent = $('body');
					}
					return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
				},
				getPageHeight: function getPageHeight(elem) {
					return $(elem).height();
				},
				settings: {
					adjustOldDeltas: true,
					normalizeOffset: true
				}
			};
			$.fn.extend({
				mousewheel: function mousewheel(fn) {
					return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
				},
				unmousewheel: function unmousewheel(fn) {
					return this.unbind('mousewheel', fn);
				}
			});

			function handler(event) {
				var orgEvent = event || window.event,
					args = slice.call(arguments, 1),
					delta = 0,
					deltaX = 0,
					deltaY = 0,
					absDelta = 0,
					offsetX = 0,
					offsetY = 0;
				event = $.event.fix(orgEvent);
				event.type = 'mousewheel';
				if ('detail' in orgEvent) {
					deltaY = orgEvent.detail * -1;
				}
				if ('wheelDelta' in orgEvent) {
					deltaY = orgEvent.wheelDelta;
				}
				if ('wheelDeltaY' in orgEvent) {
					deltaY = orgEvent.wheelDeltaY;
				}
				if ('wheelDeltaX' in orgEvent) {
					deltaX = orgEvent.wheelDeltaX * -1;
				}
				if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
					deltaX = deltaY * -1;
					deltaY = 0;
				}
				delta = deltaY === 0 ? deltaX : deltaY;
				if ('deltaY' in orgEvent) {
					deltaY = orgEvent.deltaY * -1;
					delta = deltaY;
				}
				if ('deltaX' in orgEvent) {
					deltaX = orgEvent.deltaX;
					if (deltaY === 0) {
						delta = deltaX * -1;
					}
				}
				if (deltaY === 0 && deltaX === 0) {
					return;
				}
				if (orgEvent.deltaMode === 1) {
					var lineHeight = $.data(this, 'mousewheel-line-height');
					delta *= lineHeight;
					deltaY *= lineHeight;
					deltaX *= lineHeight;
				} else if (orgEvent.deltaMode === 2) {
					var pageHeight = $.data(this, 'mousewheel-page-height');
					delta *= pageHeight;
					deltaY *= pageHeight;
					deltaX *= pageHeight;
				}
				absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
				if (!lowestDelta || absDelta < lowestDelta) {
					lowestDelta = absDelta;
					if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
						lowestDelta /= 40;
					}
				}
				if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
					delta /= 40;
					deltaX /= 40;
					deltaY /= 40;
				}
				delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
				deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
				deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);
				if (special.settings.normalizeOffset && this.getBoundingClientRect) {
					var boundingRect = this.getBoundingClientRect();
					offsetX = event.clientX - boundingRect.left;
					offsetY = event.clientY - boundingRect.top;
				}
				event.deltaX = deltaX;
				event.deltaY = deltaY;
				event.deltaFactor = lowestDelta;
				event.offsetX = offsetX;
				event.offsetY = offsetY;
				event.deltaMode = 0;
				args.unshift(event, delta, deltaX, deltaY);
				if (nullLowestDeltaTimeout) {
					clearTimeout(nullLowestDeltaTimeout);
				}
				nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
				return ($.event.dispatch || $.event.handle).apply(this, args);
			}

			function nullLowestDelta() {
				lowestDelta = null;
			}

			function shouldAdjustOldDeltas(orgEvent, absDelta) {
				return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
			}
		});
	}), (function (module, exports, __webpack_require__) {
		__webpack_require__(7);
		__webpack_require__(8);
		__webpack_require__(9);
		module.exports = __webpack_require__(10);
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		module.exports = function () {
			if (Element && !Element.prototype.matches) {
				Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;
			}
		}();
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (ElementProto) {
			if (typeof ElementProto.matches !== 'function') {
				ElementProto.matches = ElementProto.msMatchesSelector || ElementProto.mozMatchesSelector || ElementProto.webkitMatchesSelector || function matches(selector) {
					var element = this;
					var elements = (element.document || element.ownerDocument).querySelectorAll(selector);
					var index = 0;
					while (elements[index] && elements[index] !== element) {
						++index;
					}
					return Boolean(elements[index]);
				};
			}
			if (typeof ElementProto.closest !== 'function') {
				ElementProto.closest = function closest(selector) {
					var element = this;
					while (element && element.nodeType === 1) {
						if (element.matches(selector)) {
							return element;
						}
						element = element.parentNode;
					}
					return null;
				};
			}
		})(window.Element.prototype);
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		if (window.NodeList && !NodeList.prototype.forEach) {
			NodeList.prototype.forEach = function (callback, thisArg) {
				thisArg = thisArg || window;
				for (var i = 0; i < this.length; i++) {
					callback.call(thisArg, this[i], i, this);
				}
			};
		}
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (global) {
			var _jquery = __webpack_require__(0);
			var _jquery2 = _interopRequireDefault(_jquery);
			__webpack_require__(12);
			__webpack_require__(13);
			__webpack_require__(14);
			var _sliders = __webpack_require__(15);
			var _sliders2 = _interopRequireDefault(_sliders);
			var _countdown = __webpack_require__(16);
			var _countdown2 = _interopRequireDefault(_countdown);
			var _map = __webpack_require__(17);
			var _map2 = _interopRequireDefault(_map);
			var _svg = __webpack_require__(18);
			var _svg2 = _interopRequireDefault(_svg);
			var _svgUseIt = __webpack_require__(19);
			var _svgUseIt2 = _interopRequireDefault(_svgUseIt);
			var _main = __webpack_require__(20);
			var _main2 = _interopRequireDefault(_main);
			__webpack_require__(21);
			var _animation = __webpack_require__(22);
			var _animation2 = _interopRequireDefault(_animation);
			var _popup = __webpack_require__(26);
			var _popup2 = _interopRequireDefault(_popup);
			var _socialLikes = __webpack_require__(27);
			var _socialLikes2 = _interopRequireDefault(_socialLikes);
			var _malihuCustomScrollbarPlugin = __webpack_require__(28);
			var _malihuCustomScrollbarPlugin2 = _interopRequireDefault(_malihuCustomScrollbarPlugin);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : {
					default: obj
				};
			}
			__webpack_require__(5);
			global.$ = global.jquery = _jquery2.default;
			document.addEventListener("DOMContentLoaded", function () {
				(0, _sliders2.default)();
				(0, _countdown2.default)();
				(0, _map2.default)();
				(0, _svg2.default)();
				(0, _svgUseIt2.default)();
				if ((0, _jquery2.default)(window).width() >= 1120) {
					(0, _animation2.default)();
				}
				(0, _main2.default)();
				(0, _popup2.default)();
				(0, _jquery2.default)('.main-text__info, .course-reviews__caption, .scroll-info').mCustomScrollbar();
				if ((0, _jquery2.default)(window).width() <= 1120) {
					(0, _jquery2.default)('.footer__contacts').after((0, _jquery2.default)('.site-footer'));
				} else {
					(0, _jquery2.default)('.map-2').after((0, _jquery2.default)('.site-footer'));
				}
				(0, _jquery2.default)(window).on('resize', function () {
					if ((0, _jquery2.default)(window).width() <= 1120) {
						(0, _jquery2.default)('.footer__contacts').after((0, _jquery2.default)('.site-footer'));
					} else {
						(0, _jquery2.default)('.map-2').after((0, _jquery2.default)('.site-footer'));
					}
				});
				(0, _jquery2.default)('.main-text__info, .course-content__text').mCustomScrollbar();
				(0, _jquery2.default)('input[type="tel"]').mask("+38(099) 999-99-99");
				var icon = void 0;
				(0, _jquery2.default)('.course-section__people-item.active').on('click', function () {
					icon = (0, _jquery2.default)(this);
					(0, _jquery2.default)(this).removeClass('active');
					(0, _jquery2.default)(this).addClass('temp');
					(0, _jquery2.default)(this).parents('.course-section__info').find('input[type="tel"]').trigger('focus');
				});
				(0, _jquery2.default)('.course-section__info input[type="tel"]').on('blur', function () {
					(0, _jquery2.default)('.course-section__people-item.temp').addClass('active');
					(0, _jquery2.default)('.course-section__people-item.temp').removeClass('temp');
				});
				var video = (0, _jquery2.default)('.top-section--instructor').find("video");
				var videoMute = false;
				(0, _jquery2.default)(document).on("click", ".mute", function (event) {
					event.stopPropagation();
					if (!videoMute) {
						video.prop("muted", false);
						(0, _jquery2.default)(this).removeClass("disable");
					} else {
						video.prop("muted", true);
						(0, _jquery2.default)(this).toggleClass("disable");
					}
					videoMute = !videoMute;
				});
				(0, _jquery2.default)(window).on("scroll", function () {
					if ((0, _jquery2.default)(this).scrollTop() > (0, _jquery2.default)('.top-section--instructor').height()) {
						(0, _jquery2.default)('.top-section--instructor').find("video").prop("muted", true);
						(0, _jquery2.default)('.instructor-heading .mute').addClass('disable');
						videoMute = false;
					}
				});
				(0, _jquery2.default)('.instructor__btn').on('click', function () {
					(0, _jquery2.default)(this).parents('.instructor__box').find('.pop-up').addClass('active');
				});
				if ((0, _jquery2.default)(window).width() < 768) {
					(0, _jquery2.default)('.navigation__item-big.parent').append((0, _jquery2.default)('.curs-sub'));
				};
				setInterval(function () {
					(0, _jquery2.default)('.order-btn').addClass('animate');
					setTimeout(function () {
						(0, _jquery2.default)('.order-btn').removeClass('animate');
					}, 5000);
				}, 10000);
			});
		}.call(exports, __webpack_require__(1)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		module.exports = function (module) {
			if (!module.webpackPolyfill) {
				module.deprecate = function () { };
				module.paths = [];
				if (!module.children) module.children = [];
				Object.defineProperty(module, "loaded", {
					enumerable: true,
					get: function get() {
						return module.l;
					}
				});
				Object.defineProperty(module, "id", {
					enumerable: true,
					get: function get() {
						return module.i;
					}
				});
				module.webpackPolyfill = 1;
			}
			return module;
		};
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};;
		(function (factory) {
			'use strict';
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if (typeof exports !== 'undefined') {
				module.exports = factory(require('jquery'));
			} else {
				factory(jQuery);
			}
		})(function ($) {
			'use strict';
			var Slick = window.Slick || {};
			Slick = function () {
				var instanceUid = 0;

				function Slick(element, settings) {
					var _ = this,
						dataSettings;
					_.defaults = {
						accessibility: true,
						adaptiveHeight: false,
						appendArrows: $(element),
						appendDots: $(element),
						arrows: true,
						asNavFor: null,
						prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
						nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
						autoplay: false,
						autoplaySpeed: 3000,
						centerMode: false,
						centerPadding: '50px',
						cssEase: 'ease',
						customPaging: function customPaging(slider, i) {
							return $('<button type="button" />').text(i + 1);
						},
						dots: false,
						dotsClass: 'slick-dots',
						draggable: true,
						easing: 'linear',
						edgeFriction: 0.35,
						fade: false,
						focusOnSelect: false,
						focusOnChange: false,
						infinite: true,
						initialSlide: 0,
						lazyLoad: 'ondemand',
						mobileFirst: false,
						pauseOnHover: true,
						pauseOnFocus: true,
						pauseOnDotsHover: false,
						respondTo: 'window',
						responsive: null,
						rows: 1,
						rtl: false,
						slide: '',
						slidesPerRow: 1,
						slidesToShow: 1,
						slidesToScroll: 1,
						speed: 500,
						swipe: true,
						swipeToSlide: false,
						touchMove: true,
						touchThreshold: 5,
						useCSS: true,
						useTransform: true,
						variableWidth: false,
						vertical: false,
						verticalSwiping: false,
						waitForAnimate: true,
						zIndex: 1000
					};
					_.initials = {
						animating: false,
						dragging: false,
						autoPlayTimer: null,
						currentDirection: 0,
						currentLeft: null,
						currentSlide: 0,
						direction: 1,
						$dots: null,
						listWidth: null,
						listHeight: null,
						loadIndex: 0,
						$nextArrow: null,
						$prevArrow: null,
						scrolling: false,
						slideCount: null,
						slideWidth: null,
						$slideTrack: null,
						$slides: null,
						sliding: false,
						slideOffset: 0,
						swipeLeft: null,
						swiping: false,
						$list: null,
						touchObject: {},
						transformsEnabled: false,
						unslicked: false
					};
					$.extend(_, _.initials);
					_.activeBreakpoint = null;
					_.animType = null;
					_.animProp = null;
					_.breakpoints = [];
					_.breakpointSettings = [];
					_.cssTransitions = false;
					_.focussed = false;
					_.interrupted = false;
					_.hidden = 'hidden';
					_.paused = true;
					_.positionProp = null;
					_.respondTo = null;
					_.rowCount = 1;
					_.shouldClick = true;
					_.$slider = $(element);
					_.$slidesCache = null;
					_.transformType = null;
					_.transitionType = null;
					_.visibilityChange = 'visibilitychange';
					_.windowWidth = 0;
					_.windowTimer = null;
					dataSettings = $(element).data('slick') || {};
					_.options = $.extend({}, _.defaults, settings, dataSettings);
					_.currentSlide = _.options.initialSlide;
					_.originalSettings = _.options;
					if (typeof document.mozHidden !== 'undefined') {
						_.hidden = 'mozHidden';
						_.visibilityChange = 'mozvisibilitychange';
					} else if (typeof document.webkitHidden !== 'undefined') {
						_.hidden = 'webkitHidden';
						_.visibilityChange = 'webkitvisibilitychange';
					}
					_.autoPlay = $.proxy(_.autoPlay, _);
					_.autoPlayClear = $.proxy(_.autoPlayClear, _);
					_.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
					_.changeSlide = $.proxy(_.changeSlide, _);
					_.clickHandler = $.proxy(_.clickHandler, _);
					_.selectHandler = $.proxy(_.selectHandler, _);
					_.setPosition = $.proxy(_.setPosition, _);
					_.swipeHandler = $.proxy(_.swipeHandler, _);
					_.dragHandler = $.proxy(_.dragHandler, _);
					_.keyHandler = $.proxy(_.keyHandler, _);
					_.instanceUid = instanceUid++;
					_.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;
					_.registerBreakpoints();
					_.init(true);
				}
				return Slick;
			}();
			Slick.prototype.activateADA = function () {
				var _ = this;
				_.$slideTrack.find('.slick-active').attr({
					'aria-hidden': 'false'
				}).find('a, input, button, select').attr({
					'tabindex': '0'
				});
			};
			Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {
				var _ = this;
				if (typeof index === 'boolean') {
					addBefore = index;
					index = null;
				} else if (index < 0 || index >= _.slideCount) {
					return false;
				}
				_.unload();
				if (typeof index === 'number') {
					if (index === 0 && _.$slides.length === 0) {
						$(markup).appendTo(_.$slideTrack);
					} else if (addBefore) {
						$(markup).insertBefore(_.$slides.eq(index));
					} else {
						$(markup).insertAfter(_.$slides.eq(index));
					}
				} else {
					if (addBefore === true) {
						$(markup).prependTo(_.$slideTrack);
					} else {
						$(markup).appendTo(_.$slideTrack);
					}
				}
				_.$slides = _.$slideTrack.children(this.options.slide);
				_.$slideTrack.children(this.options.slide).detach();
				_.$slideTrack.append(_.$slides);
				_.$slides.each(function (index, element) {
					$(element).attr('data-slick-index', index);
				});
				_.$slidesCache = _.$slides;
				_.reinit();
			};
			Slick.prototype.animateHeight = function () {
				var _ = this;
				if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
					var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
					_.$list.animate({
						height: targetHeight
					}, _.options.speed);
				}
			};
			Slick.prototype.animateSlide = function (targetLeft, callback) {
				var animProps = {},
					_ = this;
				_.animateHeight();
				if (_.options.rtl === true && _.options.vertical === false) {
					targetLeft = -targetLeft;
				}
				if (_.transformsEnabled === false) {
					if (_.options.vertical === false) {
						_.$slideTrack.animate({
							left: targetLeft
						}, _.options.speed, _.options.easing, callback);
					} else {
						_.$slideTrack.animate({
							top: targetLeft
						}, _.options.speed, _.options.easing, callback);
					}
				} else {
					if (_.cssTransitions === false) {
						if (_.options.rtl === true) {
							_.currentLeft = -_.currentLeft;
						}
						$({
							animStart: _.currentLeft
						}).animate({
							animStart: targetLeft
						}, {
							duration: _.options.speed,
							easing: _.options.easing,
							step: function step(now) {
								now = Math.ceil(now);
								if (_.options.vertical === false) {
									animProps[_.animType] = 'translate(' + now + 'px, 0px)';
									_.$slideTrack.css(animProps);
								} else {
									animProps[_.animType] = 'translate(0px,' + now + 'px)';
									_.$slideTrack.css(animProps);
								}
							},
							complete: function complete() {
								if (callback) {
									callback.call();
								}
							}
						});
					} else {
						_.applyTransition();
						targetLeft = Math.ceil(targetLeft);
						if (_.options.vertical === false) {
							animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
						} else {
							animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
						}
						_.$slideTrack.css(animProps);
						if (callback) {
							setTimeout(function () {
								_.disableTransition();
								callback.call();
							}, _.options.speed);
						}
					}
				}
			};
			Slick.prototype.getNavTarget = function () {
				var _ = this,
					asNavFor = _.options.asNavFor;
				if (asNavFor && asNavFor !== null) {
					asNavFor = $(asNavFor).not(_.$slider);
				}
				return asNavFor;
			};
			Slick.prototype.asNavFor = function (index) {
				var _ = this,
					asNavFor = _.getNavTarget();
				if (asNavFor !== null && (typeof asNavFor === 'undefined' ? 'undefined' : _typeof(asNavFor)) === 'object') {
					asNavFor.each(function () {
						var target = $(this).slick('getSlick');
						if (!target.unslicked) {
							target.slideHandler(index, true);
						}
					});
				}
			};
			Slick.prototype.applyTransition = function (slide) {
				var _ = this,
					transition = {};
				if (_.options.fade === false) {
					transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
				} else {
					transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
				}
				if (_.options.fade === false) {
					_.$slideTrack.css(transition);
				} else {
					_.$slides.eq(slide).css(transition);
				}
			};
			Slick.prototype.autoPlay = function () {
				var _ = this;
				_.autoPlayClear();
				if (_.slideCount > _.options.slidesToShow) {
					_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
				}
			};
			Slick.prototype.autoPlayClear = function () {
				var _ = this;
				if (_.autoPlayTimer) {
					clearInterval(_.autoPlayTimer);
				}
			};
			Slick.prototype.autoPlayIterator = function () {
				var _ = this,
					slideTo = _.currentSlide + _.options.slidesToScroll;
				if (!_.paused && !_.interrupted && !_.focussed) {
					if (_.options.infinite === false) {
						if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
							_.direction = 0;
						} else if (_.direction === 0) {
							slideTo = _.currentSlide - _.options.slidesToScroll;
							if (_.currentSlide - 1 === 0) {
								_.direction = 1;
							}
						}
					}
					_.slideHandler(slideTo);
				}
			};
			Slick.prototype.buildArrows = function () {
				var _ = this;
				if (_.options.arrows === true) {
					_.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
					_.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');
					if (_.slideCount > _.options.slidesToShow) {
						_.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
						_.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
						if (_.htmlExpr.test(_.options.prevArrow)) {
							_.$prevArrow.prependTo(_.options.appendArrows);
						}
						if (_.htmlExpr.test(_.options.nextArrow)) {
							_.$nextArrow.appendTo(_.options.appendArrows);
						}
						if (_.options.infinite !== true) {
							_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
						}
					} else {
						_.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
							'aria-disabled': 'true',
							'tabindex': '-1'
						});
					}
				}
			};
			Slick.prototype.buildDots = function () {
				var _ = this,
					i, dot;
				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$slider.addClass('slick-dotted');
					dot = $('<ul />').addClass(_.options.dotsClass);
					for (i = 0; i <= _.getDotCount(); i += 1) {
						dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
					}
					_.$dots = dot.appendTo(_.options.appendDots);
					_.$dots.find('li').first().addClass('slick-active');
				}
			};
			Slick.prototype.buildOut = function () {
				var _ = this;
				_.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');
				_.slideCount = _.$slides.length;
				_.$slides.each(function (index, element) {
					$(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
				});
				_.$slider.addClass('slick-slider');
				_.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
				_.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();
				_.$slideTrack.css('opacity', 0);
				if (_.options.centerMode === true || _.options.swipeToSlide === true) {
					_.options.slidesToScroll = 1;
				}
				$('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');
				_.setupInfinite();
				_.buildArrows();
				_.buildDots();
				_.updateDots();
				_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);
				if (_.options.draggable === true) {
					_.$list.addClass('draggable');
				}
			};
			Slick.prototype.buildRows = function () {
				var _ = this,
					a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection;
				newSlides = document.createDocumentFragment();
				originalSlides = _.$slider.children();
				if (_.options.rows > 0) {
					slidesPerSection = _.options.slidesPerRow * _.options.rows;
					numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);
					for (a = 0; a < numOfSlides; a++) {
						var slide = document.createElement('div');
						for (b = 0; b < _.options.rows; b++) {
							var row = document.createElement('div');
							for (c = 0; c < _.options.slidesPerRow; c++) {
								var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
								if (originalSlides.get(target)) {
									row.appendChild(originalSlides.get(target));
								}
							}
							slide.appendChild(row);
						}
						newSlides.appendChild(slide);
					}
					_.$slider.empty().append(newSlides);
					_.$slider.children().children().children().css({
						'width': 100 / _.options.slidesPerRow + '%',
						'display': 'inline-block'
					});
				}
			};
			Slick.prototype.checkResponsive = function (initial, forceUpdate) {
				var _ = this,
					breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
				var sliderWidth = _.$slider.width();
				var windowWidth = window.innerWidth || $(window).width();
				if (_.respondTo === 'window') {
					respondToWidth = windowWidth;
				} else if (_.respondTo === 'slider') {
					respondToWidth = sliderWidth;
				} else if (_.respondTo === 'min') {
					respondToWidth = Math.min(windowWidth, sliderWidth);
				}
				if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {
					targetBreakpoint = null;
					for (breakpoint in _.breakpoints) {
						if (_.breakpoints.hasOwnProperty(breakpoint)) {
							if (_.originalSettings.mobileFirst === false) {
								if (respondToWidth < _.breakpoints[breakpoint]) {
									targetBreakpoint = _.breakpoints[breakpoint];
								}
							} else {
								if (respondToWidth > _.breakpoints[breakpoint]) {
									targetBreakpoint = _.breakpoints[breakpoint];
								}
							}
						}
					}
					if (targetBreakpoint !== null) {
						if (_.activeBreakpoint !== null) {
							if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
								_.activeBreakpoint = targetBreakpoint;
								if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
									_.unslick(targetBreakpoint);
								} else {
									_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
									if (initial === true) {
										_.currentSlide = _.options.initialSlide;
									}
									_.refresh(initial);
								}
								triggerBreakpoint = targetBreakpoint;
							}
						} else {
							_.activeBreakpoint = targetBreakpoint;
							if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
								_.unslick(targetBreakpoint);
							} else {
								_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
								if (initial === true) {
									_.currentSlide = _.options.initialSlide;
								}
								_.refresh(initial);
							}
							triggerBreakpoint = targetBreakpoint;
						}
					} else {
						if (_.activeBreakpoint !== null) {
							_.activeBreakpoint = null;
							_.options = _.originalSettings;
							if (initial === true) {
								_.currentSlide = _.options.initialSlide;
							}
							_.refresh(initial);
							triggerBreakpoint = targetBreakpoint;
						}
					}
					if (!initial && triggerBreakpoint !== false) {
						_.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
					}
				}
			};
			Slick.prototype.changeSlide = function (event, dontAnimate) {
				var _ = this,
					$target = $(event.currentTarget),
					indexOffset, slideOffset, unevenOffset;
				if ($target.is('a')) {
					event.preventDefault();
				}
				if (!$target.is('li')) {
					$target = $target.closest('li');
				}
				unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
				indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;
				switch (event.data.message) {
					case 'previous':
						slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
						if (_.slideCount > _.options.slidesToShow) {
							_.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
						}
						break;
					case 'next':
						slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
						if (_.slideCount > _.options.slidesToShow) {
							_.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
						}
						break;
					case 'index':
						var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;
						_.slideHandler(_.checkNavigable(index), false, dontAnimate);
						$target.children().trigger('focus');
						break;
					default:
						return;
				}
			};
			Slick.prototype.checkNavigable = function (index) {
				var _ = this,
					navigables, prevNavigable;
				navigables = _.getNavigableIndexes();
				prevNavigable = 0;
				if (index > navigables[navigables.length - 1]) {
					index = navigables[navigables.length - 1];
				} else {
					for (var n in navigables) {
						if (index < navigables[n]) {
							index = prevNavigable;
							break;
						}
						prevNavigable = navigables[n];
					}
				}
				return index;
			};
			Slick.prototype.cleanUpEvents = function () {
				var _ = this;
				if (_.options.dots && _.$dots !== null) {
					$('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));
					if (_.options.accessibility === true) {
						_.$dots.off('keydown.slick', _.keyHandler);
					}
				}
				_.$slider.off('focus.slick blur.slick');
				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
					_.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
					if (_.options.accessibility === true) {
						_.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
						_.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
					}
				}
				_.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
				_.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
				_.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
				_.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);
				_.$list.off('click.slick', _.clickHandler);
				$(document).off(_.visibilityChange, _.visibility);
				_.cleanUpSlideEvents();
				if (_.options.accessibility === true) {
					_.$list.off('keydown.slick', _.keyHandler);
				}
				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().off('click.slick', _.selectHandler);
				}
				$(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);
				$(window).off('resize.slick.slick-' + _.instanceUid, _.resize);
				$('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);
				$(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
			};
			Slick.prototype.cleanUpSlideEvents = function () {
				var _ = this;
				_.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
				_.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
			};
			Slick.prototype.cleanUpRows = function () {
				var _ = this,
					originalSlides;
				if (_.options.rows > 0) {
					originalSlides = _.$slides.children().children();
					originalSlides.removeAttr('style');
					_.$slider.empty().append(originalSlides);
				}
			};
			Slick.prototype.clickHandler = function (event) {
				var _ = this;
				if (_.shouldClick === false) {
					event.stopImmediatePropagation();
					event.stopPropagation();
					event.preventDefault();
				}
			};
			Slick.prototype.destroy = function (refresh) {
				var _ = this;
				_.autoPlayClear();
				_.touchObject = {};
				_.cleanUpEvents();
				$('.slick-cloned', _.$slider).detach();
				if (_.$dots) {
					_.$dots.remove();
				}
				if (_.$prevArrow && _.$prevArrow.length) {
					_.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');
					if (_.htmlExpr.test(_.options.prevArrow)) {
						_.$prevArrow.remove();
					}
				}
				if (_.$nextArrow && _.$nextArrow.length) {
					_.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');
					if (_.htmlExpr.test(_.options.nextArrow)) {
						_.$nextArrow.remove();
					}
				}
				if (_.$slides) {
					_.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
						$(this).attr('style', $(this).data('originalStyling'));
					});
					_.$slideTrack.children(this.options.slide).detach();
					_.$slideTrack.detach();
					_.$list.detach();
					_.$slider.append(_.$slides);
				}
				_.cleanUpRows();
				_.$slider.removeClass('slick-slider');
				_.$slider.removeClass('slick-initialized');
				_.$slider.removeClass('slick-dotted');
				_.unslicked = true;
				if (!refresh) {
					_.$slider.trigger('destroy', [_]);
				}
			};
			Slick.prototype.disableTransition = function (slide) {
				var _ = this,
					transition = {};
				transition[_.transitionType] = '';
				if (_.options.fade === false) {
					_.$slideTrack.css(transition);
				} else {
					_.$slides.eq(slide).css(transition);
				}
			};
			Slick.prototype.fadeSlide = function (slideIndex, callback) {
				var _ = this;
				if (_.cssTransitions === false) {
					_.$slides.eq(slideIndex).css({
						zIndex: _.options.zIndex
					});
					_.$slides.eq(slideIndex).animate({
						opacity: 1
					}, _.options.speed, _.options.easing, callback);
				} else {
					_.applyTransition(slideIndex);
					_.$slides.eq(slideIndex).css({
						opacity: 1,
						zIndex: _.options.zIndex
					});
					if (callback) {
						setTimeout(function () {
							_.disableTransition(slideIndex);
							callback.call();
						}, _.options.speed);
					}
				}
			};
			Slick.prototype.fadeSlideOut = function (slideIndex) {
				var _ = this;
				if (_.cssTransitions === false) {
					_.$slides.eq(slideIndex).animate({
						opacity: 0,
						zIndex: _.options.zIndex - 2
					}, _.options.speed, _.options.easing);
				} else {
					_.applyTransition(slideIndex);
					_.$slides.eq(slideIndex).css({
						opacity: 0,
						zIndex: _.options.zIndex - 2
					});
				}
			};
			Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {
				var _ = this;
				if (filter !== null) {
					_.$slidesCache = _.$slides;
					_.unload();
					_.$slideTrack.children(this.options.slide).detach();
					_.$slidesCache.filter(filter).appendTo(_.$slideTrack);
					_.reinit();
				}
			};
			Slick.prototype.focusHandler = function () {
				var _ = this;
				_.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*', function (event) {
					event.stopImmediatePropagation();
					var $sf = $(this);
					setTimeout(function () {
						if (_.options.pauseOnFocus) {
							_.focussed = $sf.is(':focus');
							_.autoPlay();
						}
					}, 0);
				});
			};
			Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {
				var _ = this;
				return _.currentSlide;
			};
			Slick.prototype.getDotCount = function () {
				var _ = this;
				var breakPoint = 0;
				var counter = 0;
				var pagerQty = 0;
				if (_.options.infinite === true) {
					if (_.slideCount <= _.options.slidesToShow) {
						++pagerQty;
					} else {
						while (breakPoint < _.slideCount) {
							++pagerQty;
							breakPoint = counter + _.options.slidesToScroll;
							counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
						}
					}
				} else if (_.options.centerMode === true) {
					pagerQty = _.slideCount;
				} else if (!_.options.asNavFor) {
					pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
				} else {
					while (breakPoint < _.slideCount) {
						++pagerQty;
						breakPoint = counter + _.options.slidesToScroll;
						counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
					}
				}
				return pagerQty - 1;
			};
			Slick.prototype.getLeft = function (slideIndex) {
				var _ = this,
					targetLeft, verticalHeight, verticalOffset = 0,
					targetSlide, coef;
				_.slideOffset = 0;
				verticalHeight = _.$slides.first().outerHeight(true);
				if (_.options.infinite === true) {
					if (_.slideCount > _.options.slidesToShow) {
						_.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
						coef = -1;
						if (_.options.vertical === true && _.options.centerMode === true) {
							if (_.options.slidesToShow === 2) {
								coef = -1.5;
							} else if (_.options.slidesToShow === 1) {
								coef = -2;
							}
						}
						verticalOffset = verticalHeight * _.options.slidesToShow * coef;
					}
					if (_.slideCount % _.options.slidesToScroll !== 0) {
						if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
							if (slideIndex > _.slideCount) {
								_.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
								verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
							} else {
								_.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
								verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
							}
						}
					}
				} else {
					if (slideIndex + _.options.slidesToShow > _.slideCount) {
						_.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
						verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
					}
				}
				if (_.slideCount <= _.options.slidesToShow) {
					_.slideOffset = 0;
					verticalOffset = 0;
				}
				if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
					_.slideOffset = _.slideWidth * Math.floor(_.options.slidesToShow) / 2 - _.slideWidth * _.slideCount / 2;
				} else if (_.options.centerMode === true && _.options.infinite === true) {
					_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
				} else if (_.options.centerMode === true) {
					_.slideOffset = 0;
					_.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
				}
				if (_.options.vertical === false) {
					targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
				} else {
					targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
				}
				if (_.options.variableWidth === true) {
					if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
						targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
					} else {
						targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
					}
					if (_.options.rtl === true) {
						if (targetSlide[0]) {
							targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
						} else {
							targetLeft = 0;
						}
					} else {
						targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
					}
					if (_.options.centerMode === true) {
						if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
						} else {
							targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
						}
						if (_.options.rtl === true) {
							if (targetSlide[0]) {
								targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
							} else {
								targetLeft = 0;
							}
						} else {
							targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
						}
						targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
					}
				}
				return targetLeft;
			};
			Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {
				var _ = this;
				return _.options[option];
			};
			Slick.prototype.getNavigableIndexes = function () {
				var _ = this,
					breakPoint = 0,
					counter = 0,
					indexes = [],
					max;
				if (_.options.infinite === false) {
					max = _.slideCount;
				} else {
					breakPoint = _.options.slidesToScroll * -1;
					counter = _.options.slidesToScroll * -1;
					max = _.slideCount * 2;
				}
				while (breakPoint < max) {
					indexes.push(breakPoint);
					breakPoint = counter + _.options.slidesToScroll;
					counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
				}
				return indexes;
			};
			Slick.prototype.getSlick = function () {
				return this;
			};
			Slick.prototype.getSlideCount = function () {
				var _ = this,
					slidesTraversed, swipedSlide, centerOffset;
				centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;
				if (_.options.swipeToSlide === true) {
					_.$slideTrack.find('.slick-slide').each(function (index, slide) {
						if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
							swipedSlide = slide;
							return false;
						}
					});
					slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;
					return slidesTraversed;
				} else {
					return _.options.slidesToScroll;
				}
			};
			Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {
				var _ = this;
				_.changeSlide({
					data: {
						message: 'index',
						index: parseInt(slide)
					}
				}, dontAnimate);
			};
			Slick.prototype.init = function (creation) {
				var _ = this;
				if (!$(_.$slider).hasClass('slick-initialized')) {
					$(_.$slider).addClass('slick-initialized');
					_.buildRows();
					_.buildOut();
					_.setProps();
					_.startLoad();
					_.loadSlider();
					_.initializeEvents();
					_.updateArrows();
					_.updateDots();
					_.checkResponsive(true);
					_.focusHandler();
				}
				if (creation) {
					_.$slider.trigger('init', [_]);
				}
				if (_.options.accessibility === true) {
					_.initADA();
				}
				if (_.options.autoplay) {
					_.paused = false;
					_.autoPlay();
				}
			};
			Slick.prototype.initADA = function () {
				var _ = this,
					numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
					tabControlIndexes = _.getNavigableIndexes().filter(function (val) {
						return val >= 0 && val < _.slideCount;
					});
				_.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
					'aria-hidden': 'true',
					'tabindex': '-1'
				}).find('a, input, button, select').attr({
					'tabindex': '-1'
				});
				if (_.$dots !== null) {
					_.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
						var slideControlIndex = tabControlIndexes.indexOf(i);
						$(this).attr({
							'role': 'tabpanel',
							'id': 'slick-slide' + _.instanceUid + i,
							'tabindex': -1
						});
						if (slideControlIndex !== -1) {
							var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex;
							if ($('#' + ariaButtonControl).length) {
								$(this).attr({
									'aria-describedby': ariaButtonControl
								});
							}
						}
					});
					_.$dots.attr('role', 'tablist').find('li').each(function (i) {
						var mappedSlideIndex = tabControlIndexes[i];
						$(this).attr({
							'role': 'presentation'
						});
						$(this).find('button').first().attr({
							'role': 'tab',
							'id': 'slick-slide-control' + _.instanceUid + i,
							'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
							'aria-label': i + 1 + ' of ' + numDotGroups,
							'aria-selected': null,
							'tabindex': '-1'
						});
					}).eq(_.currentSlide).find('button').attr({
						'aria-selected': 'true',
						'tabindex': '0'
					}).end();
				}
				for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++) {
					if (_.options.focusOnChange) {
						_.$slides.eq(i).attr({
							'tabindex': '0'
						});
					} else {
						_.$slides.eq(i).removeAttr('tabindex');
					}
				}
				_.activateADA();
			};
			Slick.prototype.initArrowEvents = function () {
				var _ = this;
				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.off('click.slick').on('click.slick', {
						message: 'previous'
					}, _.changeSlide);
					_.$nextArrow.off('click.slick').on('click.slick', {
						message: 'next'
					}, _.changeSlide);
					if (_.options.accessibility === true) {
						_.$prevArrow.on('keydown.slick', _.keyHandler);
						_.$nextArrow.on('keydown.slick', _.keyHandler);
					}
				}
			};
			Slick.prototype.initDotEvents = function () {
				var _ = this;
				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					$('li', _.$dots).on('click.slick', {
						message: 'index'
					}, _.changeSlide);
					if (_.options.accessibility === true) {
						_.$dots.on('keydown.slick', _.keyHandler);
					}
				}
				if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {
					$('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
				}
			};
			Slick.prototype.initSlideEvents = function () {
				var _ = this;
				if (_.options.pauseOnHover) {
					_.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
					_.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
				}
			};
			Slick.prototype.initializeEvents = function () {
				var _ = this;
				_.initArrowEvents();
				_.initDotEvents();
				_.initSlideEvents();
				_.$list.on('touchstart.slick mousedown.slick', {
					action: 'start'
				}, _.swipeHandler);
				_.$list.on('touchmove.slick mousemove.slick', {
					action: 'move'
				}, _.swipeHandler);
				_.$list.on('touchend.slick mouseup.slick', {
					action: 'end'
				}, _.swipeHandler);
				_.$list.on('touchcancel.slick mouseleave.slick', {
					action: 'end'
				}, _.swipeHandler);
				_.$list.on('click.slick', _.clickHandler);
				$(document).on(_.visibilityChange, $.proxy(_.visibility, _));
				if (_.options.accessibility === true) {
					_.$list.on('keydown.slick', _.keyHandler);
				}
				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().on('click.slick', _.selectHandler);
				}
				$(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));
				$(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));
				$('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);
				$(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
				$(_.setPosition);
			};
			Slick.prototype.initUI = function () {
				var _ = this;
				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.show();
					_.$nextArrow.show();
				}
				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$dots.show();
				}
			};
			Slick.prototype.keyHandler = function (event) {
				var _ = this;
				if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
					if (event.keyCode === 37 && _.options.accessibility === true) {
						_.changeSlide({
							data: {
								message: _.options.rtl === true ? 'next' : 'previous'
							}
						});
					} else if (event.keyCode === 39 && _.options.accessibility === true) {
						_.changeSlide({
							data: {
								message: _.options.rtl === true ? 'previous' : 'next'
							}
						});
					}
				}
			};
			Slick.prototype.lazyLoad = function () {
				var _ = this,
					loadRange, cloneRange, rangeStart, rangeEnd;

				function loadImages(imagesScope) {
					$('img[data-lazy]', imagesScope).each(function () {
						var image = $(this),
							imageSource = $(this).attr('data-lazy'),
							imageSrcSet = $(this).attr('data-srcset'),
							imageSizes = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
							imageToLoad = document.createElement('img');
						imageToLoad.onload = function () {
							image.animate({
								opacity: 0
							}, 100, function () {
								if (imageSrcSet) {
									image.attr('srcset', imageSrcSet);
									if (imageSizes) {
										image.attr('sizes', imageSizes);
									}
								}
								image.attr('src', imageSource).animate({
									opacity: 1
								}, 200, function () {
									image.removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');
								});
								_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
							});
						};
						imageToLoad.onerror = function () {
							image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');
							_.$slider.trigger('lazyLoadError', [_, image, imageSource]);
						};
						imageToLoad.src = imageSource;
					});
				}
				if (_.options.centerMode === true) {
					if (_.options.infinite === true) {
						rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
						rangeEnd = rangeStart + _.options.slidesToShow + 2;
					} else {
						rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
						rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
					}
				} else {
					rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
					rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
					if (_.options.fade === true) {
						if (rangeStart > 0) rangeStart--;
						if (rangeEnd <= _.slideCount) rangeEnd++;
					}
				}
				loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
				if (_.options.lazyLoad === 'anticipated') {
					var prevSlide = rangeStart - 1,
						nextSlide = rangeEnd,
						$slides = _.$slider.find('.slick-slide');
					for (var i = 0; i < _.options.slidesToScroll; i++) {
						if (prevSlide < 0) prevSlide = _.slideCount - 1;
						loadRange = loadRange.add($slides.eq(prevSlide));
						loadRange = loadRange.add($slides.eq(nextSlide));
						prevSlide--;
						nextSlide++;
					}
				}
				loadImages(loadRange);
				if (_.slideCount <= _.options.slidesToShow) {
					cloneRange = _.$slider.find('.slick-slide');
					loadImages(cloneRange);
				} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
					cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
					loadImages(cloneRange);
				} else if (_.currentSlide === 0) {
					cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
					loadImages(cloneRange);
				}
			};
			Slick.prototype.loadSlider = function () {
				var _ = this;
				_.setPosition();
				_.$slideTrack.css({
					opacity: 1
				});
				_.$slider.removeClass('slick-loading');
				_.initUI();
				if (_.options.lazyLoad === 'progressive') {
					_.progressiveLazyLoad();
				}
			};
			Slick.prototype.next = Slick.prototype.slickNext = function () {
				var _ = this;
				_.changeSlide({
					data: {
						message: 'next'
					}
				});
			};
			Slick.prototype.orientationChange = function () {
				var _ = this;
				_.checkResponsive();
				_.setPosition();
			};
			Slick.prototype.pause = Slick.prototype.slickPause = function () {
				var _ = this;
				_.autoPlayClear();
				_.paused = true;
			};
			Slick.prototype.play = Slick.prototype.slickPlay = function () {
				var _ = this;
				_.autoPlay();
				_.options.autoplay = true;
				_.paused = false;
				_.focussed = false;
				_.interrupted = false;
			};
			Slick.prototype.postSlide = function (index) {
				var _ = this;
				if (!_.unslicked) {
					_.$slider.trigger('afterChange', [_, index]);
					_.animating = false;
					if (_.slideCount > _.options.slidesToShow) {
						_.setPosition();
					}
					_.swipeLeft = null;
					if (_.options.autoplay) {
						_.autoPlay();
					}
					if (_.options.accessibility === true) {
						_.initADA();
						if (_.options.focusOnChange) {
							var $currentSlide = $(_.$slides.get(_.currentSlide));
							$currentSlide.attr('tabindex', 0).focus();
						}
					}
				}
			};
			Slick.prototype.prev = Slick.prototype.slickPrev = function () {
				var _ = this;
				_.changeSlide({
					data: {
						message: 'previous'
					}
				});
			};
			Slick.prototype.preventDefault = function (event) {
				event.preventDefault();
			};
			Slick.prototype.progressiveLazyLoad = function (tryCount) {
				tryCount = tryCount || 1;
				var _ = this,
					$imgsToLoad = $('img[data-lazy]', _.$slider),
					image, imageSource, imageSrcSet, imageSizes, imageToLoad;
				if ($imgsToLoad.length) {
					image = $imgsToLoad.first();
					imageSource = image.attr('data-lazy');
					imageSrcSet = image.attr('data-srcset');
					imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');
					imageToLoad = document.createElement('img');
					imageToLoad.onload = function () {
						if (imageSrcSet) {
							image.attr('srcset', imageSrcSet);
							if (imageSizes) {
								image.attr('sizes', imageSizes);
							}
						}
						image.attr('src', imageSource).removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');
						if (_.options.adaptiveHeight === true) {
							_.setPosition();
						}
						_.$slider.trigger('lazyLoaded', [_, image, imageSource]);
						_.progressiveLazyLoad();
					};
					imageToLoad.onerror = function () {
						if (tryCount < 3) {
							setTimeout(function () {
								_.progressiveLazyLoad(tryCount + 1);
							}, 500);
						} else {
							image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');
							_.$slider.trigger('lazyLoadError', [_, image, imageSource]);
							_.progressiveLazyLoad();
						}
					};
					imageToLoad.src = imageSource;
				} else {
					_.$slider.trigger('allImagesLoaded', [_]);
				}
			};
			Slick.prototype.refresh = function (initializing) {
				var _ = this,
					currentSlide, lastVisibleIndex;
				lastVisibleIndex = _.slideCount - _.options.slidesToShow;
				if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
					_.currentSlide = lastVisibleIndex;
				}
				if (_.slideCount <= _.options.slidesToShow) {
					_.currentSlide = 0;
				}
				currentSlide = _.currentSlide;
				_.destroy(true);
				$.extend(_, _.initials, {
					currentSlide: currentSlide
				});
				_.init();
				if (!initializing) {
					_.changeSlide({
						data: {
							message: 'index',
							index: currentSlide
						}
					}, false);
				}
			};
			Slick.prototype.registerBreakpoints = function () {
				var _ = this,
					breakpoint, currentBreakpoint, l, responsiveSettings = _.options.responsive || null;
				if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {
					_.respondTo = _.options.respondTo || 'window';
					for (breakpoint in responsiveSettings) {
						l = _.breakpoints.length - 1;
						if (responsiveSettings.hasOwnProperty(breakpoint)) {
							currentBreakpoint = responsiveSettings[breakpoint].breakpoint;
							while (l >= 0) {
								if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
									_.breakpoints.splice(l, 1);
								}
								l--;
							}
							_.breakpoints.push(currentBreakpoint);
							_.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
						}
					}
					_.breakpoints.sort(function (a, b) {
						return _.options.mobileFirst ? a - b : b - a;
					});
				}
			};
			Slick.prototype.reinit = function () {
				var _ = this;
				_.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');
				_.slideCount = _.$slides.length;
				if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
					_.currentSlide = _.currentSlide - _.options.slidesToScroll;
				}
				if (_.slideCount <= _.options.slidesToShow) {
					_.currentSlide = 0;
				}
				_.registerBreakpoints();
				_.setProps();
				_.setupInfinite();
				_.buildArrows();
				_.updateArrows();
				_.initArrowEvents();
				_.buildDots();
				_.updateDots();
				_.initDotEvents();
				_.cleanUpSlideEvents();
				_.initSlideEvents();
				_.checkResponsive(false, true);
				if (_.options.focusOnSelect === true) {
					$(_.$slideTrack).children().on('click.slick', _.selectHandler);
				}
				_.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);
				_.setPosition();
				_.focusHandler();
				_.paused = !_.options.autoplay;
				_.autoPlay();
				_.$slider.trigger('reInit', [_]);
			};
			Slick.prototype.resize = function () {
				var _ = this;
				if ($(window).width() !== _.windowWidth) {
					clearTimeout(_.windowDelay);
					_.windowDelay = window.setTimeout(function () {
						_.windowWidth = $(window).width();
						_.checkResponsive();
						if (!_.unslicked) {
							_.setPosition();
						}
					}, 50);
				}
			};
			Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {
				var _ = this;
				if (typeof index === 'boolean') {
					removeBefore = index;
					index = removeBefore === true ? 0 : _.slideCount - 1;
				} else {
					index = removeBefore === true ? --index : index;
				}
				if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
					return false;
				}
				_.unload();
				if (removeAll === true) {
					_.$slideTrack.children().remove();
				} else {
					_.$slideTrack.children(this.options.slide).eq(index).remove();
				}
				_.$slides = _.$slideTrack.children(this.options.slide);
				_.$slideTrack.children(this.options.slide).detach();
				_.$slideTrack.append(_.$slides);
				_.$slidesCache = _.$slides;
				_.reinit();
			};
			Slick.prototype.setCSS = function (position) {
				var _ = this,
					positionProps = {},
					x, y;
				if (_.options.rtl === true) {
					position = -position;
				}
				x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
				y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';
				positionProps[_.positionProp] = position;
				if (_.transformsEnabled === false) {
					_.$slideTrack.css(positionProps);
				} else {
					positionProps = {};
					if (_.cssTransitions === false) {
						positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
						_.$slideTrack.css(positionProps);
					} else {
						positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
						_.$slideTrack.css(positionProps);
					}
				}
			};
			Slick.prototype.setDimensions = function () {
				var _ = this;
				if (_.options.vertical === false) {
					if (_.options.centerMode === true) {
						_.$list.css({
							padding: '0px ' + _.options.centerPadding
						});
					}
				} else {
					_.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
					if (_.options.centerMode === true) {
						_.$list.css({
							padding: _.options.centerPadding + ' 0px'
						});
					}
				}
				_.listWidth = _.$list.width();
				_.listHeight = _.$list.height();
				if (_.options.vertical === false && _.options.variableWidth === false) {
					_.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
					_.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
				} else if (_.options.variableWidth === true) {
					_.$slideTrack.width(5000 * _.slideCount);
				} else {
					_.slideWidth = Math.ceil(_.listWidth);
					_.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
				}
				var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
				if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
			};
			Slick.prototype.setFade = function () {
				var _ = this,
					targetLeft;
				_.$slides.each(function (index, element) {
					targetLeft = _.slideWidth * index * -1;
					if (_.options.rtl === true) {
						$(element).css({
							position: 'relative',
							right: targetLeft,
							top: 0,
							zIndex: _.options.zIndex - 2,
							opacity: 0
						});
					} else {
						$(element).css({
							position: 'relative',
							left: targetLeft,
							top: 0,
							zIndex: _.options.zIndex - 2,
							opacity: 0
						});
					}
				});
				_.$slides.eq(_.currentSlide).css({
					zIndex: _.options.zIndex - 1,
					opacity: 1
				});
			};
			Slick.prototype.setHeight = function () {
				var _ = this;
				if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
					var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
					_.$list.css('height', targetHeight);
				}
			};
			Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {
				var _ = this,
					l, item, option, value, refresh = false,
					type;
				if ($.type(arguments[0]) === 'object') {
					option = arguments[0];
					refresh = arguments[1];
					type = 'multiple';
				} else if ($.type(arguments[0]) === 'string') {
					option = arguments[0];
					value = arguments[1];
					refresh = arguments[2];
					if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {
						type = 'responsive';
					} else if (typeof arguments[1] !== 'undefined') {
						type = 'single';
					}
				}
				if (type === 'single') {
					_.options[option] = value;
				} else if (type === 'multiple') {
					$.each(option, function (opt, val) {
						_.options[opt] = val;
					});
				} else if (type === 'responsive') {
					for (item in value) {
						if ($.type(_.options.responsive) !== 'array') {
							_.options.responsive = [value[item]];
						} else {
							l = _.options.responsive.length - 1;
							while (l >= 0) {
								if (_.options.responsive[l].breakpoint === value[item].breakpoint) {
									_.options.responsive.splice(l, 1);
								}
								l--;
							}
							_.options.responsive.push(value[item]);
						}
					}
				}
				if (refresh) {
					_.unload();
					_.reinit();
				}
			};
			Slick.prototype.setPosition = function () {
				var _ = this;
				_.setDimensions();
				_.setHeight();
				if (_.options.fade === false) {
					_.setCSS(_.getLeft(_.currentSlide));
				} else {
					_.setFade();
				}
				_.$slider.trigger('setPosition', [_]);
			};
			Slick.prototype.setProps = function () {
				var _ = this,
					bodyStyle = document.body.style;
				_.positionProp = _.options.vertical === true ? 'top' : 'left';
				if (_.positionProp === 'top') {
					_.$slider.addClass('slick-vertical');
				} else {
					_.$slider.removeClass('slick-vertical');
				}
				if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
					if (_.options.useCSS === true) {
						_.cssTransitions = true;
					}
				}
				if (_.options.fade) {
					if (typeof _.options.zIndex === 'number') {
						if (_.options.zIndex < 3) {
							_.options.zIndex = 3;
						}
					} else {
						_.options.zIndex = _.defaults.zIndex;
					}
				}
				if (bodyStyle.OTransform !== undefined) {
					_.animType = 'OTransform';
					_.transformType = '-o-transform';
					_.transitionType = 'OTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
				}
				if (bodyStyle.MozTransform !== undefined) {
					_.animType = 'MozTransform';
					_.transformType = '-moz-transform';
					_.transitionType = 'MozTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
				}
				if (bodyStyle.webkitTransform !== undefined) {
					_.animType = 'webkitTransform';
					_.transformType = '-webkit-transform';
					_.transitionType = 'webkitTransition';
					if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
				}
				if (bodyStyle.msTransform !== undefined) {
					_.animType = 'msTransform';
					_.transformType = '-ms-transform';
					_.transitionType = 'msTransition';
					if (bodyStyle.msTransform === undefined) _.animType = false;
				}
				if (bodyStyle.transform !== undefined && _.animType !== false) {
					_.animType = 'transform';
					_.transformType = 'transform';
					_.transitionType = 'transition';
				}
				_.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
			};
			Slick.prototype.setSlideClasses = function (index) {
				var _ = this,
					centerOffset, allSlides, indexOffset, remainder;
				allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');
				_.$slides.eq(index).addClass('slick-current');
				if (_.options.centerMode === true) {
					var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;
					centerOffset = Math.floor(_.options.slidesToShow / 2);
					if (_.options.infinite === true) {
						if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {
							_.$slides.slice(index - centerOffset + evenCoef, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
						} else {
							indexOffset = _.options.slidesToShow + index;
							allSlides.slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
						}
						if (index === 0) {
							allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
						} else if (index === _.slideCount - 1) {
							allSlides.eq(_.options.slidesToShow).addClass('slick-center');
						}
					}
					_.$slides.eq(index).addClass('slick-center');
				} else {
					if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {
						_.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
					} else if (allSlides.length <= _.options.slidesToShow) {
						allSlides.addClass('slick-active').attr('aria-hidden', 'false');
					} else {
						remainder = _.slideCount % _.options.slidesToShow;
						indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;
						if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {
							allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
						} else {
							allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
						}
					}
				}
				if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
					_.lazyLoad();
				}
			};
			Slick.prototype.setupInfinite = function () {
				var _ = this,
					i, slideIndex, infiniteCount;
				if (_.options.fade === true) {
					_.options.centerMode = false;
				}
				if (_.options.infinite === true && _.options.fade === false) {
					slideIndex = null;
					if (_.slideCount > _.options.slidesToShow) {
						if (_.options.centerMode === true) {
							infiniteCount = _.options.slidesToShow + 1;
						} else {
							infiniteCount = _.options.slidesToShow;
						}
						for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
							slideIndex = i - 1;
							$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
						}
						for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
							slideIndex = i;
							$(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
						}
						_.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
							$(this).attr('id', '');
						});
					}
				}
			};
			Slick.prototype.interrupt = function (toggle) {
				var _ = this;
				if (!toggle) {
					_.autoPlay();
				}
				_.interrupted = toggle;
			};
			Slick.prototype.selectHandler = function (event) {
				var _ = this;
				var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');
				var index = parseInt(targetElement.attr('data-slick-index'));
				if (!index) index = 0;
				if (_.slideCount <= _.options.slidesToShow) {
					_.slideHandler(index, false, true);
					return;
				}
				_.slideHandler(index);
			};
			Slick.prototype.slideHandler = function (index, sync, dontAnimate) {
				var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
					_ = this,
					navTarget;
				sync = sync || false;
				if (_.animating === true && _.options.waitForAnimate === true) {
					return;
				}
				if (_.options.fade === true && _.currentSlide === index) {
					return;
				}
				if (sync === false) {
					_.asNavFor(index);
				}
				targetSlide = index;
				targetLeft = _.getLeft(targetSlide);
				slideLeft = _.getLeft(_.currentSlide);
				_.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;
				if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
					if (_.options.fade === false) {
						targetSlide = _.currentSlide;
						if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
							_.animateSlide(slideLeft, function () {
								_.postSlide(targetSlide);
							});
						} else {
							_.postSlide(targetSlide);
						}
					}
					return;
				} else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
					if (_.options.fade === false) {
						targetSlide = _.currentSlide;
						if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
							_.animateSlide(slideLeft, function () {
								_.postSlide(targetSlide);
							});
						} else {
							_.postSlide(targetSlide);
						}
					}
					return;
				}
				if (_.options.autoplay) {
					clearInterval(_.autoPlayTimer);
				}
				if (targetSlide < 0) {
					if (_.slideCount % _.options.slidesToScroll !== 0) {
						animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
					} else {
						animSlide = _.slideCount + targetSlide;
					}
				} else if (targetSlide >= _.slideCount) {
					if (_.slideCount % _.options.slidesToScroll !== 0) {
						animSlide = 0;
					} else {
						animSlide = targetSlide - _.slideCount;
					}
				} else {
					animSlide = targetSlide;
				}
				_.animating = true;
				_.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);
				oldSlide = _.currentSlide;
				_.currentSlide = animSlide;
				_.setSlideClasses(_.currentSlide);
				if (_.options.asNavFor) {
					navTarget = _.getNavTarget();
					navTarget = navTarget.slick('getSlick');
					if (navTarget.slideCount <= navTarget.options.slidesToShow) {
						navTarget.setSlideClasses(_.currentSlide);
					}
				}
				_.updateDots();
				_.updateArrows();
				if (_.options.fade === true) {
					if (dontAnimate !== true) {
						_.fadeSlideOut(oldSlide);
						_.fadeSlide(animSlide, function () {
							_.postSlide(animSlide);
						});
					} else {
						_.postSlide(animSlide);
					}
					_.animateHeight();
					return;
				}
				if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
					_.animateSlide(targetLeft, function () {
						_.postSlide(animSlide);
					});
				} else {
					_.postSlide(animSlide);
				}
			};
			Slick.prototype.startLoad = function () {
				var _ = this;
				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
					_.$prevArrow.hide();
					_.$nextArrow.hide();
				}
				if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
					_.$dots.hide();
				}
				_.$slider.addClass('slick-loading');
			};
			Slick.prototype.swipeDirection = function () {
				var xDist, yDist, r, swipeAngle, _ = this;
				xDist = _.touchObject.startX - _.touchObject.curX;
				yDist = _.touchObject.startY - _.touchObject.curY;
				r = Math.atan2(yDist, xDist);
				swipeAngle = Math.round(r * 180 / Math.PI);
				if (swipeAngle < 0) {
					swipeAngle = 360 - Math.abs(swipeAngle);
				}
				if (swipeAngle <= 45 && swipeAngle >= 0) {
					return _.options.rtl === false ? 'left' : 'right';
				}
				if (swipeAngle <= 360 && swipeAngle >= 315) {
					return _.options.rtl === false ? 'left' : 'right';
				}
				if (swipeAngle >= 135 && swipeAngle <= 225) {
					return _.options.rtl === false ? 'right' : 'left';
				}
				if (_.options.verticalSwiping === true) {
					if (swipeAngle >= 35 && swipeAngle <= 135) {
						return 'down';
					} else {
						return 'up';
					}
				}
				return 'vertical';
			};
			Slick.prototype.swipeEnd = function (event) {
				var _ = this,
					slideCount, direction;
				_.dragging = false;
				_.swiping = false;
				if (_.scrolling) {
					_.scrolling = false;
					return false;
				}
				_.interrupted = false;
				_.shouldClick = _.touchObject.swipeLength > 10 ? false : true;
				if (_.touchObject.curX === undefined) {
					return false;
				}
				if (_.touchObject.edgeHit === true) {
					_.$slider.trigger('edge', [_, _.swipeDirection()]);
				}
				if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
					direction = _.swipeDirection();
					switch (direction) {
						case 'left':
						case 'down':
							slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
							_.currentDirection = 0;
							break;
						case 'right':
						case 'up':
							slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
							_.currentDirection = 1;
							break;
						default:
					}
					if (direction != 'vertical') {
						_.slideHandler(slideCount);
						_.touchObject = {};
						_.$slider.trigger('swipe', [_, direction]);
					}
				} else {
					if (_.touchObject.startX !== _.touchObject.curX) {
						_.slideHandler(_.currentSlide);
						_.touchObject = {};
					}
				}
			};
			Slick.prototype.swipeHandler = function (event) {
				var _ = this;
				if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
					return;
				} else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
					return;
				}
				_.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;
				_.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;
				if (_.options.verticalSwiping === true) {
					_.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
				}
				switch (event.data.action) {
					case 'start':
						_.swipeStart(event);
						break;
					case 'move':
						_.swipeMove(event);
						break;
					case 'end':
						_.swipeEnd(event);
						break;
				}
			};
			Slick.prototype.swipeMove = function (event) {
				var _ = this,
					edgeWasHit = false,
					curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;
				touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;
				if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
					return false;
				}
				curLeft = _.getLeft(_.currentSlide);
				_.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
				_.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;
				_.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
				verticalSwipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
				if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
					_.scrolling = true;
					return false;
				}
				if (_.options.verticalSwiping === true) {
					_.touchObject.swipeLength = verticalSwipeLength;
				}
				swipeDirection = _.swipeDirection();
				if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
					_.swiping = true;
					event.preventDefault();
				}
				positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
				if (_.options.verticalSwiping === true) {
					positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
				}
				swipeLength = _.touchObject.swipeLength;
				_.touchObject.edgeHit = false;
				if (_.options.infinite === false) {
					if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
						swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
						_.touchObject.edgeHit = true;
					}
				}
				if (_.options.vertical === false) {
					_.swipeLeft = curLeft + swipeLength * positionOffset;
				} else {
					_.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
				}
				if (_.options.verticalSwiping === true) {
					_.swipeLeft = curLeft + swipeLength * positionOffset;
				}
				if (_.options.fade === true || _.options.touchMove === false) {
					return false;
				}
				if (_.animating === true) {
					_.swipeLeft = null;
					return false;
				}
				_.setCSS(_.swipeLeft);
			};
			Slick.prototype.swipeStart = function (event) {
				var _ = this,
					touches;
				_.interrupted = true;
				if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
					_.touchObject = {};
					return false;
				}
				if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
					touches = event.originalEvent.touches[0];
				}
				_.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
				_.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;
				_.dragging = true;
			};
			Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {
				var _ = this;
				if (_.$slidesCache !== null) {
					_.unload();
					_.$slideTrack.children(this.options.slide).detach();
					_.$slidesCache.appendTo(_.$slideTrack);
					_.reinit();
				}
			};
			Slick.prototype.unload = function () {
				var _ = this;
				$('.slick-cloned', _.$slider).remove();
				if (_.$dots) {
					_.$dots.remove();
				}
				if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
					_.$prevArrow.remove();
				}
				if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
					_.$nextArrow.remove();
				}
				_.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
			};
			Slick.prototype.unslick = function (fromBreakpoint) {
				var _ = this;
				_.$slider.trigger('unslick', [_, fromBreakpoint]);
				_.destroy();
			};
			Slick.prototype.updateArrows = function () {
				var _ = this,
					centerOffset;
				centerOffset = Math.floor(_.options.slidesToShow / 2);
				if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {
					_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					if (_.currentSlide === 0) {
						_.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
						_.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					} else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {
						_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
						_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					} else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {
						_.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
						_.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
					}
				}
			};
			Slick.prototype.updateDots = function () {
				var _ = this;
				if (_.$dots !== null) {
					_.$dots.find('li').removeClass('slick-active').end();
					_.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active');
				}
			};
			Slick.prototype.visibility = function () {
				var _ = this;
				if (_.options.autoplay) {
					if (document[_.hidden]) {
						_.interrupted = true;
					} else {
						_.interrupted = false;
					}
				}
			};
			$.fn.slick = function () {
				var _ = this,
					opt = arguments[0],
					args = Array.prototype.slice.call(arguments, 1),
					l = _.length,
					i, ret;
				for (i = 0; i < l; i++) {
					if ((typeof opt === 'undefined' ? 'undefined' : _typeof(opt)) == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);
					else ret = _[i].slick[opt].apply(_[i].slick, args);
					if (typeof ret != 'undefined') return ret;
				}
				return _;
			};
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		/*!
		 * The Final Countdown for jQuery v2.2.0 (http://hilios.github.io/jQuery.countdown/)
		 * Copyright (c) 2016 Edson Hilios
		 * 
		 * Permission is hereby granted, free of charge, to any person obtaining a copy of
		 * this software and associated documentation files (the "Software"), to deal in
		 * the Software without restriction, including without limitation the rights to
		 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
		 * the Software, and to permit persons to whom the Software is furnished to do so,
		 * subject to the following conditions:
		 * 
		 * The above copyright notice and this permission notice shall be included in all
		 * copies or substantial portions of the Software.
		 * 
		 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
		 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
		 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
		 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
		 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		 */
		(function (factory) {
			"use strict";
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
				factory(jQuery);
			}
		})(function ($) {
			"use strict";
			var instances = [],
				matchers = [],
				defaultOptions = {
					precision: 100,
					elapse: false,
					defer: false
				};
			matchers.push(/^[0-9]*$/.source);
			matchers.push(/([0-9]{1,2}\/){2}[0-9]{4}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
			matchers.push(/[0-9]{4}([\/\-][0-9]{1,2}){2}( [0-9]{1,2}(:[0-9]{2}){2})?/.source);
			matchers = new RegExp(matchers.join("|"));

			function parseDateString(dateString) {
				if (dateString instanceof Date) {
					return dateString;
				}
				if (String(dateString).match(matchers)) {
					if (String(dateString).match(/^[0-9]*$/)) {
						dateString = Number(dateString);
					}
					if (String(dateString).match(/\-/)) {
						dateString = String(dateString).replace(/\-/g, "/");
					}
					return new Date(dateString);
				} else {
					throw new Error("Couldn't cast `" + dateString + "` to a date object.");
				}
			}
			var DIRECTIVE_KEY_MAP = {
				Y: "years",
				m: "months",
				n: "daysToMonth",
				d: "daysToWeek",
				w: "weeks",
				W: "weeksToMonth",
				H: "hours",
				M: "minutes",
				S: "seconds",
				D: "totalDays",
				I: "totalHours",
				N: "totalMinutes",
				T: "totalSeconds"
			};

			function escapedRegExp(str) {
				var sanitize = str.toString().replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
				return new RegExp(sanitize);
			}

			function strftime(offsetObject) {
				return function (format) {
					var directives = format.match(/%(-|!)?[A-Z]{1}(:[^;]+;)?/gi);
					if (directives) {
						for (var i = 0, len = directives.length; i < len; ++i) {
							var directive = directives[i].match(/%(-|!)?([a-zA-Z]{1})(:[^;]+;)?/),
								regexp = escapedRegExp(directive[0]),
								modifier = directive[1] || "",
								plural = directive[3] || "",
								value = null;
							directive = directive[2];
							if (DIRECTIVE_KEY_MAP.hasOwnProperty(directive)) {
								value = DIRECTIVE_KEY_MAP[directive];
								value = Number(offsetObject[value]);
							}
							if (value !== null) {
								if (modifier === "!") {
									value = pluralize(plural, value);
								}
								if (modifier === "") {
									if (value < 10) {
										value = "0" + value.toString();
									}
								}
								format = format.replace(regexp, value.toString());
							}
						}
					}
					format = format.replace(/%%/, "%");
					return format;
				};
			}

			function pluralize(format, count) {
				var plural = "s",
					singular = "";
				if (format) {
					format = format.replace(/(:|;|\s)/gi, "").split(/\,/);
					if (format.length === 1) {
						plural = format[0];
					} else {
						singular = format[0];
						plural = format[1];
					}
				}
				if (Math.abs(count) > 1) {
					return plural;
				} else {
					return singular;
				}
			}
			var Countdown = function Countdown(el, finalDate, options) {
				this.el = el;
				this.$el = $(el);
				this.interval = null;
				this.offset = {};
				this.options = $.extend({}, defaultOptions);
				this.instanceNumber = instances.length;
				instances.push(this);
				this.$el.data("countdown-instance", this.instanceNumber);
				if (options) {
					if (typeof options === "function") {
						this.$el.on("update.countdown", options);
						this.$el.on("stoped.countdown", options);
						this.$el.on("finish.countdown", options);
					} else {
						this.options = $.extend({}, defaultOptions, options);
					}
				}
				this.setFinalDate(finalDate);
				if (this.options.defer === false) {
					this.start();
				}
			};
			$.extend(Countdown.prototype, {
				start: function start() {
					if (this.interval !== null) {
						clearInterval(this.interval);
					}
					var self = this;
					this.update();
					this.interval = setInterval(function () {
						self.update.call(self);
					}, this.options.precision);
				},
				stop: function stop() {
					clearInterval(this.interval);
					this.interval = null;
					this.dispatchEvent("stoped");
				},
				toggle: function toggle() {
					if (this.interval) {
						this.stop();
					} else {
						this.start();
					}
				},
				pause: function pause() {
					this.stop();
				},
				resume: function resume() {
					this.start();
				},
				remove: function remove() {
					this.stop.call(this);
					instances[this.instanceNumber] = null;
					delete this.$el.data().countdownInstance;
				},
				setFinalDate: function setFinalDate(value) {
					this.finalDate = parseDateString(value);
				},
				update: function update() {
					if (this.$el.closest("html").length === 0) {
						this.remove();
						return;
					}
					var hasEventsAttached = $._data(this.el, "events") !== undefined,
						now = new Date(),
						newTotalSecsLeft;
					newTotalSecsLeft = this.finalDate.getTime() - now.getTime();
					newTotalSecsLeft = Math.ceil(newTotalSecsLeft / 1e3);
					newTotalSecsLeft = !this.options.elapse && newTotalSecsLeft < 0 ? 0 : Math.abs(newTotalSecsLeft);
					if (this.totalSecsLeft === newTotalSecsLeft || !hasEventsAttached) {
						return;
					} else {
						this.totalSecsLeft = newTotalSecsLeft;
					}
					this.elapsed = now >= this.finalDate;
					this.offset = {
						seconds: this.totalSecsLeft % 60,
						minutes: Math.floor(this.totalSecsLeft / 60) % 60,
						hours: Math.floor(this.totalSecsLeft / 60 / 60) % 24,
						days: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
						daysToWeek: Math.floor(this.totalSecsLeft / 60 / 60 / 24) % 7,
						daysToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 % 30.4368),
						weeks: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7),
						weeksToMonth: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 7) % 4,
						months: Math.floor(this.totalSecsLeft / 60 / 60 / 24 / 30.4368),
						years: Math.abs(this.finalDate.getFullYear() - now.getFullYear()),
						totalDays: Math.floor(this.totalSecsLeft / 60 / 60 / 24),
						totalHours: Math.floor(this.totalSecsLeft / 60 / 60),
						totalMinutes: Math.floor(this.totalSecsLeft / 60),
						totalSeconds: this.totalSecsLeft
					};
					if (!this.options.elapse && this.totalSecsLeft === 0) {
						this.stop();
						this.dispatchEvent("finish");
					} else {
						this.dispatchEvent("update");
					}
				},
				dispatchEvent: function dispatchEvent(eventName) {
					var event = $.Event(eventName + ".countdown");
					event.finalDate = this.finalDate;
					event.elapsed = this.elapsed;
					event.offset = $.extend({}, this.offset);
					event.strftime = strftime(this.offset);
					this.$el.trigger(event);
				}
			});
			$.fn.countdown = function () {
				var argumentsArray = Array.prototype.slice.call(arguments, 0);
				return this.each(function () {
					var instanceNumber = $(this).data("countdown-instance");
					if (instanceNumber !== undefined) {
						var instance = instances[instanceNumber],
							method = argumentsArray[0];
						if (Countdown.prototype.hasOwnProperty(method)) {
							instance[method].apply(instance, argumentsArray.slice(1));
						} else if (String(method).match(/^[$A-Z_][0-9A-Z_$]*$/i) === null) {
							instance.setFinalDate.call(instance, method);
							instance.start();
						} else {
							$.error("Method %s does not exist on jQuery.countdown".replace(/\%s/gi, method));
						}
					} else {
						new Countdown(this, argumentsArray[0], argumentsArray[1]);
					}
				});
			};
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (__webpack_provided_window_dot_jQuery, jQuery) {
			(function (window, document, $, undefined) {
				"use strict";
				window.console = window.console || {
					info: function info(stuff) { }
				};
				if (!$) {
					return;
				}
				if ($.fn.fancybox) {
					console.info("fancyBox already initialized");
					return;
				}
				var defaults = {
					loop: false,
					gutter: 50,
					keyboard: true,
					arrows: true,
					infobar: true,
					smallBtn: "auto",
					toolbar: "auto",
					buttons: ["zoom", "thumbs", "close"],
					idleTime: 3,
					protect: false,
					modal: false,
					image: {
						preload: false
					},
					ajax: {
						settings: {
							data: {
								fancybox: true
							}
						}
					},
					iframe: {
						tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen allowtransparency="true" src=""></iframe>',
						preload: true,
						css: {},
						attr: {
							scrolling: "auto"
						}
					},
					defaultType: "image",
					animationEffect: "zoom",
					animationDuration: 366,
					zoomOpacity: "auto",
					transitionEffect: "fade",
					transitionDuration: 366,
					slideClass: "",
					baseClass: "",
					baseTpl: '<div class="fancybox-container" role="dialog" tabindex="-1">' + '<div class="fancybox-bg"></div>' + '<div class="fancybox-inner">' + '<div class="fancybox-infobar">' + "<span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span>" + "</div>" + '<div class="fancybox-toolbar">{{buttons}}</div>' + '<div class="fancybox-navigation">{{arrows}}</div>' + '<div class="fancybox-stage"></div>' + '<div class="fancybox-caption"></div>' + "</div>" + "</div>",
					spinnerTpl: '<div class="fancybox-loading"></div>',
					errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',
					btnTpl: {
						download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">' + '<svg viewBox="0 0 40 40">' + '<path d="M13,16 L20,23 L27,16 M20,7 L20,23 M10,24 L10,28 L30,28 L30,24" />' + "</svg>" + "</a>",
						zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' + '<svg viewBox="0 0 40 40">' + '<path d="M18,17 m-8,0 a8,8 0 1,0 16,0 a8,8 0 1,0 -16,0 M24,22 L31,29" />' + "</svg>" + "</button>",
						close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' + '<svg viewBox="0 0 40 40">' + '<path d="M10,10 L30,30 M30,10 L10,30" />' + "</svg>" + "</button>",
						smallBtn: '<button data-fancybox-close class="fancybox-close-small" title="{{CLOSE}}"><svg viewBox="0 0 32 32"><path d="M10,10 L22,22 M22,10 L10,22"></path></svg></button>',
						arrowLeft: '<a data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}" href="javascript:;">' + '<svg viewBox="0 0 40 40">' + '<path d="M18,12 L10,20 L18,28 M10,20 L30,20"></path>' + "</svg>" + "</a>",
						arrowRight: '<a data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}" href="javascript:;">' + '<svg viewBox="0 0 40 40">' + '<path d="M10,20 L30,20 M22,12 L30,20 L22,28"></path>' + "</svg>" + "</a>"
					},
					parentEl: "body",
					autoFocus: false,
					backFocus: true,
					trapFocus: true,
					fullScreen: {
						autoStart: false
					},
					touch: {
						vertical: true,
						momentum: true
					},
					hash: null,
					media: {},
					slideShow: {
						autoStart: false,
						speed: 4000
					},
					thumbs: {
						autoStart: false,
						hideOnClose: true,
						parentEl: ".fancybox-container",
						axis: "y"
					},
					wheel: "auto",
					onInit: $.noop,
					beforeLoad: $.noop,
					afterLoad: $.noop,
					beforeShow: $.noop,
					afterShow: $.noop,
					beforeClose: $.noop,
					afterClose: $.noop,
					onActivate: $.noop,
					onDeactivate: $.noop,
					clickContent: function clickContent(current, event) {
						return current.type === "image" ? "zoom" : false;
					},
					clickSlide: "close",
					clickOutside: "close",
					dblclickContent: false,
					dblclickSlide: false,
					dblclickOutside: false,
					mobile: {
						idleTime: false,
						clickContent: function clickContent(current, event) {
							return current.type === "image" ? "toggleControls" : false;
						},
						clickSlide: function clickSlide(current, event) {
							return current.type === "image" ? "toggleControls" : "close";
						},
						dblclickContent: function dblclickContent(current, event) {
							return current.type === "image" ? "zoom" : false;
						},
						dblclickSlide: function dblclickSlide(current, event) {
							return current.type === "image" ? "zoom" : false;
						}
					},
					lang: "en",
					i18n: {
						en: {
							CLOSE: "Close",
							NEXT: "Next",
							PREV: "Previous",
							ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
							PLAY_START: "Start slideshow",
							PLAY_STOP: "Pause slideshow",
							FULL_SCREEN: "Full screen",
							THUMBS: "Thumbnails",
							DOWNLOAD: "Download",
							SHARE: "Share",
							ZOOM: "Zoom"
						},
						de: {
							CLOSE: "Schliessen",
							NEXT: "Weiter",
							PREV: "Zurück",
							ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es später nochmal.",
							PLAY_START: "Diaschau starten",
							PLAY_STOP: "Diaschau beenden",
							FULL_SCREEN: "Vollbild",
							THUMBS: "Vorschaubilder",
							DOWNLOAD: "Herunterladen",
							SHARE: "Teilen",
							ZOOM: "Maßstab"
						}
					}
				};
				var $W = $(window);
				var $D = $(document);
				var called = 0;
				var isQuery = function isQuery(obj) {
					return obj && obj.hasOwnProperty && obj instanceof $;
				};
				var requestAFrame = function () {
					return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
				}();
				var transitionEnd = function () {
					var el = document.createElement("fakeelement"),
						t;
					var transitions = {
						transition: "transitionend",
						OTransition: "oTransitionEnd",
						MozTransition: "transitionend",
						WebkitTransition: "webkitTransitionEnd"
					};
					for (t in transitions) {
						if (el.style[t] !== undefined) {
							return transitions[t];
						}
					}
					return "transitionend";
				}();
				var forceRedraw = function forceRedraw($el) {
					return $el && $el.length && $el[0].offsetHeight;
				};
				var mergeOpts = function mergeOpts(opts1, opts2) {
					var rez = $.extend(true, {}, opts1, opts2);
					$.each(opts2, function (key, value) {
						if ($.isArray(value)) {
							rez[key] = value;
						}
					});
					return rez;
				};
				var FancyBox = function FancyBox(content, opts, index) {
					var self = this;
					self.opts = mergeOpts({
						index: index
					}, $.fancybox.defaults);
					if ($.isPlainObject(opts)) {
						self.opts = mergeOpts(self.opts, opts);
					}
					if ($.fancybox.isMobile) {
						self.opts = mergeOpts(self.opts, self.opts.mobile);
					}
					self.id = self.opts.id || ++called;
					self.currIndex = parseInt(self.opts.index, 10) || 0;
					self.prevIndex = null;
					self.prevPos = null;
					self.currPos = 0;
					self.firstRun = true;
					self.group = [];
					self.slides = {};
					self.addContent(content);
					if (!self.group.length) {
						return;
					}
					self.$lastFocus = $(document.activeElement).trigger("blur");
					self.init();
				};
				$.extend(FancyBox.prototype, {
					init: function init() {
						var self = this,
							firstItem = self.group[self.currIndex],
							firstItemOpts = firstItem.opts,
							scrollbarWidth = $.fancybox.scrollbarWidth,
							$scrollDiv, $container, buttonStr;
						if (!$.fancybox.getInstance() && firstItemOpts.hideScrollbar !== false) {
							$("body").addClass("fancybox-active");
							if (!$.fancybox.isMobile && document.body.scrollHeight > window.innerHeight) {
								if (scrollbarWidth === undefined) {
									$scrollDiv = $('<div style="width:100px;height:100px;overflow:scroll;" />').appendTo("body");
									scrollbarWidth = $.fancybox.scrollbarWidth = $scrollDiv[0].offsetWidth - $scrollDiv[0].clientWidth;
									$scrollDiv.remove();
								}
								$("head").append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar { margin-right: ' + scrollbarWidth + "px; }</style>");
								$("body").addClass("compensate-for-scrollbar");
							}
						}
						buttonStr = "";
						$.each(firstItemOpts.buttons, function (index, value) {
							buttonStr += firstItemOpts.btnTpl[value] || "";
						});
						$container = $(self.translate(self, firstItemOpts.baseTpl.replace("{{buttons}}", buttonStr).replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight))).attr("id", "fancybox-container-" + self.id).addClass("fancybox-is-hidden").addClass(firstItemOpts.baseClass).data("FancyBox", self).appendTo(firstItemOpts.parentEl);
						self.$refs = {
							container: $container
						};
						["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function (item) {
							self.$refs[item] = $container.find(".fancybox-" + item);
						});
						self.trigger("onInit");
						self.activate();
						self.jumpTo(self.currIndex);
					},
					translate: function translate(obj, str) {
						var arr = obj.opts.i18n[obj.opts.lang];
						return str.replace(/\{\{(\w+)\}\}/g, function (match, n) {
							var value = arr[n];
							if (value === undefined) {
								return match;
							}
							return value;
						});
					},
					addContent: function addContent(content) {
						var self = this,
							items = $.makeArray(content),
							thumbs;
						$.each(items, function (i, item) {
							var obj = {},
								opts = {},
								$item, type, found, src, srcParts;
							if ($.isPlainObject(item)) {
								obj = item;
								opts = item.opts || item;
							} else if ($.type(item) === "object" && $(item).length) {
								$item = $(item);
								opts = $item.data() || {};
								opts = $.extend(true, {}, opts, opts.options);
								opts.$orig = $item;
								obj.src = self.opts.src || opts.src || $item.attr("href");
								if (!obj.type && !obj.src) {
									obj.type = "inline";
									obj.src = item;
								}
							} else {
								obj = {
									type: "html",
									src: item + ""
								};
							}
							obj.opts = $.extend(true, {}, self.opts, opts);
							if ($.isArray(opts.buttons)) {
								obj.opts.buttons = opts.buttons;
							}
							type = obj.type || obj.opts.type;
							src = obj.src || "";
							if (!type && src) {
								if (found = src.match(/\.(mp4|mov|ogv)((\?|#).*)?$/i)) {
									type = "video";
									if (!obj.opts.videoFormat) {
										obj.opts.videoFormat = "video/" + (found[1] === "ogv" ? "ogg" : found[1]);
									}
								} else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
									type = "image";
								} else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
									type = "iframe";
								} else if (src.charAt(0) === "#") {
									type = "inline";
								}
							}
							if (type) {
								obj.type = type;
							} else {
								self.trigger("objectNeedsType", obj);
							}
							if (!obj.contentType) {
								obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;
							}
							obj.index = self.group.length;
							if (obj.opts.smallBtn == "auto") {
								obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;
							}
							if (obj.opts.toolbar === "auto") {
								obj.opts.toolbar = !obj.opts.smallBtn;
							}
							if (obj.opts.$trigger && obj.index === self.opts.index) {
								obj.opts.$thumb = obj.opts.$trigger.find("img:first");
							}
							if ((!obj.opts.$thumb || !obj.opts.$thumb.length) && obj.opts.$orig) {
								obj.opts.$thumb = obj.opts.$orig.find("img:first");
							}
							if ($.type(obj.opts.caption) === "function") {
								obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
							}
							if ($.type(self.opts.caption) === "function") {
								obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
							}
							if (!(obj.opts.caption instanceof $)) {
								obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";
							}
							if (obj.type === "ajax") {
								srcParts = src.split(/\s+/, 2);
								if (srcParts.length > 1) {
									obj.src = srcParts.shift();
									obj.opts.filter = srcParts.shift();
								}
							}
							if (obj.opts.modal) {
								obj.opts = $.extend(true, obj.opts, {
									infobar: 0,
									toolbar: 0,
									smallBtn: 0,
									keyboard: 0,
									slideShow: 0,
									fullScreen: 0,
									thumbs: 0,
									touch: 0,
									clickContent: false,
									clickSlide: false,
									clickOutside: false,
									dblclickContent: false,
									dblclickSlide: false,
									dblclickOutside: false
								});
							}
							self.group.push(obj);
						});
						if (Object.keys(self.slides).length) {
							self.updateControls();
							thumbs = self.Thumbs;
							if (thumbs && thumbs.isActive) {
								thumbs.create();
								thumbs.focus();
							}
						}
					},
					addEvents: function addEvents() {
						var self = this;
						self.removeEvents();
						self.$refs.container.on("click.fb-close", "[data-fancybox-close]", function (e) {
							e.stopPropagation();
							e.preventDefault();
							self.close(e);
						}).on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function (e) {
							e.stopPropagation();
							e.preventDefault();
							self.previous();
						}).on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function (e) {
							e.stopPropagation();
							e.preventDefault();
							self.next();
						}).on("click.fb", "[data-fancybox-zoom]", function (e) {
							self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();
						});
						$W.on("orientationchange.fb resize.fb", function (e) {
							if (e && e.originalEvent && e.originalEvent.type === "resize") {
								requestAFrame(function () {
									self.update();
								});
							} else {
								self.$refs.stage.hide();
								setTimeout(function () {
									self.$refs.stage.show();
									self.update();
								}, $.fancybox.isMobile ? 600 : 250);
							}
						});
						$D.on("focusin.fb", function (e) {
							var instance = $.fancybox ? $.fancybox.getInstance() : null;
							if (instance.isClosing || !instance.current || !instance.current.opts.trapFocus || $(e.target).hasClass("fancybox-container") || $(e.target).is(document)) {
								return;
							}
							if (instance && $(e.target).css("position") !== "fixed" && !instance.$refs.container.has(e.target).length) {
								e.stopPropagation();
								instance.focus();
							}
						});
						$D.on("keydown.fb", function (e) {
							var current = self.current,
								keycode = e.keyCode || e.which;
							if (!current || !current.opts.keyboard) {
								return;
							}
							if (e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input") || $(e.target).is("textarea")) {
								return;
							}
							if (keycode === 8 || keycode === 27) {
								e.preventDefault();
								self.close(e);
								return;
							}
							if (keycode === 37 || keycode === 38) {
								e.preventDefault();
								self.previous();
								return;
							}
							if (keycode === 39 || keycode === 40) {
								e.preventDefault();
								self.next();
								return;
							}
							self.trigger("afterKeydown", e, keycode);
						});
						if (self.group[self.currIndex].opts.idleTime) {
							self.idleSecondsCounter = 0;
							$D.on("mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle", function (e) {
								self.idleSecondsCounter = 0;
								if (self.isIdle) {
									self.showControls();
								}
								self.isIdle = false;
							});
							self.idleInterval = window.setInterval(function () {
								self.idleSecondsCounter++;
								if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
									self.isIdle = true;
									self.idleSecondsCounter = 0;
									self.hideControls();
								}
							}, 1000);
						}
					},
					removeEvents: function removeEvents() {
						var self = this;
						$W.off("orientationchange.fb resize.fb");
						$D.off("focusin.fb keydown.fb .fb-idle");
						this.$refs.container.off(".fb-close .fb-prev .fb-next");
						if (self.idleInterval) {
							window.clearInterval(self.idleInterval);
							self.idleInterval = null;
						}
					},
					previous: function previous(duration) {
						return this.jumpTo(this.currPos - 1, duration);
					},
					next: function next(duration) {
						return this.jumpTo(this.currPos + 1, duration);
					},
					jumpTo: function jumpTo(pos, duration) {
						var self = this,
							groupLen = self.group.length,
							firstRun, loop, current, previous, canvasWidth, currentPos, transitionProps;
						if (self.isDragging || self.isClosing || self.isAnimating && self.firstRun) {
							return;
						}
						pos = parseInt(pos, 10);
						loop = self.current ? self.current.opts.loop : self.opts.loop;
						if (!loop && (pos < 0 || pos >= groupLen)) {
							return false;
						}
						firstRun = self.firstRun = !Object.keys(self.slides).length;
						if (groupLen < 2 && !firstRun && !!self.isDragging) {
							return;
						}
						previous = self.current;
						self.prevIndex = self.currIndex;
						self.prevPos = self.currPos;
						current = self.createSlide(pos);
						if (groupLen > 1) {
							if (loop || current.index > 0) {
								self.createSlide(pos - 1);
							}
							if (loop || current.index < groupLen - 1) {
								self.createSlide(pos + 1);
							}
						}
						self.current = current;
						self.currIndex = current.index;
						self.currPos = current.pos;
						self.trigger("beforeShow", firstRun);
						self.updateControls();
						currentPos = $.fancybox.getTranslate(current.$slide);
						current.isMoved = (currentPos.left !== 0 || currentPos.top !== 0) && !current.$slide.hasClass("fancybox-animated");
						current.forcedDuration = undefined;
						if ($.isNumeric(duration)) {
							current.forcedDuration = duration;
						} else {
							duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];
						}
						duration = parseInt(duration, 10);
						if (firstRun) {
							if (current.opts.animationEffect && duration) {
								self.$refs.container.css("transition-duration", duration + "ms");
							}
							self.$refs.container.removeClass("fancybox-is-hidden");
							forceRedraw(self.$refs.container);
							self.$refs.container.addClass("fancybox-is-open");
							forceRedraw(self.$refs.container);
							current.$slide.addClass("fancybox-slide--previous");
							self.loadSlide(current);
							current.$slide.removeClass("fancybox-slide--previous").addClass("fancybox-slide--current");
							self.preload("image");
							return;
						}
						$.each(self.slides, function (index, slide) {
							$.fancybox.stop(slide.$slide);
						});
						current.$slide.removeClass("fancybox-slide--next fancybox-slide--previous").addClass("fancybox-slide--current");
						if (current.isMoved) {
							canvasWidth = Math.round(current.$slide.width());
							$.each(self.slides, function (index, slide) {
								var pos = slide.pos - current.pos;
								$.fancybox.animate(slide.$slide, {
									top: 0,
									left: pos * canvasWidth + pos * slide.opts.gutter
								}, duration, function () {
									slide.$slide.removeAttr("style").removeClass("fancybox-slide--next fancybox-slide--previous");
									if (slide.pos === self.currPos) {
										current.isMoved = false;
										self.complete();
									}
								});
							});
						} else {
							self.$refs.stage.children().removeAttr("style");
						}
						if (current.isLoaded) {
							self.revealContent(current);
						} else {
							self.loadSlide(current);
						}
						self.preload("image");
						if (previous.pos === current.pos) {
							return;
						}
						transitionProps = "fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous");
						previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current fancybox-slide--next fancybox-slide--previous");
						previous.isComplete = false;
						if (!duration || !current.isMoved && !current.opts.transitionEffect) {
							return;
						}
						if (current.isMoved) {
							previous.$slide.addClass(transitionProps);
						} else {
							transitionProps = "fancybox-animated " + transitionProps + " fancybox-fx-" + current.opts.transitionEffect;
							$.fancybox.animate(previous.$slide, transitionProps, duration, function () {
								previous.$slide.removeClass(transitionProps).removeAttr("style");
							});
						}
					},
					createSlide: function createSlide(pos) {
						var self = this,
							$slide, index;
						index = pos % self.group.length;
						index = index < 0 ? self.group.length + index : index;
						if (!self.slides[pos] && self.group[index]) {
							$slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);
							self.slides[pos] = $.extend(true, {}, self.group[index], {
								pos: pos,
								$slide: $slide,
								isLoaded: false
							});
							self.updateSlide(self.slides[pos]);
						}
						return self.slides[pos];
					},
					scaleToActual: function scaleToActual(x, y, duration) {
						var self = this,
							current = self.current,
							$content = current.$content,
							canvasWidth = $.fancybox.getTranslate(current.$slide).width,
							canvasHeight = $.fancybox.getTranslate(current.$slide).height,
							newImgWidth = current.width,
							newImgHeight = current.height,
							imgPos, posX, posY, scaleX, scaleY;
						if (self.isAnimating || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
							return;
						}
						$.fancybox.stop($content);
						self.isAnimating = true;
						x = x === undefined ? canvasWidth * 0.5 : x;
						y = y === undefined ? canvasHeight * 0.5 : y;
						imgPos = $.fancybox.getTranslate($content);
						imgPos.top -= $.fancybox.getTranslate(current.$slide).top;
						imgPos.left -= $.fancybox.getTranslate(current.$slide).left;
						scaleX = newImgWidth / imgPos.width;
						scaleY = newImgHeight / imgPos.height;
						posX = canvasWidth * 0.5 - newImgWidth * 0.5;
						posY = canvasHeight * 0.5 - newImgHeight * 0.5;
						if (newImgWidth > canvasWidth) {
							posX = imgPos.left * scaleX - (x * scaleX - x);
							if (posX > 0) {
								posX = 0;
							}
							if (posX < canvasWidth - newImgWidth) {
								posX = canvasWidth - newImgWidth;
							}
						}
						if (newImgHeight > canvasHeight) {
							posY = imgPos.top * scaleY - (y * scaleY - y);
							if (posY > 0) {
								posY = 0;
							}
							if (posY < canvasHeight - newImgHeight) {
								posY = canvasHeight - newImgHeight;
							}
						}
						self.updateCursor(newImgWidth, newImgHeight);
						$.fancybox.animate($content, {
							top: posY,
							left: posX,
							scaleX: scaleX,
							scaleY: scaleY
						}, duration || 330, function () {
							self.isAnimating = false;
						});
						if (self.SlideShow && self.SlideShow.isActive) {
							self.SlideShow.stop();
						}
					},
					scaleToFit: function scaleToFit(duration) {
						var self = this,
							current = self.current,
							$content = current.$content,
							end;
						if (self.isAnimating || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
							return;
						}
						$.fancybox.stop($content);
						self.isAnimating = true;
						end = self.getFitPos(current);
						self.updateCursor(end.width, end.height);
						$.fancybox.animate($content, {
							top: end.top,
							left: end.left,
							scaleX: end.width / $content.width(),
							scaleY: end.height / $content.height()
						}, duration || 330, function () {
							self.isAnimating = false;
						});
					},
					getFitPos: function getFitPos(slide) {
						var self = this,
							$content = slide.$content,
							width = slide.width || slide.opts.width,
							height = slide.height || slide.opts.height,
							maxWidth, maxHeight, minRatio, margin, aspectRatio, rez = {};
						if (!slide.isLoaded || !$content || !$content.length) {
							return false;
						}
						margin = {
							top: parseInt(slide.$slide.css("paddingTop"), 10),
							right: parseInt(slide.$slide.css("paddingRight"), 10),
							bottom: parseInt(slide.$slide.css("paddingBottom"), 10),
							left: parseInt(slide.$slide.css("paddingLeft"), 10)
						};
						maxWidth = parseInt(self.$refs.stage.width(), 10) - (margin.left + margin.right);
						maxHeight = parseInt(self.$refs.stage.height(), 10) - (margin.top + margin.bottom);
						if (!width || !height) {
							width = maxWidth;
							height = maxHeight;
						}
						minRatio = Math.min(1, maxWidth / width, maxHeight / height);
						width = Math.floor(minRatio * width);
						height = Math.floor(minRatio * height);
						if (slide.type === "image") {
							rez.top = Math.floor((maxHeight - height) * 0.5) + margin.top;
							rez.left = Math.floor((maxWidth - width) * 0.5) + margin.left;
						} else if (slide.contentType === "video") {
							aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;
							if (height > width / aspectRatio) {
								height = width / aspectRatio;
							} else if (width > height * aspectRatio) {
								width = height * aspectRatio;
							}
						}
						rez.width = width;
						rez.height = height;
						return rez;
					},
					update: function update() {
						var self = this;
						$.each(self.slides, function (key, slide) {
							self.updateSlide(slide);
						});
					},
					updateSlide: function updateSlide(slide, duration) {
						var self = this,
							$content = slide && slide.$content,
							width = slide.width || slide.opts.width,
							height = slide.height || slide.opts.height;
						if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {
							$.fancybox.stop($content);
							$.fancybox.setTranslate($content, self.getFitPos(slide));
							if (slide.pos === self.currPos) {
								self.isAnimating = false;
								self.updateCursor();
							}
						}
						slide.$slide.trigger("refresh");
						self.$refs.toolbar.toggleClass("compensate-for-scrollbar", slide.$slide.get(0).scrollHeight > slide.$slide.get(0).clientHeight);
						self.trigger("onUpdate", slide);
					},
					centerSlide: function centerSlide(slide, duration) {
						var self = this,
							canvasWidth, pos;
						if (self.current) {
							canvasWidth = Math.round(slide.$slide.width());
							pos = slide.pos - self.current.pos;
							$.fancybox.animate(slide.$slide, {
								top: 0,
								left: pos * canvasWidth + pos * slide.opts.gutter,
								opacity: 1
							}, duration === undefined ? 0 : duration, null, false);
						}
					},
					updateCursor: function updateCursor(nextWidth, nextHeight) {
						var self = this,
							current = self.current,
							$container = self.$refs.container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-drag fancybox-can-zoomOut"),
							isZoomable;
						if (!current || self.isClosing) {
							return;
						}
						isZoomable = self.isZoomable();
						$container.toggleClass("fancybox-is-zoomable", isZoomable);
						$("[data-fancybox-zoom]").prop("disabled", !isZoomable);
						if (isZoomable && (current.opts.clickContent === "zoom" || $.isFunction(current.opts.clickContent) && current.opts.clickContent(current) === "zoom")) {
							if (self.isScaledDown(nextWidth, nextHeight)) {
								$container.addClass("fancybox-can-zoomIn");
							} else {
								if (current.opts.touch) {
									$container.addClass("fancybox-can-drag");
								} else {
									$container.addClass("fancybox-can-zoomOut");
								}
							}
						} else if (current.opts.touch && current.contentType !== "video") {
							$container.addClass("fancybox-can-drag");
						}
					},
					isZoomable: function isZoomable() {
						var self = this,
							current = self.current,
							fitPos;
						if (current && !self.isClosing && current.type === "image" && !current.hasError) {
							if (!current.isLoaded) {
								return true;
							}
							fitPos = self.getFitPos(current);
							if (current.width > fitPos.width || current.height > fitPos.height) {
								return true;
							}
						}
						return false;
					},
					isScaledDown: function isScaledDown(nextWidth, nextHeight) {
						var self = this,
							rez = false,
							current = self.current,
							$content = current.$content;
						if (nextWidth !== undefined && nextHeight !== undefined) {
							rez = nextWidth < current.width && nextHeight < current.height;
						} else if ($content) {
							rez = $.fancybox.getTranslate($content);
							rez = rez.width < current.width && rez.height < current.height;
						}
						return rez;
					},
					canPan: function canPan() {
						var self = this,
							rez = false,
							current = self.current,
							$content;
						if (current.type === "image" && ($content = current.$content) && !current.hasError) {
							rez = self.getFitPos(current);
							rez = Math.abs($content.width() - rez.width) > 1 || Math.abs($content.height() - rez.height) > 1;
						}
						return rez;
					},
					loadSlide: function loadSlide(slide) {
						var self = this,
							type, $slide, ajaxLoad;
						if (slide.isLoading || slide.isLoaded) {
							return;
						}
						slide.isLoading = true;
						self.trigger("beforeLoad", slide);
						type = slide.type;
						$slide = slide.$slide;
						$slide.off("refresh").trigger("onReset").addClass(slide.opts.slideClass);
						switch (type) {
							case "image":
								self.setImage(slide);
								break;
							case "iframe":
								self.setIframe(slide);
								break;
							case "html":
								self.setContent(slide, slide.src || slide.content);
								break;
							case "video":
								self.setContent(slide, '<video class="fancybox-video" controls controlsList="nodownload">' + '<source src="' + slide.src + '" type="' + slide.opts.videoFormat + '">' + "Your browser doesn't support HTML5 video" + "</video");
								break;
							case "inline":
								if ($(slide.src).length) {
									self.setContent(slide, $(slide.src));
								} else {
									self.setError(slide);
								}
								break;
							case "ajax":
								self.showLoading(slide);
								ajaxLoad = $.ajax($.extend({}, slide.opts.ajax.settings, {
									url: slide.src,
									success: function success(data, textStatus) {
										if (textStatus === "success") {
											self.setContent(slide, data);
										}
									},
									error: function error(jqXHR, textStatus) {
										if (jqXHR && textStatus !== "abort") {
											self.setError(slide);
										}
									}
								}));
								$slide.one("onReset", function () {
									ajaxLoad.abort();
								});
								break;
							default:
								self.setError(slide);
								break;
						}
						return true;
					},
					setImage: function setImage(slide) {
						var self = this,
							srcset = slide.opts.srcset || slide.opts.image.srcset,
							thumbSrc, found, temp, pxRatio, windowWidth;
						slide.timouts = setTimeout(function () {
							var $img = slide.$image;
							if (slide.isLoading && (!$img || !$img[0].complete) && !slide.hasError) {
								self.showLoading(slide);
							}
						}, 350);
						if (srcset) {
							pxRatio = window.devicePixelRatio || 1;
							windowWidth = window.innerWidth * pxRatio;
							temp = srcset.split(",").map(function (el) {
								var ret = {};
								el.trim().split(/\s+/).forEach(function (el, i) {
									var value = parseInt(el.substring(0, el.length - 1), 10);
									if (i === 0) {
										return ret.url = el;
									}
									if (value) {
										ret.value = value;
										ret.postfix = el[el.length - 1];
									}
								});
								return ret;
							});
							temp.sort(function (a, b) {
								return a.value - b.value;
							});
							for (var j = 0; j < temp.length; j++) {
								var el = temp[j];
								if (el.postfix === "w" && el.value >= windowWidth || el.postfix === "x" && el.value >= pxRatio) {
									found = el;
									break;
								}
							}
							if (!found && temp.length) {
								found = temp[temp.length - 1];
							}
							if (found) {
								slide.src = found.url;
								if (slide.width && slide.height && found.postfix == "w") {
									slide.height = slide.width / slide.height * found.value;
									slide.width = found.value;
								}
								slide.opts.srcset = srcset;
							}
						}
						slide.$content = $('<div class="fancybox-content"></div>').addClass("fancybox-is-hidden").appendTo(slide.$slide.addClass("fancybox-slide--image"));
						thumbSrc = slide.opts.thumb || (slide.opts.$thumb && slide.opts.$thumb.length ? slide.opts.$thumb.attr("src") : false);
						if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && thumbSrc) {
							slide.width = slide.opts.width;
							slide.height = slide.opts.height;
							slide.$ghost = $("<img />").one("error", function () {
								$(this).remove();
								slide.$ghost = null;
							}).one("load", function () {
								self.afterLoad(slide);
							}).addClass("fancybox-image").appendTo(slide.$content).attr("src", thumbSrc);
						}
						self.setBigImage(slide);
					},
					setBigImage: function setBigImage(slide) {
						var self = this,
							$img = $("<img />");
						slide.$image = $img.one("error", function () {
							self.setError(slide);
						}).one("load", function () {
							var sizes;
							if (!slide.$ghost) {
								self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);
								self.afterLoad(slide);
							}
							if (slide.timouts) {
								clearTimeout(slide.timouts);
								slide.timouts = null;
							}
							if (self.isClosing) {
								return;
							}
							if (slide.opts.srcset) {
								sizes = slide.opts.sizes;
								if (!sizes || sizes === "auto") {
									sizes = (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? "100" : Math.round(slide.width / slide.height * 100)) + "vw";
								}
								$img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);
							}
							if (slide.$ghost) {
								setTimeout(function () {
									if (slide.$ghost && !self.isClosing) {
										slide.$ghost.hide();
									}
								}, Math.min(300, Math.max(1000, slide.height / 1600)));
							}
							self.hideLoading(slide);
						}).addClass("fancybox-image").attr("src", slide.src).appendTo(slide.$content);
						if (($img[0].complete || $img[0].readyState == "complete") && $img[0].naturalWidth && $img[0].naturalHeight) {
							$img.trigger("load");
						} else if ($img[0].error) {
							$img.trigger("error");
						}
					},
					resolveImageSlideSize: function resolveImageSlideSize(slide, imgWidth, imgHeight) {
						var maxWidth = parseInt(slide.opts.width, 10),
							maxHeight = parseInt(slide.opts.height, 10);
						slide.width = imgWidth;
						slide.height = imgHeight;
						if (maxWidth > 0) {
							slide.width = maxWidth;
							slide.height = Math.floor(maxWidth * imgHeight / imgWidth);
						}
						if (maxHeight > 0) {
							slide.width = Math.floor(maxHeight * imgWidth / imgHeight);
							slide.height = maxHeight;
						}
					},
					setIframe: function setIframe(slide) {
						var self = this,
							opts = slide.opts.iframe,
							$slide = slide.$slide,
							$iframe;
						slide.$content = $('<div class="fancybox-content' + (opts.preload ? " fancybox-is-hidden" : "") + '"></div>').css(opts.css).appendTo($slide);
						$slide.addClass("fancybox-slide--" + slide.contentType);
						slide.$iframe = $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime())).attr(opts.attr).appendTo(slide.$content);
						if (opts.preload) {
							self.showLoading(slide);
							$iframe.on("load.fb error.fb", function (e) {
								this.isReady = 1;
								slide.$slide.trigger("refresh");
								self.afterLoad(slide);
							});
							$slide.on("refresh.fb", function () {
								var $content = slide.$content,
									frameWidth = opts.css.width,
									frameHeight = opts.css.height,
									$contents, $body;
								if ($iframe[0].isReady !== 1) {
									return;
								}
								try {
									$contents = $iframe.contents();
									$body = $contents.find("body");
								} catch (ignore) { }
								if ($body && $body.length && $body.children().length) {
									$content.css({
										width: "",
										height: ""
									});
									if (frameWidth === undefined) {
										frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));
									}
									if (frameWidth) {
										$content.width(frameWidth);
									}
									if (frameHeight === undefined) {
										frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));
									}
									if (frameHeight) {
										$content.height(frameHeight);
									}
								}
								$content.removeClass("fancybox-is-hidden");
							});
						} else {
							this.afterLoad(slide);
						}
						$iframe.attr("src", slide.src);
						$slide.one("onReset", function () {
							try {
								$(this).find("iframe").hide().unbind().attr("src", "//about:blank");
							} catch (ignore) { }
							$(this).off("refresh.fb").empty();
							slide.isLoaded = false;
						});
					},
					setContent: function setContent(slide, content) {
						var self = this;
						if (self.isClosing) {
							return;
						}
						self.hideLoading(slide);
						if (slide.$content) {
							$.fancybox.stop(slide.$content);
						}
						slide.$slide.empty();
						if (isQuery(content) && content.parent().length) {
							content.parent().parent(".fancybox-slide--inline").trigger("onReset");
							slide.$placeholder = $("<div>").hide().insertAfter(content);
							content.css("display", "inline-block");
						} else if (!slide.hasError) {
							if ($.type(content) === "string") {
								content = $("<div>").append($.trim(content)).contents();
								if (content[0].nodeType === 3) {
									content = $("<div>").html(content);
								}
							}
							if (slide.opts.filter) {
								content = $("<div>").html(content).find(slide.opts.filter);
							}
						}
						slide.$slide.one("onReset", function () {
							$(this).find("video,audio").trigger("pause");
							if (slide.$placeholder) {
								slide.$placeholder.after(content.hide()).remove();
								slide.$placeholder = null;
							}
							if (slide.$smallBtn) {
								slide.$smallBtn.remove();
								slide.$smallBtn = null;
							}
							if (!slide.hasError) {
								$(this).empty();
								slide.isLoaded = false;
							}
						});
						$(content).appendTo(slide.$slide);
						if ($(content).is("video,audio")) {
							$(content).addClass("fancybox-video");
							$(content).wrap("<div></div>");
							slide.contentType = "video";
							slide.opts.width = slide.opts.width || $(content).attr("width");
							slide.opts.height = slide.opts.height || $(content).attr("height");
						}
						slide.$content = slide.$slide.children().filter("div,form,main,video,audio").first().addClass("fancybox-content");
						slide.$slide.addClass("fancybox-slide--" + slide.contentType);
						this.afterLoad(slide);
					},
					setError: function setError(slide) {
						slide.hasError = true;
						slide.$slide.trigger("onReset").removeClass("fancybox-slide--" + slide.contentType).addClass("fancybox-slide--error");
						slide.contentType = "html";
						this.setContent(slide, this.translate(slide, slide.opts.errorTpl));
						if (slide.pos === this.currPos) {
							this.isAnimating = false;
						}
					},
					showLoading: function showLoading(slide) {
						var self = this;
						slide = slide || self.current;
						if (slide && !slide.$spinner) {
							slide.$spinner = $(self.translate(self, self.opts.spinnerTpl)).appendTo(slide.$slide);
						}
					},
					hideLoading: function hideLoading(slide) {
						var self = this;
						slide = slide || self.current;
						if (slide && slide.$spinner) {
							slide.$spinner.remove();
							delete slide.$spinner;
						}
					},
					afterLoad: function afterLoad(slide) {
						var self = this;
						if (self.isClosing) {
							return;
						}
						slide.isLoading = false;
						slide.isLoaded = true;
						self.trigger("afterLoad", slide);
						self.hideLoading(slide);
						if (slide.pos === self.currPos) {
							self.updateCursor();
						}
						if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {
							slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).prependTo(slide.$content);
						}
						if (slide.opts.protect && slide.$content && !slide.hasError) {
							slide.$content.on("contextmenu.fb", function (e) {
								if (e.button == 2) {
									e.preventDefault();
								}
								return true;
							});
							if (slide.type === "image") {
								$('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
							}
						}
						self.revealContent(slide);
					},
					revealContent: function revealContent(slide) {
						var self = this,
							$slide = slide.$slide,
							end = false,
							start = false,
							effect, effectClassName, duration, opacity;
						effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];
						duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];
						duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);
						if (slide.pos === self.currPos) {
							if (slide.isComplete) {
								effect = false;
							} else {
								self.isAnimating = true;
							}
						}
						if (slide.isMoved || slide.pos !== self.currPos || !duration) {
							effect = false;
						}
						if (effect === "zoom") {
							if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {
								end = self.getFitPos(slide);
							} else {
								effect = "fade";
							}
						}
						if (effect === "zoom") {
							end.scaleX = end.width / start.width;
							end.scaleY = end.height / start.height;
							opacity = slide.opts.zoomOpacity;
							if (opacity == "auto") {
								opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
							}
							if (opacity) {
								start.opacity = 0.1;
								end.opacity = 1;
							}
							$.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);
							forceRedraw(slide.$content);
							$.fancybox.animate(slide.$content, end, duration, function () {
								self.isAnimating = false;
								self.complete();
							});
							return;
						}
						self.updateSlide(slide);
						if (!effect) {
							forceRedraw($slide);
							slide.$content.removeClass("fancybox-is-hidden");
							if (slide.pos === self.currPos) {
								self.complete();
							}
							return;
						}
						$.fancybox.stop($slide);
						effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;
						$slide.removeAttr("style").removeClass("fancybox-slide--current fancybox-slide--next fancybox-slide--previous").addClass(effectClassName);
						slide.$content.removeClass("fancybox-is-hidden");
						forceRedraw($slide);
						$.fancybox.animate($slide, "fancybox-slide--current", duration, function (e) {
							$slide.removeClass(effectClassName).removeAttr("style");
							if (slide.pos === self.currPos) {
								self.complete();
							}
						}, true);
					},
					getThumbPos: function getThumbPos(slide) {
						var self = this,
							rez = false,
							$thumb = slide.opts.$thumb,
							thumbPos = $thumb && $thumb.length && $thumb[0].ownerDocument === document ? $thumb.offset() : 0,
							slidePos;
						var isElementVisible = function isElementVisible($el) {
							var element = $el[0],
								elementRect = element.getBoundingClientRect(),
								parentRects = [],
								visibleInAllParents;
							while (element.parentElement !== null) {
								if ($(element.parentElement).css("overflow") === "hidden" || $(element.parentElement).css("overflow") === "auto") {
									parentRects.push(element.parentElement.getBoundingClientRect());
								}
								element = element.parentElement;
							}
							visibleInAllParents = parentRects.every(function (parentRect) {
								var visiblePixelX = Math.min(elementRect.right, parentRect.right) - Math.max(elementRect.left, parentRect.left);
								var visiblePixelY = Math.min(elementRect.bottom, parentRect.bottom) - Math.max(elementRect.top, parentRect.top);
								return visiblePixelX > 0 && visiblePixelY > 0;
							});
							return visibleInAllParents && elementRect.bottom > 0 && elementRect.right > 0 && elementRect.left < $(window).width() && elementRect.top < $(window).height();
						};
						if (thumbPos && isElementVisible($thumb)) {
							slidePos = self.$refs.stage.offset();
							rez = {
								top: thumbPos.top - slidePos.top + parseFloat($thumb.css("border-top-width") || 0),
								left: thumbPos.left - slidePos.left + parseFloat($thumb.css("border-left-width") || 0),
								width: $thumb.width(),
								height: $thumb.height(),
								scaleX: 1,
								scaleY: 1
							};
						}
						return rez;
					},
					complete: function complete() {
						var self = this,
							current = self.current,
							slides = {};
						if (current.isMoved || !current.isLoaded) {
							return;
						}
						if (!current.isComplete) {
							current.isComplete = true;
							current.$slide.siblings().trigger("onReset");
							self.preload("inline");
							forceRedraw(current.$slide);
							current.$slide.addClass("fancybox-slide--complete");
							$.each(self.slides, function (key, slide) {
								if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
									slides[slide.pos] = slide;
								} else if (slide) {
									$.fancybox.stop(slide.$slide);
									slide.$slide.off().remove();
								}
							});
							self.slides = slides;
						}
						self.isAnimating = false;
						self.updateCursor();
						self.trigger("afterShow");
						current.$slide.find("video,audio").filter(":visible:first").trigger("play");
						if ($(document.activeElement).is("[disabled]") || current.opts.autoFocus && !(current.type == "image" || current.type === "iframe")) {
							self.focus();
						}
					},
					preload: function preload(type) {
						var self = this,
							next = self.slides[self.currPos + 1],
							prev = self.slides[self.currPos - 1];
						if (next && next.type === type) {
							self.loadSlide(next);
						}
						if (prev && prev.type === type) {
							self.loadSlide(prev);
						}
					},
					focus: function focus() {
						var current = this.current,
							$el;
						if (this.isClosing) {
							return;
						}
						if (current && current.isComplete && current.$content) {
							$el = current.$content.find("input[autofocus]:enabled:visible:first");
							if (!$el.length) {
								$el = current.$content.find("button,:input,[tabindex],a").filter(":enabled:visible:first");
							}
							$el = $el && $el.length ? $el : current.$content;
							$el.trigger("focus");
						}
					},
					activate: function activate() {
						var self = this;
						$(".fancybox-container").each(function () {
							var instance = $(this).data("FancyBox");
							if (instance && instance.id !== self.id && !instance.isClosing) {
								instance.trigger("onDeactivate");
								instance.removeEvents();
								instance.isVisible = false;
							}
						});
						self.isVisible = true;
						if (self.current || self.isIdle) {
							self.update();
							self.updateControls();
						}
						self.trigger("onActivate");
						self.addEvents();
					},
					close: function close(e, d) {
						var self = this,
							current = self.current,
							effect, duration, $content, domRect, opacity, start, end;
						var done = function done() {
							self.cleanUp(e);
						};
						if (self.isClosing) {
							return false;
						}
						self.isClosing = true;
						if (self.trigger("beforeClose", e) === false) {
							self.isClosing = false;
							requestAFrame(function () {
								self.update();
							});
							return false;
						}
						self.removeEvents();
						if (current.timouts) {
							clearTimeout(current.timouts);
						}
						$content = current.$content;
						effect = current.opts.animationEffect;
						duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;
						current.$slide.off(transitionEnd).removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");
						current.$slide.siblings().trigger("onReset").remove();
						if (duration) {
							self.$refs.container.removeClass("fancybox-is-open").addClass("fancybox-is-closing");
						}
						self.hideLoading(current);
						self.hideControls();
						self.updateCursor();
						if (effect === "zoom" && !(e !== true && $content && duration && current.type === "image" && !current.hasError && (end = self.getThumbPos(current)))) {
							effect = "fade";
						}
						if (effect === "zoom") {
							$.fancybox.stop($content);
							domRect = $.fancybox.getTranslate($content);
							start = {
								top: domRect.top,
								left: domRect.left,
								scaleX: domRect.width / end.width,
								scaleY: domRect.height / end.height,
								width: end.width,
								height: end.height
							};
							opacity = current.opts.zoomOpacity;
							if (opacity == "auto") {
								opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
							}
							if (opacity) {
								end.opacity = 0;
							}
							$.fancybox.setTranslate($content, start);
							forceRedraw($content);
							$.fancybox.animate($content, end, duration, done);
							return true;
						}
						if (effect && duration) {
							if (e === true) {
								setTimeout(done, duration);
							} else {
								$.fancybox.animate(current.$slide.removeClass("fancybox-slide--current"), "fancybox-animated fancybox-slide--previous fancybox-fx-" + effect, duration, done);
							}
						} else {
							done();
						}
						return true;
					},
					cleanUp: function cleanUp(e) {
						var self = this,
							$body = $("body"),
							instance, scrollTop;
						self.current.$slide.trigger("onReset");
						self.$refs.container.empty().remove();
						self.trigger("afterClose", e);
						if (self.$lastFocus && !!self.current.opts.backFocus) {
							self.$lastFocus.trigger("focus");
						}
						self.current = null;
						instance = $.fancybox.getInstance();
						if (instance) {
							instance.activate();
						} else {
							$body.removeClass("fancybox-active compensate-for-scrollbar");
							$("#fancybox-style-noscroll").remove();
						}
					},
					trigger: function trigger(name, slide) {
						var args = Array.prototype.slice.call(arguments, 1),
							self = this,
							obj = slide && slide.opts ? slide : self.current,
							rez;
						if (obj) {
							args.unshift(obj);
						} else {
							obj = self;
						}
						args.unshift(self);
						if ($.isFunction(obj.opts[name])) {
							rez = obj.opts[name].apply(obj, args);
						}
						if (rez === false) {
							return rez;
						}
						if (name === "afterClose" || !self.$refs) {
							$D.trigger(name + ".fb", args);
						} else {
							self.$refs.container.trigger(name + ".fb", args);
						}
					},
					updateControls: function updateControls(force) {
						var self = this,
							current = self.current,
							index = current.index,
							caption = current.opts.caption,
							$container = self.$refs.container,
							$caption = self.$refs.caption;
						current.$slide.trigger("refresh");
						self.$caption = caption && caption.length ? $caption.html(caption) : null;
						if (!self.isHiddenControls && !self.isIdle) {
							self.showControls();
						}
						$container.find("[data-fancybox-count]").html(self.group.length);
						$container.find("[data-fancybox-index]").html(index + 1);
						$container.find("[data-fancybox-prev]").toggleClass("disabled", !current.opts.loop && index <= 0);
						$container.find("[data-fancybox-next]").toggleClass("disabled", !current.opts.loop && index >= self.group.length - 1);
						if (current.type === "image") {
							$container.find("[data-fancybox-zoom]").show().end().find("[data-fancybox-download]").attr("href", current.opts.image.src || current.src).show();
						} else if (current.opts.toolbar) {
							$container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();
						}
					},
					hideControls: function hideControls() {
						this.isHiddenControls = true;
						this.$refs.container.removeClass("fancybox-show-infobar fancybox-show-toolbar fancybox-show-caption fancybox-show-nav");
					},
					showControls: function showControls() {
						var self = this,
							opts = self.current ? self.current.opts : self.opts,
							$container = self.$refs.container;
						self.isHiddenControls = false;
						self.idleSecondsCounter = 0;
						$container.toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons)).toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1)).toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1)).toggleClass("fancybox-is-modal", !!opts.modal);
						if (self.$caption) {
							$container.addClass("fancybox-show-caption ");
						} else {
							$container.removeClass("fancybox-show-caption");
						}
					},
					toggleControls: function toggleControls() {
						if (this.isHiddenControls) {
							this.showControls();
						} else {
							this.hideControls();
						}
					}
				});
				$.fancybox = {
					version: "3.3.5",
					defaults: defaults,
					getInstance: function getInstance(command) {
						var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
							args = Array.prototype.slice.call(arguments, 1);
						if (instance instanceof FancyBox) {
							if ($.type(command) === "string") {
								instance[command].apply(instance, args);
							} else if ($.type(command) === "function") {
								command.apply(instance, args);
							}
							return instance;
						}
						return false;
					},
					open: function open(items, opts, index) {
						return new FancyBox(items, opts, index);
					},
					close: function close(all) {
						var instance = this.getInstance();
						if (instance) {
							instance.close();
							if (all === true) {
								this.close();
							}
						}
					},
					destroy: function destroy() {
						this.close(true);
						$D.add("body").off("click.fb-start", "**");
					},
					isMobile: document.createTouch !== undefined && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
					use3d: function () {
						var div = document.createElement("div");
						return window.getComputedStyle && window.getComputedStyle(div) && window.getComputedStyle(div).getPropertyValue("transform") && !(document.documentMode && document.documentMode < 11);
					}(),
					getTranslate: function getTranslate($el) {
						var domRect;
						if (!$el || !$el.length) {
							return false;
						}
						domRect = $el[0].getBoundingClientRect();
						return {
							top: domRect.top || 0,
							left: domRect.left || 0,
							width: domRect.width,
							height: domRect.height,
							opacity: parseFloat($el.css("opacity"))
						};
					},
					setTranslate: function setTranslate($el, props) {
						var str = "",
							css = {};
						if (!$el || !props) {
							return;
						}
						if (props.left !== undefined || props.top !== undefined) {
							str = (props.left === undefined ? $el.position().left : props.left) + "px, " + (props.top === undefined ? $el.position().top : props.top) + "px";
							if (this.use3d) {
								str = "translate3d(" + str + ", 0px)";
							} else {
								str = "translate(" + str + ")";
							}
						}
						if (props.scaleX !== undefined && props.scaleY !== undefined) {
							str = (str.length ? str + " " : "") + "scale(" + props.scaleX + ", " + props.scaleY + ")";
						}
						if (str.length) {
							css.transform = str;
						}
						if (props.opacity !== undefined) {
							css.opacity = props.opacity;
						}
						if (props.width !== undefined) {
							css.width = props.width;
						}
						if (props.height !== undefined) {
							css.height = props.height;
						}
						return $el.css(css);
					},
					animate: function animate($el, to, duration, callback, leaveAnimationName) {
						var final = false;
						if ($.isFunction(duration)) {
							callback = duration;
							duration = null;
						}
						if (!$.isPlainObject(to)) {
							$el.removeAttr("style");
						}
						$.fancybox.stop($el);
						$el.on(transitionEnd, function (e) {
							if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {
								return;
							}
							$.fancybox.stop($el);
							if (final) {
								$.fancybox.setTranslate($el, final);
							}
							if ($.isPlainObject(to)) {
								if (leaveAnimationName === false) {
									$el.removeAttr("style");
								}
							} else if (leaveAnimationName !== true) {
								$el.removeClass(to);
							}
							if ($.isFunction(callback)) {
								callback(e);
							}
						});
						if ($.isNumeric(duration)) {
							$el.css("transition-duration", duration + "ms");
						}
						if ($.isPlainObject(to)) {
							if (to.scaleX !== undefined && to.scaleY !== undefined) {
								final = $.extend({}, to, {
									width: $el.width() * to.scaleX,
									height: $el.height() * to.scaleY,
									scaleX: 1,
									scaleY: 1
								});
								delete to.width;
								delete to.height;
								if ($el.parent().hasClass("fancybox-slide--image")) {
									$el.parent().addClass("fancybox-is-scaling");
								}
							}
							$.fancybox.setTranslate($el, to);
						} else {
							$el.addClass(to);
						}
						$el.data("timer", setTimeout(function () {
							$el.trigger("transitionend");
						}, duration + 16));
					},
					stop: function stop($el) {
						if ($el && $el.length) {
							clearTimeout($el.data("timer"));
							$el.off("transitionend").css("transition-duration", "");
							$el.parent().removeClass("fancybox-is-scaling");
						}
					}
				};

				function _run(e, opts) {
					var items = [],
						index = 0,
						$target, value;
					if (e && e.isDefaultPrevented()) {
						return;
					}
					e.preventDefault();
					opts = e && e.data ? e.data.options : opts || {};
					$target = opts.$target || $(e.currentTarget);
					value = $target.attr("data-fancybox") || "";
					if (value) {
						items = opts.selector ? $(opts.selector) : e.data ? e.data.items : [];
						items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');
						index = items.index($target);
						if (index < 0) {
							index = 0;
						}
					} else {
						items = [$target];
					}
					$.fancybox.open(items, opts, index);
				}
				$.fn.fancybox = function (options) {
					var selector;
					options = options || {};
					selector = options.selector || false;
					if (selector) {
						$("body").off("click.fb-start", selector).on("click.fb-start", selector, {
							options: options
						}, _run);
					} else {
						this.off("click.fb-start").on("click.fb-start", {
							items: this,
							options: options
						}, _run);
					}
					return this;
				};
				$D.on("click.fb-start", "[data-fancybox]", _run);
				$D.on("click.fb-start", "[data-trigger]", function (e) {
					_run(e, {
						$target: $('[data-fancybox="' + $(e.currentTarget).attr("data-trigger") + '"]').eq($(e.currentTarget).attr("data-index") || 0),
						$trigger: $(this)
					});
				});
			})(window, document, __webpack_provided_window_dot_jQuery || jQuery);
			(function ($) {
				"use strict";
				var format = function format(url, rez, params) {
					if (!url) {
						return;
					}
					params = params || "";
					if ($.type(params) === "object") {
						params = $.param(params, true);
					}
					$.each(rez, function (key, value) {
						url = url.replace("$" + key, value || "");
					});
					if (params.length) {
						url += (url.indexOf("?") > 0 ? "&" : "?") + params;
					}
					return url;
				};
				var defaults = {
					youtube: {
						matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
						params: {
							autoplay: 1,
							autohide: 1,
							fs: 1,
							rel: 0,
							hd: 1,
							wmode: "transparent",
							enablejsapi: 1,
							html5: 1
						},
						paramPlace: 8,
						type: "iframe",
						url: "",
						thumb: ""
					},
					vimeo: {
						matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
						params: {
							autoplay: 1,
							hd: 1,
							show_title: 1,
							show_byline: 1,
							show_portrait: 0,
							fullscreen: 1,
							api: 1
						},
						paramPlace: 3,
						type: "iframe",
						url: ""
					},
					instagram: {
						matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
						type: "image",
						url: ""
					},
					gmap_place: {
						matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
						type: "iframe",
						url: function url(rez) {
							return "//maps.google." + rez[2] + "/?ll=" + (rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : "") : rez[12] + "").replace(/\?/, "&") + "&output=" + (rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed");
						}
					},
					gmap_search: {
						matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
						type: "iframe",
						url: function url(rez) {
							return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";
						}
					}
				};
				$(document).on("objectNeedsType.fb", function (e, instance, item) {
					var url = item.src || "",
						type = false,
						media, thumb, rez, params, urlParams, paramObj, provider;
					media = $.extend(true, {}, defaults, item.opts.media);
					$.each(media, function (providerName, providerOpts) {
						rez = url.match(providerOpts.matcher);
						if (!rez) {
							return;
						}
						type = providerOpts.type;
						provider = providerName;
						paramObj = {};
						if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
							urlParams = rez[providerOpts.paramPlace];
							if (urlParams[0] == "?") {
								urlParams = urlParams.substring(1);
							}
							urlParams = urlParams.split("&");
							for (var m = 0; m < urlParams.length; ++m) {
								var p = urlParams[m].split("=", 2);
								if (p.length == 2) {
									paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
								}
							}
						}
						params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);
						url = $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);
						thumb = $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);
						if (providerName === "youtube") {
							url = url.replace(/&t=((\d+)m)?(\d+)s/, function (match, p1, m, s) {
								return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));
							});
						} else if (providerName === "vimeo") {
							url = url.replace("&%23", "#");
						}
						return false;
					});
					if (type) {
						if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
							item.opts.thumb = thumb;
						}
						if (type === "iframe") {
							item.opts = $.extend(true, item.opts, {
								iframe: {
									preload: false,
									attr: {
										scrolling: "no"
									}
								}
							});
						}
						$.extend(item, {
							type: type,
							src: url,
							origSrc: item.src,
							contentSource: provider,
							contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"
						});
					} else if (url) {
						item.type = item.opts.defaultType;
					}
				});
			})(__webpack_provided_window_dot_jQuery || jQuery);
			(function (window, document, $) {
				"use strict";
				var requestAFrame = function () {
					return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) {
						return window.setTimeout(callback, 1000 / 60);
					};
				}();
				var cancelAFrame = function () {
					return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function (id) {
						window.clearTimeout(id);
					};
				}();
				var getPointerXY = function getPointerXY(e) {
					var result = [];
					e = e.originalEvent || e || window.e;
					e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];
					for (var key in e) {
						if (e[key].pageX) {
							result.push({
								x: e[key].pageX,
								y: e[key].pageY
							});
						} else if (e[key].clientX) {
							result.push({
								x: e[key].clientX,
								y: e[key].clientY
							});
						}
					}
					return result;
				};
				var distance = function distance(point2, point1, what) {
					if (!point1 || !point2) {
						return 0;
					}
					if (what === "x") {
						return point2.x - point1.x;
					} else if (what === "y") {
						return point2.y - point1.y;
					}
					return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
				};
				var isClickable = function isClickable($el) {
					if ($el.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio') || $.isFunction($el.get(0).onclick) || $el.data("selectable")) {
						return true;
					}
					for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
						if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {
							return true;
						}
					}
					return false;
				};
				var hasScrollbars = function hasScrollbars(el) {
					var overflowY = window.getComputedStyle(el)["overflow-y"],
						overflowX = window.getComputedStyle(el)["overflow-x"],
						vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,
						horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;
					return vertical || horizontal;
				};
				var isScrollable = function isScrollable($el) {
					var rez = false;
					while (true) {
						rez = hasScrollbars($el.get(0));
						if (rez) {
							break;
						}
						$el = $el.parent();
						if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {
							break;
						}
					}
					return rez;
				};
				var Guestures = function Guestures(instance) {
					var self = this;
					self.instance = instance;
					self.$bg = instance.$refs.bg;
					self.$stage = instance.$refs.stage;
					self.$container = instance.$refs.container;
					self.destroy();
					self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));
				};
				Guestures.prototype.destroy = function () {
					this.$container.off(".fb.touch");
				};
				Guestures.prototype.ontouchstart = function (e) {
					var self = this,
						$target = $(e.target),
						instance = self.instance,
						current = instance.current,
						$content = current.$content,
						isTouchDevice = e.type == "touchstart";
					if (isTouchDevice) {
						self.$container.off("mousedown.fb.touch");
					}
					if (e.originalEvent && e.originalEvent.button == 2) {
						return;
					}
					if (!$target.length || isClickable($target) || isClickable($target.parent())) {
						return;
					}
					if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
						return;
					}
					if (!current || instance.isAnimating || instance.isClosing) {
						e.stopPropagation();
						e.preventDefault();
						return;
					}
					self.realPoints = self.startPoints = getPointerXY(e);
					if (!self.startPoints.length) {
						return;
					}
					e.stopPropagation();
					self.startEvent = e;
					self.canTap = true;
					self.$target = $target;
					self.$content = $content;
					self.opts = current.opts.touch;
					self.isPanning = false;
					self.isSwiping = false;
					self.isZooming = false;
					self.isScrolling = false;
					self.startTime = new Date().getTime();
					self.distanceX = self.distanceY = self.distance = 0;
					self.canvasWidth = Math.round(current.$slide[0].clientWidth);
					self.canvasHeight = Math.round(current.$slide[0].clientHeight);
					self.contentLastPos = null;
					self.contentStartPos = $.fancybox.getTranslate(self.$content) || {
						top: 0,
						left: 0
					};
					self.sliderStartPos = self.sliderLastPos || $.fancybox.getTranslate(current.$slide);
					self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);
					self.sliderStartPos.top -= self.stagePos.top;
					self.sliderStartPos.left -= self.stagePos.left;
					self.contentStartPos.top -= self.stagePos.top;
					self.contentStartPos.left -= self.stagePos.left;
					$(document).off(".fb.touch").on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend")).on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));
					if ($.fancybox.isMobile) {
						document.addEventListener("scroll", self.onscroll, true);
					}
					if (!(self.opts || instance.canPan()) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
						if ($target.is(".fancybox-image")) {
							e.preventDefault();
						}
						return;
					}
					if (!($.fancybox.isMobile && (isScrollable($target) || isScrollable($target.parent())))) {
						e.preventDefault();
					}
					if (self.startPoints.length === 1 || current.hasError) {
						if (self.instance.canPan()) {
							$.fancybox.stop(self.$content);
							self.$content.css("transition-duration", "");
							self.isPanning = true;
						} else {
							self.isSwiping = true;
						}
						self.$container.addClass("fancybox-controls--isGrabbing");
					}
					if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {
						self.canTap = false;
						self.isSwiping = false;
						self.isPanning = false;
						self.isZooming = true;
						$.fancybox.stop(self.$content);
						self.$content.css("transition-duration", "");
						self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();
						self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();
						self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
						self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;
						self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
					}
				};
				Guestures.prototype.onscroll = function (e) {
					var self = this;
					self.isScrolling = true;
					document.removeEventListener("scroll", self.onscroll, true);
				};
				Guestures.prototype.ontouchmove = function (e) {
					var self = this,
						$target = $(e.target);
					if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {
						self.ontouchend(e);
						return;
					}
					if (self.isScrolling || !($target.is(self.$stage) || self.$stage.find($target).length)) {
						self.canTap = false;
						return;
					}
					self.newPoints = getPointerXY(e);
					if (!(self.opts || self.instance.canPan()) || !self.newPoints.length || !self.newPoints.length) {
						return;
					}
					if (!(self.isSwiping && self.isSwiping === true)) {
						e.preventDefault();
					}
					self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");
					self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");
					self.distance = distance(self.newPoints[0], self.startPoints[0]);
					if (self.distance > 0) {
						if (self.isSwiping) {
							self.onSwipe(e);
						} else if (self.isPanning) {
							self.onPan();
						} else if (self.isZooming) {
							self.onZoom();
						}
					}
				};
				Guestures.prototype.onSwipe = function (e) {
					var self = this,
						swiping = self.isSwiping,
						left = self.sliderStartPos.left || 0,
						angle;
					if (swiping === true) {
						if (Math.abs(self.distance) > 10) {
							self.canTap = false;
							if (self.instance.group.length < 2 && self.opts.vertical) {
								self.isSwiping = "y";
							} else if (self.instance.isDragging || self.opts.vertical === false || self.opts.vertical === "auto" && $(window).width() > 800) {
								self.isSwiping = "x";
							} else {
								angle = Math.abs(Math.atan2(self.distanceY, self.distanceX) * 180 / Math.PI);
								self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";
							}
							self.canTap = false;
							if (self.isSwiping === "y" && $.fancybox.isMobile && (isScrollable(self.$target) || isScrollable(self.$target.parent()))) {
								self.isScrolling = true;
								return;
							}
							self.instance.isDragging = self.isSwiping;
							self.startPoints = self.newPoints;
							$.each(self.instance.slides, function (index, slide) {
								$.fancybox.stop(slide.$slide);
								slide.$slide.css("transition-duration", "");
								slide.inTransition = false;
								if (slide.pos === self.instance.current.pos) {
									self.sliderStartPos.left = $.fancybox.getTranslate(slide.$slide).left - $.fancybox.getTranslate(self.instance.$refs.stage).left;
								}
							});
							if (self.instance.SlideShow && self.instance.SlideShow.isActive) {
								self.instance.SlideShow.stop();
							}
						}
						return;
					}
					if (swiping == "x") {
						if (self.distanceX > 0 && (self.instance.group.length < 2 || self.instance.current.index === 0 && !self.instance.current.opts.loop)) {
							left = left + Math.pow(self.distanceX, 0.8);
						} else if (self.distanceX < 0 && (self.instance.group.length < 2 || self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop)) {
							left = left - Math.pow(-self.distanceX, 0.8);
						} else {
							left = left + self.distanceX;
						}
					}
					self.sliderLastPos = {
						top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,
						left: left
					};
					if (self.requestId) {
						cancelAFrame(self.requestId);
						self.requestId = null;
					}
					self.requestId = requestAFrame(function () {
						if (self.sliderLastPos) {
							$.each(self.instance.slides, function (index, slide) {
								var pos = slide.pos - self.instance.currPos;
								$.fancybox.setTranslate(slide.$slide, {
									top: self.sliderLastPos.top,
									left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter
								});
							});
							self.$container.addClass("fancybox-is-sliding");
						}
					});
				};
				Guestures.prototype.onPan = function () {
					var self = this;
					if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {
						self.startPoints = self.newPoints;
						return;
					}
					self.canTap = false;
					self.contentLastPos = self.limitMovement();
					if (self.requestId) {
						cancelAFrame(self.requestId);
						self.requestId = null;
					}
					self.requestId = requestAFrame(function () {
						$.fancybox.setTranslate(self.$content, self.contentLastPos);
					});
				};
				Guestures.prototype.limitMovement = function () {
					var self = this;
					var canvasWidth = self.canvasWidth;
					var canvasHeight = self.canvasHeight;
					var distanceX = self.distanceX;
					var distanceY = self.distanceY;
					var contentStartPos = self.contentStartPos;
					var currentOffsetX = contentStartPos.left;
					var currentOffsetY = contentStartPos.top;
					var currentWidth = contentStartPos.width;
					var currentHeight = contentStartPos.height;
					var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;
					if (currentWidth > canvasWidth) {
						newOffsetX = currentOffsetX + distanceX;
					} else {
						newOffsetX = currentOffsetX;
					}
					newOffsetY = currentOffsetY + distanceY;
					minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
					minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);
					maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
					maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);
					if (distanceX > 0 && newOffsetX > minTranslateX) {
						newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
					}
					if (distanceX < 0 && newOffsetX < maxTranslateX) {
						newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
					}
					if (distanceY > 0 && newOffsetY > minTranslateY) {
						newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
					}
					if (distanceY < 0 && newOffsetY < maxTranslateY) {
						newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
					}
					return {
						top: newOffsetY,
						left: newOffsetX
					};
				};
				Guestures.prototype.limitPosition = function (newOffsetX, newOffsetY, newWidth, newHeight) {
					var self = this;
					var canvasWidth = self.canvasWidth;
					var canvasHeight = self.canvasHeight;
					if (newWidth > canvasWidth) {
						newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
						newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
					} else {
						newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);
					}
					if (newHeight > canvasHeight) {
						newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
						newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
					} else {
						newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);
					}
					return {
						top: newOffsetY,
						left: newOffsetX
					};
				};
				Guestures.prototype.onZoom = function () {
					var self = this;
					var contentStartPos = self.contentStartPos;
					var currentWidth = contentStartPos.width;
					var currentHeight = contentStartPos.height;
					var currentOffsetX = contentStartPos.left;
					var currentOffsetY = contentStartPos.top;
					var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);
					var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;
					var newWidth = Math.floor(currentWidth * pinchRatio);
					var newHeight = Math.floor(currentHeight * pinchRatio);
					var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
					var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;
					var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();
					var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop();
					var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
					var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;
					var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
					var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);
					var newPos = {
						top: newOffsetY,
						left: newOffsetX,
						scaleX: pinchRatio,
						scaleY: pinchRatio
					};
					self.canTap = false;
					self.newWidth = newWidth;
					self.newHeight = newHeight;
					self.contentLastPos = newPos;
					if (self.requestId) {
						cancelAFrame(self.requestId);
						self.requestId = null;
					}
					self.requestId = requestAFrame(function () {
						$.fancybox.setTranslate(self.$content, self.contentLastPos);
					});
				};
				Guestures.prototype.ontouchend = function (e) {
					var self = this;
					var dMs = Math.max(new Date().getTime() - self.startTime, 1);
					var swiping = self.isSwiping;
					var panning = self.isPanning;
					var zooming = self.isZooming;
					var scrolling = self.isScrolling;
					self.endPoints = getPointerXY(e);
					self.$container.removeClass("fancybox-controls--isGrabbing");
					$(document).off(".fb.touch");
					document.removeEventListener("scroll", self.onscroll, true);
					if (self.requestId) {
						cancelAFrame(self.requestId);
						self.requestId = null;
					}
					self.isSwiping = false;
					self.isPanning = false;
					self.isZooming = false;
					self.isScrolling = false;
					self.instance.isDragging = false;
					if (self.canTap) {
						return self.onTap(e);
					}
					self.speed = 366;
					self.velocityX = self.distanceX / dMs * 0.5;
					self.velocityY = self.distanceY / dMs * 0.5;
					self.speedX = Math.max(self.speed * 0.5, Math.min(self.speed * 1.5, 1 / Math.abs(self.velocityX) * self.speed));
					if (panning) {
						self.endPanning();
					} else if (zooming) {
						self.endZooming();
					} else {
						self.endSwiping(swiping, scrolling);
					}
					return;
				};
				Guestures.prototype.endSwiping = function (swiping, scrolling) {
					var self = this,
						ret = false,
						len = self.instance.group.length;
					self.sliderLastPos = null;
					if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {
						$.fancybox.animate(self.instance.current.$slide, {
							top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,
							opacity: 0
						}, 200);
						ret = self.instance.close(true, 200);
					} else if (swiping == "x" && self.distanceX > 50 && len > 1) {
						ret = self.instance.previous(self.speedX);
					} else if (swiping == "x" && self.distanceX < -50 && len > 1) {
						ret = self.instance.next(self.speedX);
					}
					if (ret === false && (swiping == "x" || swiping == "y")) {
						if (scrolling || len < 2) {
							self.instance.centerSlide(self.instance.current, 150);
						} else {
							self.instance.jumpTo(self.instance.current.index);
						}
					}
					self.$container.removeClass("fancybox-is-sliding");
				};
				Guestures.prototype.endPanning = function () {
					var self = this;
					var newOffsetX, newOffsetY, newPos;
					if (!self.contentLastPos) {
						return;
					}
					if (self.opts.momentum === false) {
						newOffsetX = self.contentLastPos.left;
						newOffsetY = self.contentLastPos.top;
					} else {
						newOffsetX = self.contentLastPos.left + self.velocityX * self.speed;
						newOffsetY = self.contentLastPos.top + self.velocityY * self.speed;
					}
					newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);
					newPos.width = self.contentStartPos.width;
					newPos.height = self.contentStartPos.height;
					$.fancybox.animate(self.$content, newPos, 330);
				};
				Guestures.prototype.endZooming = function () {
					var self = this;
					var current = self.instance.current;
					var newOffsetX, newOffsetY, newPos, reset;
					var newWidth = self.newWidth;
					var newHeight = self.newHeight;
					if (!self.contentLastPos) {
						return;
					}
					newOffsetX = self.contentLastPos.left;
					newOffsetY = self.contentLastPos.top;
					reset = {
						top: newOffsetY,
						left: newOffsetX,
						width: newWidth,
						height: newHeight,
						scaleX: 1,
						scaleY: 1
					};
					$.fancybox.setTranslate(self.$content, reset);
					if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
						self.instance.scaleToFit(150);
					} else if (newWidth > current.width || newHeight > current.height) {
						self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
					} else {
						newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);
						$.fancybox.setTranslate(self.$content, $.fancybox.getTranslate(self.$content));
						$.fancybox.animate(self.$content, newPos, 150);
					}
				};
				Guestures.prototype.onTap = function (e) {
					var self = this;
					var $target = $(e.target);
					var instance = self.instance;
					var current = instance.current;
					var endPoints = e && getPointerXY(e) || self.startPoints;
					var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;
					var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;
					var where;
					var process = function process(prefix) {
						var action = current.opts[prefix];
						if ($.isFunction(action)) {
							action = action.apply(instance, [current, e]);
						}
						if (!action) {
							return;
						}
						switch (action) {
							case "close":
								instance.close(self.startEvent);
								break;
							case "toggleControls":
								instance.toggleControls(true);
								break;
							case "next":
								instance.next();
								break;
							case "nextOrClose":
								if (instance.group.length > 1) {
									instance.next();
								} else {
									instance.close(self.startEvent);
								}
								break;
							case "zoom":
								if (current.type == "image" && (current.isLoaded || current.$ghost)) {
									if (instance.canPan()) {
										instance.scaleToFit();
									} else if (instance.isScaledDown()) {
										instance.scaleToActual(tapX, tapY);
									} else if (instance.group.length < 2) {
										instance.close(self.startEvent);
									}
								}
								break;
						}
					};
					if (e.originalEvent && e.originalEvent.button == 2) {
						return;
					}
					if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {
						return;
					}
					if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {
						where = "Outside";
					} else if ($target.is(".fancybox-slide")) {
						where = "Slide";
					} else if (instance.current.$content && instance.current.$content.find($target).addBack().filter($target).length) {
						where = "Content";
					} else {
						return;
					}
					if (self.tapped) {
						clearTimeout(self.tapped);
						self.tapped = null;
						if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
							return this;
						}
						process("dblclick" + where);
					} else {
						self.tapX = tapX;
						self.tapY = tapY;
						if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {
							self.tapped = setTimeout(function () {
								self.tapped = null;
								process("click" + where);
							}, 500);
						} else {
							process("click" + where);
						}
					}
					return this;
				};
				$(document).on("onActivate.fb", function (e, instance) {
					if (instance && !instance.Guestures) {
						instance.Guestures = new Guestures(instance);
					}
				});
			})(window, document, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, $) {
				"use strict";
				$.extend(true, $.fancybox.defaults, {
					btnTpl: {
						slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' + '<svg viewBox="0 0 40 40">' + '<path d="M13,12 L27,20 L13,27 Z" />' + '<path d="M15,10 v19 M23,10 v19" />' + "</svg>" + "</button>"
					},
					slideShow: {
						autoStart: false,
						speed: 3000
					}
				});
				var SlideShow = function SlideShow(instance) {
					this.instance = instance;
					this.init();
				};
				$.extend(SlideShow.prototype, {
					timer: null,
					isActive: false,
					$button: null,
					init: function init() {
						var self = this;
						self.$button = self.instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function () {
							self.toggle();
						});
						if (self.instance.group.length < 2 || !self.instance.group[self.instance.currIndex].opts.slideShow) {
							self.$button.hide();
						}
					},
					set: function set(force) {
						var self = this;
						if (self.instance && self.instance.current && (force === true || self.instance.current.opts.loop || self.instance.currIndex < self.instance.group.length - 1)) {
							self.timer = setTimeout(function () {
								if (self.isActive) {
									self.instance.jumpTo((self.instance.currIndex + 1) % self.instance.group.length);
								}
							}, self.instance.current.opts.slideShow.speed);
						} else {
							self.stop();
							self.instance.idleSecondsCounter = 0;
							self.instance.showControls();
						}
					},
					clear: function clear() {
						var self = this;
						clearTimeout(self.timer);
						self.timer = null;
					},
					start: function start() {
						var self = this;
						var current = self.instance.current;
						if (current) {
							self.isActive = true;
							self.$button.attr("title", current.opts.i18n[current.opts.lang].PLAY_STOP).removeClass("fancybox-button--play").addClass("fancybox-button--pause");
							self.set(true);
						}
					},
					stop: function stop() {
						var self = this;
						var current = self.instance.current;
						self.clear();
						self.$button.attr("title", current.opts.i18n[current.opts.lang].PLAY_START).removeClass("fancybox-button--pause").addClass("fancybox-button--play");
						self.isActive = false;
					},
					toggle: function toggle() {
						var self = this;
						if (self.isActive) {
							self.stop();
						} else {
							self.start();
						}
					}
				});
				$(document).on({
					"onInit.fb": function onInitFb(e, instance) {
						if (instance && !instance.SlideShow) {
							instance.SlideShow = new SlideShow(instance);
						}
					},
					"beforeShow.fb": function beforeShowFb(e, instance, current, firstRun) {
						var SlideShow = instance && instance.SlideShow;
						if (firstRun) {
							if (SlideShow && current.opts.slideShow.autoStart) {
								SlideShow.start();
							}
						} else if (SlideShow && SlideShow.isActive) {
							SlideShow.clear();
						}
					},
					"afterShow.fb": function afterShowFb(e, instance, current) {
						var SlideShow = instance && instance.SlideShow;
						if (SlideShow && SlideShow.isActive) {
							SlideShow.set();
						}
					},
					"afterKeydown.fb": function afterKeydownFb(e, instance, current, keypress, keycode) {
						var SlideShow = instance && instance.SlideShow;
						if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {
							keypress.preventDefault();
							SlideShow.toggle();
						}
					},
					"beforeClose.fb onDeactivate.fb": function beforeCloseFbOnDeactivateFb(e, instance) {
						var SlideShow = instance && instance.SlideShow;
						if (SlideShow) {
							SlideShow.stop();
						}
					}
				});
				$(document).on("visibilitychange", function () {
					var instance = $.fancybox.getInstance();
					var SlideShow = instance && instance.SlideShow;
					if (SlideShow && SlideShow.isActive) {
						if (document.hidden) {
							SlideShow.clear();
						} else {
							SlideShow.set();
						}
					}
				});
			})(document, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, $) {
				"use strict";
				var fn = function () {
					var fnMap = [
						["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
						["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
						["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
						["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
						["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
					];
					var ret = {};
					for (var i = 0; i < fnMap.length; i++) {
						var val = fnMap[i];
						if (val && val[1] in document) {
							for (var j = 0; j < val.length; j++) {
								ret[fnMap[0][j]] = val[j];
							}
							return ret;
						}
					}
					return false;
				}();
				if (!fn) {
					if ($ && $.fancybox) {
						$.fancybox.defaults.btnTpl.fullScreen = false;
					}
					return;
				}
				var FullScreen = {
					request: function request(elem) {
						elem = elem || document.documentElement;
						elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
					},
					exit: function exit() {
						document[fn.exitFullscreen]();
					},
					toggle: function toggle(elem) {
						elem = elem || document.documentElement;
						if (this.isFullscreen()) {
							this.exit();
						} else {
							this.request(elem);
						}
					},
					isFullscreen: function isFullscreen() {
						return Boolean(document[fn.fullscreenElement]);
					},
					enabled: function enabled() {
						return Boolean(document[fn.fullscreenEnabled]);
					}
				};
				$.extend(true, $.fancybox.defaults, {
					btnTpl: {
						fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fullscreen" title="{{FULL_SCREEN}}">' + '<svg viewBox="0 0 40 40">' + '<path d="M9,12 v16 h22 v-16 h-22 v8" />' + "</svg>" + "</button>"
					},
					fullScreen: {
						autoStart: false
					}
				});
				$(document).on({
					"onInit.fb": function onInitFb(e, instance) {
						var $container;
						if (instance && instance.group[instance.currIndex].opts.fullScreen) {
							$container = instance.$refs.container;
							$container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function (e) {
								e.stopPropagation();
								e.preventDefault();
								FullScreen.toggle();
							});
							if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
								FullScreen.request();
							}
							instance.FullScreen = FullScreen;
						} else if (instance) {
							instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();
						}
					},
					"afterKeydown.fb": function afterKeydownFb(e, instance, current, keypress, keycode) {
						if (instance && instance.FullScreen && keycode === 70) {
							keypress.preventDefault();
							instance.FullScreen.toggle();
						}
					},
					"beforeClose.fb": function beforeCloseFb(e, instance) {
						if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {
							FullScreen.exit();
						}
					}
				});
				$(document).on(fn.fullscreenchange, function () {
					var isFullscreen = FullScreen.isFullscreen(),
						instance = $.fancybox.getInstance();
					if (instance) {
						if (instance.current && instance.current.type === "image" && instance.isAnimating) {
							instance.current.$content.css("transition", "none");
							instance.isAnimating = false;
							instance.update(true, true, 0);
						}
						instance.trigger("onFullscreenChange", isFullscreen);
						instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);
					}
				});
			})(document, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, $) {
				"use strict";
				var CLASS = "fancybox-thumbs",
					CLASS_ACTIVE = CLASS + "-active",
					CLASS_LOAD = CLASS + "-loading";
				$.fancybox.defaults = $.extend(true, {
					btnTpl: {
						thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' + '<svg viewBox="0 0 120 120">' + '<path d="M30,30 h14 v14 h-14 Z M50,30 h14 v14 h-14 Z M70,30 h14 v14 h-14 Z M30,50 h14 v14 h-14 Z M50,50 h14 v14 h-14 Z M70,50 h14 v14 h-14 Z M30,70 h14 v14 h-14 Z M50,70 h14 v14 h-14 Z M70,70 h14 v14 h-14 Z" />' + "</svg>" + "</button>"
					},
					thumbs: {
						autoStart: false,
						hideOnClose: true,
						parentEl: ".fancybox-container",
						axis: "y"
					}
				}, $.fancybox.defaults);
				var FancyThumbs = function FancyThumbs(instance) {
					this.init(instance);
				};
				$.extend(FancyThumbs.prototype, {
					$button: null,
					$grid: null,
					$list: null,
					isVisible: false,
					isActive: false,
					init: function init(instance) {
						var self = this,
							first, second;
						self.instance = instance;
						instance.Thumbs = self;
						self.opts = instance.group[instance.currIndex].opts.thumbs;
						first = instance.group[0];
						first = first.opts.thumb || (first.opts.$thumb && first.opts.$thumb.length ? first.opts.$thumb.attr("src") : false);
						if (instance.group.length > 1) {
							second = instance.group[1];
							second = second.opts.thumb || (second.opts.$thumb && second.opts.$thumb.length ? second.opts.$thumb.attr("src") : false);
						}
						self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]");
						if (self.opts && first && second && first && second) {
							self.$button.show().on("click", function () {
								self.toggle();
							});
							self.isActive = true;
						} else {
							self.$button.hide();
						}
					},
					create: function create() {
						var self = this,
							instance = self.instance,
							parentEl = self.opts.parentEl,
							list = [],
							src;
						if (!self.$grid) {
							self.$grid = $('<div class="' + CLASS + " " + CLASS + "-" + self.opts.axis + '"></div>').appendTo(instance.$refs.container.find(parentEl).addBack().filter(parentEl));
							self.$grid.on("click", "li", function () {
								instance.jumpTo($(this).attr("data-index"));
							});
						}
						if (!self.$list) {
							self.$list = $("<ul>").appendTo(self.$grid);
						}
						$.each(instance.group, function (i, item) {
							src = item.opts.thumb || (item.opts.$thumb ? item.opts.$thumb.attr("src") : null);
							if (!src && item.type === "image") {
								src = item.src;
							}
							list.push('<li data-index="' + i + '" tabindex="0" class="' + CLASS_LOAD + '"' + (src && src.length ? ' style="background-image:url(' + src + ')" />' : "") + "></li>");
						});
						self.$list[0].innerHTML = list.join("");
						if (self.opts.axis === "x") {
							self.$list.width(parseInt(self.$grid.css("padding-right"), 10) + instance.group.length * self.$list.children().eq(0).outerWidth(true));
						}
					},
					focus: function focus(duration) {
						var self = this,
							$list = self.$list,
							$grid = self.$grid,
							thumb, thumbPos;
						if (!self.instance.current) {
							return;
						}
						thumb = $list.children().removeClass(CLASS_ACTIVE).filter('[data-index="' + self.instance.current.index + '"]').addClass(CLASS_ACTIVE);
						thumbPos = thumb.position();
						if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {
							$list.stop().animate({
								scrollTop: $list.scrollTop() + thumbPos.top
							}, duration);
						} else if (self.opts.axis === "x" && (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))) {
							$list.parent().stop().animate({
								scrollLeft: thumbPos.left
							}, duration);
						}
					},
					update: function update() {
						var that = this;
						that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);
						if (that.isVisible) {
							if (!that.$grid) {
								that.create();
							}
							that.instance.trigger("onThumbsShow");
							that.focus(0);
						} else if (that.$grid) {
							that.instance.trigger("onThumbsHide");
						}
						that.instance.update();
					},
					hide: function hide() {
						this.isVisible = false;
						this.update();
					},
					show: function show() {
						this.isVisible = true;
						this.update();
					},
					toggle: function toggle() {
						this.isVisible = !this.isVisible;
						this.update();
					}
				});
				$(document).on({
					"onInit.fb": function onInitFb(e, instance) {
						var Thumbs;
						if (instance && !instance.Thumbs) {
							Thumbs = new FancyThumbs(instance);
							if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
								Thumbs.show();
							}
						}
					},
					"beforeShow.fb": function beforeShowFb(e, instance, item, firstRun) {
						var Thumbs = instance && instance.Thumbs;
						if (Thumbs && Thumbs.isVisible) {
							Thumbs.focus(firstRun ? 0 : 250);
						}
					},
					"afterKeydown.fb": function afterKeydownFb(e, instance, current, keypress, keycode) {
						var Thumbs = instance && instance.Thumbs;
						if (Thumbs && Thumbs.isActive && keycode === 71) {
							keypress.preventDefault();
							Thumbs.toggle();
						}
					},
					"beforeClose.fb": function beforeCloseFb(e, instance) {
						var Thumbs = instance && instance.Thumbs;
						if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
							Thumbs.$grid.hide();
						}
					}
				});
			})(document, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, $) {
				"use strict";
				$.extend(true, $.fancybox.defaults, {
					btnTpl: {
						share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' + '<svg viewBox="0 0 40 40">' + '<path d="M6,30 C8,18 19,16 23,16 L23,16 L23,10 L33,20 L23,29 L23,24 C19,24 8,27 6,30 Z">' + "</svg>" + "</button>"
					},
					share: {
						url: function url(instance, item) {
							return (!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location;
						},
						tpl: '<div class="fancybox-share">' + "<h1>{{SHARE}}</h1>" + "<p>" + '<a class="fancybox-share__button fancybox-share__button--fb" >' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>' + "<span>Facebook</span>" + "</a>" + '<a class="fancybox-share__button fancybox-share__button--tw" >' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>' + "<span>Twitter</span>" + "</a>" + '<a class="fancybox-share__button fancybox-share__button--pt" >' + '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' + "<span>Pinterest</span>" + "</a>" + "</p>" + '<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" /></p>' + "</div>"
					}
				});

				function escapeHtml(string) {
					var entityMap = {
						"&": "&amp;",
						"<": "&lt;",
						">": "&gt;",
						'"': "&quot;",
						"'": "&#39;",
						"/": "&#x2F;",
						"`": "&#x60;",
						"=": "&#x3D;"
					};
					return String(string).replace(/[&<>"'`=\/]/g, function (s) {
						return entityMap[s];
					});
				}
				$(document).on("click", "[data-fancybox-share]", function () {
					var instance = $.fancybox.getInstance(),
						current = instance.current || null,
						url, tpl;
					if (!current) {
						return;
					}
					if ($.type(current.opts.share.url) === "function") {
						url = current.opts.share.url.apply(current, [instance, current]);
					}
					tpl = current.opts.share.tpl.replace(/\{\{media\}\}/g, current.type === "image" ? encodeURIComponent(current.src) : "").replace(/\{\{url\}\}/g, encodeURIComponent(url)).replace(/\{\{url_raw\}\}/g, escapeHtml(url)).replace(/\{\{descr\}\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");
					$.fancybox.open({
						src: instance.translate(instance, tpl),
						type: "html",
						opts: {
							animationEffect: false,
							afterLoad: function afterLoad(shareInstance, shareCurrent) {
								instance.$refs.container.one("beforeClose.fb", function () {
									shareInstance.close(null, 0);
								});
								shareCurrent.$content.find(".fancybox-share__links a").click(function () {
									window.open(this.href, "Share", "width=550, height=450");
									return false;
								});
							}
						}
					});
				});
			})(document, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, window, $) {
				"use strict";
				if (!$.escapeSelector) {
					$.escapeSelector = function (sel) {
						var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
						var fcssescape = function fcssescape(ch, asCodePoint) {
							if (asCodePoint) {
								if (ch === "\0") {
									return "\uFFFD";
								}
								return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
							}
							return "\\" + ch;
						};
						return (sel + "").replace(rcssescape, fcssescape);
					};
				}

				function parseUrl() {
					var hash = window.location.hash.substr(1),
						rez = hash.split("-"),
						index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,
						gallery = rez.join("-");
					return {
						hash: hash,
						index: index < 1 ? 1 : index,
						gallery: gallery
					};
				}

				function triggerFromUrl(url) {
					var $el;
					if (url.gallery !== "") {
						$el = $("[data-fancybox='" + $.escapeSelector(url.gallery) + "']").eq(url.index - 1).trigger("click.fb-start");
					}
				}

				function getGalleryID(instance) {
					var opts, ret;
					if (!instance) {
						return false;
					}
					opts = instance.current ? instance.current.opts : instance.opts;
					ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") : "");
					return ret === "" ? false : ret;
				}
				$(function () {
					if ($.fancybox.defaults.hash === false) {
						return;
					}
					$(document).on({
						"onInit.fb": function onInitFb(e, instance) {
							var url, gallery;
							if (instance.group[instance.currIndex].opts.hash === false) {
								return;
							}
							url = parseUrl();
							gallery = getGalleryID(instance);
							if (gallery && url.gallery && gallery == url.gallery) {
								instance.currIndex = url.index - 1;
							}
						},
						"beforeShow.fb": function beforeShowFb(e, instance, current, firstRun) {
							var gallery;
							if (!current || current.opts.hash === false) {
								return;
							}
							gallery = getGalleryID(instance);
							if (!gallery) {
								return;
							}
							instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : "");
							if (window.location.hash === "#" + instance.currentHash) {
								return;
							}
							if (!instance.origHash) {
								instance.origHash = window.location.hash;
							}
							if (instance.hashTimer) {
								clearTimeout(instance.hashTimer);
							}
							instance.hashTimer = setTimeout(function () {
								if ("replaceState" in window.history) {
									window.history[firstRun ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + "#" + instance.currentHash);
									if (firstRun) {
										instance.hasCreatedHistory = true;
									}
								} else {
									window.location.hash = instance.currentHash;
								}
								instance.hashTimer = null;
							}, 300);
						},
						"beforeClose.fb": function beforeCloseFb(e, instance, current) {
							var gallery;
							if (current.opts.hash === false) {
								return;
							}
							gallery = getGalleryID(instance);
							if (instance.currentHash && instance.hasCreatedHistory) {
								window.history.back();
							} else if (instance.currentHash) {
								if ("replaceState" in window.history) {
									window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));
								} else {
									window.location.hash = instance.origHash;
								}
							}
							instance.currentHash = null;
							clearTimeout(instance.hashTimer);
						}
					});
					$(window).on("hashchange.fb", function () {
						var url = parseUrl(),
							fb;
						$.each($(".fancybox-container").get().reverse(), function (index, value) {
							var tmp = $(value).data("FancyBox");
							if (tmp.currentHash) {
								fb = tmp;
								return false;
							}
						});
						if (fb) {
							if (fb.currentHash && fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {
								fb.currentHash = null;
								fb.close();
							}
						} else if (url.gallery !== "") {
							triggerFromUrl(url);
						}
					});
					setTimeout(function () {
						if (!$.fancybox.getInstance()) {
							triggerFromUrl(parseUrl());
						}
					}, 50);
				});
			})(document, window, __webpack_provided_window_dot_jQuery || jQuery);
			(function (document, $) {
				"use strict";
				var prevTime = new Date().getTime();
				$(document).on({
					"onInit.fb": function onInitFb(e, instance, current) {
						instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function (e) {
							var current = instance.current,
								currTime = new Date().getTime();
							if (instance.group.length < 2 || current.opts.wheel === false || current.opts.wheel === "auto" && current.type !== "image") {
								return;
							}
							e.preventDefault();
							e.stopPropagation();
							if (current.$slide.hasClass("fancybox-animated")) {
								return;
							}
							e = e.originalEvent || e;
							if (currTime - prevTime < 250) {
								return;
							}
							prevTime = currTime;
							instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();
						});
					}
				});
			})(document, __webpack_provided_window_dot_jQuery || jQuery);
		}.call(exports, __webpack_require__(0), __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				$('.course-slider').slick({
					speed: 900
				});
				$('.course-carousel__arrow.next').on('click', function () {
					$('.course-slider').slick('slickNext');
				});
				$('.course-carousel__arrow.prev').on('click', function () {
					$('.course-slider').slick('slickPrev');
				});
				var len = $('.instructor-slider').find('.instructor-slider__box').length;
				$('.instructor-slider-section .slide-score').each(function () {
					$(this).html('0' + len);
				});
				$('.instructor-slider').slick({
					infinite: true,
					slidesToShow: 1,
					slidesToScroll: 1,
					speed: 1300,
					accessibility: false,
					fade: true,
					prevArrow: '<div class="slick-prev"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>',
					nextArrow: '<div class="slick-next"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>'
				});
				$('.instructor-slider').on('afterChange', function (slick, currentSlide) {
					$('.instructor-slider-section .slide-number').each(function () {
						$(this).html('0' + (currentSlide.currentSlide + 1));
					});
				});
				if ($(window).width() < 768) {
					$('.vacancies-list').slick({
						slidesToShow: 1,
						variableWidth: true,
						dots: false,
						centerMode: true,
						arrows: true,
						prevArrow: '<div class="slick-prev"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>',
						nextArrow: '<div class="slick-next"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>'
					});
				}
				$('.course-reviews-slider').slick({
					slidesToShow: 2,
					slidesToScroll: 1,
					prevArrow: '<div class="slick-prev"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>',
					nextArrow: '<div class="slick-next"><svg><use xlink:href="/images/sprite.svg#slide-arrow"/></svg></div>',
					appendArrows: $(".course-reviews-nav"),
					responsive: [{
						breakpoint: 760,
						settings: {
							slidesToShow: 1,
							slidesToScroll: 1,
							variableWidth: true
						}
					}]
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				$('.course-slider__timer').each(function () {
					console.log(44);
					var date = $(this).data('date');
					$(this).countdown(date, function (event) {
						$(this).html(event.strftime('\n	  <div class="timer-item">\n		%D\n		<span>\u0434</span>\n	  </div>\n	  <div class="timer-item">\n		%H\n		<span>\u0447</span>\n	  </div>\n	  <div class="timer-item">\n		%M\n		<span>\u043C</span>\n	  </div>\n	  <div class="timer-item">\n		%S\n		<span>\u0441</span>\n	  </div>\n	   '));
					});
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				var loadmap = false;

				function is_touch_device() {
					return 'ontouchstart' in window;
				}
				var initmap = function initmap() {
					"use strict";
					var o, e, n = [
						["", 49.993845, 36.232049],
						["", 50.026291, 36.217346]
					],
						a = is_touch_device() ? new google.maps.LatLng(49.993845, 36.232049) : new google.maps.LatLng(49.993845, 36.232049),
						t = 17,
						s = {
							animate: !0,
							duration: 5e3
						},
						g = new google.maps.Map(document.getElementById("map"), {
							zoom: t,
							center: a,
							scrollwheel: 0,
							navigationControl: !1,
							mapTypeControl: !1,
							scaleControl: !1,
							draggable: !0,
							mapTypeId: google.maps.MapTypeId.ROADMAP,
							styles: [{
								stylers: [{
									saturation: -80
								}]
							}]
						}),
						p = "",
						m = new google.maps.InfoWindow(),
						i = [];
					for (e = 0; e < n.length; e++) {
						o = new google.maps.Marker({
							position: new google.maps.LatLng(n[e][1], n[e][2]),
							map: g,
							icon: p
						}), google.maps.event.addListener(o, "event", function (o, e) {
							return function () {
								m.setContent(n[e][0]), m.open(g, o);
							};
						}(o, e)), i.push(o);
					}
					var l = new google.maps.LatLng(49.993845, 36.232049),
						r = new google.maps.LatLng(50.026291, 36.217346);
					$(".map-1").click(function () {
						$('.footer__row').removeClass('active');
						$('html, body').animate({
							scrollTop: $(".footer__map").offset().top
						}, 1000);
						$(this).toggleClass('active');
						if ($(this).hasClass('active')) {
							$(this).children('.footer__col').children('.footer__notes').children('span').html($(this).data('active'));
							$(this).siblings().children('.footer__col').children('.footer__notes').children('span').html($(this).data('inactive'));
						}
						g.panTo(l, s);
					}), $(".map-2").click(function () {
						$('html, body').animate({
							scrollTop: $(".footer__map").offset().top
						}, 1000);
						$('.footer__row').removeClass('active');
						$(this).toggleClass('active');
						if ($(this).hasClass('active')) {
							$(this).children('.footer__col').children('.footer__notes').children('span').html($(this).data('active'));
							$(this).siblings().children('.footer__col').children('.footer__notes').children('span').html($(this).data('inactive'));
						}
						g.panTo(r, s);
					});
					loadmap = true;
				};
				$(window).on('scroll', function () {
					if ($(this).scrollTop() >= $(".footer").position().top - $(".footer").outerHeight() && !loadmap) {
						initmap();
					}
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				$('img.svg').each(function () {
					var $img = $(this);
					var imgID = $img.attr('id');
					var imgClass = $img.attr('class');
					var imgURL = $img.attr('src');
					$.get(imgURL, function (data) {
						var $svg = $(data).find('svg');
						if (typeof imgID !== 'undefined') {
							$svg = $svg.attr('id', imgID);
						}
						if (typeof imgClass !== 'undefined') {
							$svg = $svg.attr('class', imgClass + ' replaced-svg');
						}
						$svg = $svg.removeAttr('xmlns:a');
						if (!$svg.attr('viewBox') && $svg.attr('height') && $svg.attr('width')) {
							$svg.attr('viewBox', '0 0 ' + $svg.attr('height') + ' ' + $svg.attr('width'));
						}
						$img.replaceWith($svg);
					}, 'xml');
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var parser = document.createElement('a');

		function sortItems(items, element) {
			var xlink = element.getAttribute('xlink:href');
			if (xlink[0] === '#') {
				return items;
			}
			parser.href = xlink;
			var hash = parser.hash;
			var filePath = parser.href.split(hash)[0];
			if (!items[filePath]) {
				items[filePath] = {
					nodes: [],
					fragments: []
				};
			}
			var item = items[filePath];
			item.nodes.push({
				element: element,
				fragment: hash
			});
			if (item.fragments.indexOf(hash) === -1) {
				item.fragments.push(hash);
			}
			return items;
		}

		function getSymbols(doc, ids) {
			return Array.prototype.slice.call(doc.querySelectorAll(ids.join(','))).reduce(function (items, item) {
				var key = ['#', item.id].join('');
				items[key] = item;
				return items;
			}, {});
		}

		function embed(item, content) {
			var parent = item.parentNode;
			if (!parent || !content) {
				return;
			}
			if (!parent.getAttribute('viewBox')) {
				parent.setAttribute('viewBox', content.getAttribute('viewBox'));
			}
			var fragment = document.createDocumentFragment();
			var copy = content.cloneNode(true);
			while (copy.childNodes.length) {
				fragment.appendChild(copy.firstChild);
			}
			parent.replaceChild(fragment, item);
		}

		function fileLoaded(xhr, resourceFiles) {
			var response = xhr.response;
			if (xhr.readyState === 4 && response && Boolean(response.documentElement)) {
				var symbols = getSymbols(response.documentElement, resourceFiles.fragments);
				resourceFiles.nodes.forEach(function (item) {
					embed(item.element, symbols[item.fragment]);
				});
			}
		}

		function fetchFile(filePath, callback) {
			var xhr = new XMLHttpRequest();
			xhr.addEventListener('load', callback);
			xhr.addEventListener('error', console.error);
			xhr.open('GET', filePath);
			xhr.responseType = 'document';
			xhr.send();
		}

		function init(rootSelector, blacklist, query) {
			var negotiations = blacklist.map(function (item) {
				return [':not(', item, ')'].join('');
			}).join('');
			var selector = negotiations ? [rootSelector, '>', negotiations, query].join(' ') : [rootSelector, query].join(' ');
			var root = document.querySelector(rootSelector);
			var matches = root.querySelectorAll(selector);
			var resourceFiles = Array.prototype.slice.call(matches).reduce(sortItems, {});
			Object.keys(resourceFiles).forEach(function (key) {
				var items = resourceFiles[key];
				fetchFile(key, function () {
					fileLoaded(this, items);
				});
			});
		}

		function notSupportsExternalFragments() {
			return Boolean(document.documentMode);
		}

		function svgUseIt(rootSelector, blacklist) {
			var query = 'use';
			if (notSupportsExternalFragments()) {
				rootSelector = rootSelector || 'body';
				blacklist = blacklist || [];
				init(rootSelector, blacklist, query);
			}
		}
		module.exports = svgUseIt;
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				$('.menu-handler, .navigation__close').on('click', function () {
					$('.navigation').toggleClass('active');
					$('body').css('overflow', 'hidden');
				});
				$('.navigation__close').on('click', function () {
					setTimeout(function () {
						$('body').css('overflow', 'auto');
					}, 400);
				});
				$('.instructor__opener').each(function () {
					$(this).click(function () {
						$(this).toggleClass('active');
						$(this).parent().siblings('.instructor__image').toggleClass('active');
						$(this).hasClass('active') ? $(this).children('span').html($(this).data('close')) : $(this).children('span').html($(this).data('open'));
					});
				});
				$('.form-section__row input').change(function () {
					if ($(this).prop('value') !== '') {
						$(this).addClass('active');
					} else {
						$(this).removeClass('active');
					}
				});
				$('.scroll-bottom').on('click', function (e) {
					e.preventDefault();
					var idBlock = $(this).attr('href');
					var idTop = $(idBlock).offset().top;
					$('html, body').stop().animate({
						scrollTop: idTop
					}, 1000);
				});
				if ($(window).width() >= 1250) {
					$('body.home .navigation__list .parent > a').on('click', function (e) {
						e.preventDefault();
						$('.navigation').removeClass('active');
						setTimeout(function () {
							$('body').css('overflow', 'auto');
						}, 400);
						var idBlock = $(this).attr('href');
						var idTop = $(idBlock).offset().top;
						$('html, body').stop().animate({
							scrollTop: idTop
						}, 1000);
					});
				}
				if ($('.form-section__form-box').hasClass('success')) {
					$('.form-section__row input').each(function () {
						$(this).val() == '';
					});
				}
				$('.form-section__area-opener').on('click', function () {
					$(this).toggleClass('active');
					$('.form-section__area').toggleClass('active');
					$('.form-section__area textarea').focus();
				});
				if ($(window).width() <= 1250) {
					$('.navigation__list .parent > a').on('click', function (e) {
						e.preventDefault();
						$('.navigation__list .parent ul').toggle();
					});
				}
				if ($(window).width() <= 479) {
					$('.programm__sub-title').on('click', function (e) {
						$('.programm__sub-title').removeClass('active');
						$(this).addClass('active');
						$('.programm__list').css('display', 'none');
						$(this).siblings().css('display', 'block');
					});
				}
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		(function (factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				factory(require('jquery'));
			} else {
				factory(jQuery);
			}
		})(function ($) {
			var ua = navigator.userAgent,
				iPhone = /iphone/i.test(ua),
				chrome = /chrome/i.test(ua),
				android = /android/i.test(ua),
				caretTimeoutId;
			$.mask = {
				definitions: {
					'9': "[0-9]",
					'a': "[A-Za-z]",
					'*': "[A-Za-z0-9]"
				},
				autoclear: true,
				dataName: "rawMaskFn",
				placeholder: '_'
			};
			$.fn.extend({
				caret: function caret(begin, end) {
					var range;
					if (this.length === 0 || this.is(":hidden") || this.get(0) !== document.activeElement) {
						return;
					}
					if (typeof begin == 'number') {
						end = typeof end === 'number' ? end : begin;
						return this.each(function () {
							if (this.setSelectionRange) {
								this.setSelectionRange(begin, end);
							} else if (this.createTextRange) {
								range = this.createTextRange();
								range.collapse(true);
								range.moveEnd('character', end);
								range.moveStart('character', begin);
								range.select();
							}
						});
					} else {
						if (this[0].setSelectionRange) {
							begin = this[0].selectionStart;
							end = this[0].selectionEnd;
						} else if (document.selection && document.selection.createRange) {
							range = document.selection.createRange();
							begin = 0 - range.duplicate().moveStart('character', -100000);
							end = begin + range.text.length;
						}
						return {
							begin: begin,
							end: end
						};
					}
				},
				unmask: function unmask() {
					return this.trigger("unmask");
				},
				mask: function mask(_mask, settings) {
					var input, defs, tests, partialPosition, firstNonMaskPos, lastRequiredNonMaskPos, len, oldVal;
					if (!_mask && this.length > 0) {
						input = $(this[0]);
						var fn = input.data($.mask.dataName);
						return fn ? fn() : undefined;
					}
					settings = $.extend({
						autoclear: $.mask.autoclear,
						placeholder: $.mask.placeholder,
						completed: null
					}, settings);
					defs = $.mask.definitions;
					tests = [];
					partialPosition = len = _mask.length;
					firstNonMaskPos = null;
					_mask = String(_mask);
					$.each(_mask.split(""), function (i, c) {
						if (c == '?') {
							len--;
							partialPosition = i;
						} else if (defs[c]) {
							tests.push(new RegExp(defs[c]));
							if (firstNonMaskPos === null) {
								firstNonMaskPos = tests.length - 1;
							}
							if (i < partialPosition) {
								lastRequiredNonMaskPos = tests.length - 1;
							}
						} else {
							tests.push(null);
						}
					});
					return this.trigger("unmask").each(function () {
						var input = $(this),
							buffer = $.map(_mask.split(""), function (c, i) {
								if (c != '?') {
									return defs[c] ? getPlaceholder(i) : c;
								}
							}),
							defaultBuffer = buffer.join(''),
							focusText = input.val();

						function tryFireCompleted() {
							if (!settings.completed) {
								return;
							}
							for (var i = firstNonMaskPos; i <= lastRequiredNonMaskPos; i++) {
								if (tests[i] && buffer[i] === getPlaceholder(i)) {
									return;
								}
							}
							settings.completed.call(input);
						}

						function getPlaceholder(i) {
							if (i < settings.placeholder.length) return settings.placeholder.charAt(i);
							return settings.placeholder.charAt(0);
						}

						function seekNext(pos) {
							while (++pos < len && !tests[pos]) { }
							return pos;
						}

						function seekPrev(pos) {
							while (--pos >= 0 && !tests[pos]) { }
							return pos;
						}

						function shiftL(begin, end) {
							var i, j;
							if (begin < 0) {
								return;
							}
							for (i = begin, j = seekNext(end); i < len; i++) {
								if (tests[i]) {
									if (j < len && tests[i].test(buffer[j])) {
										buffer[i] = buffer[j];
										buffer[j] = getPlaceholder(j);
									} else {
										break;
									}
									j = seekNext(j);
								}
							}
							writeBuffer();
							input.caret(Math.max(firstNonMaskPos, begin));
						}

						function shiftR(pos) {
							var i, c, j, t;
							for (i = pos, c = getPlaceholder(pos); i < len; i++) {
								if (tests[i]) {
									j = seekNext(i);
									t = buffer[i];
									buffer[i] = c;
									if (j < len && tests[j].test(t)) {
										c = t;
									} else {
										break;
									}
								}
							}
						}

						function androidInputEvent(e) {
							var curVal = input.val();
							var pos = input.caret();
							if (oldVal && oldVal.length && oldVal.length > curVal.length) {
								checkVal(true);
								while (pos.begin > 0 && !tests[pos.begin - 1]) {
									pos.begin--;
								}
								if (pos.begin === 0) {
									while (pos.begin < firstNonMaskPos && !tests[pos.begin]) {
										pos.begin++;
									}
								}
								input.caret(pos.begin, pos.begin);
							} else {
								var pos2 = checkVal(true);
								var lastEnteredValue = curVal.charAt(pos.begin);
								if (pos.begin < len) {
									if (!tests[pos.begin]) {
										pos.begin++;
										if (tests[pos.begin].test(lastEnteredValue)) {
											pos.begin++;
										}
									} else {
										if (tests[pos.begin].test(lastEnteredValue)) {
											pos.begin++;
										}
									}
								}
								input.caret(pos.begin, pos.begin);
							}
							tryFireCompleted();
						}

						function blurEvent(e) {
							checkVal();
							if (input.val() != focusText) input.change();
						}

						function keydownEvent(e) {
							if (input.prop("readonly")) {
								return;
							}
							var k = e.which || e.keyCode,
								pos, begin, end;
							oldVal = input.val();
							if (k === 8 || k === 46 || iPhone && k === 127) {
								pos = input.caret();
								begin = pos.begin;
								end = pos.end;
								if (end - begin === 0) {
									begin = k !== 46 ? seekPrev(begin) : end = seekNext(begin - 1);
									end = k === 46 ? seekNext(end) : end;
								}
								clearBuffer(begin, end);
								shiftL(begin, end - 1);
								e.preventDefault();
							} else if (k === 13) {
								blurEvent.call(this, e);
							} else if (k === 27) {
								input.val(focusText);
								input.caret(0, checkVal());
								e.preventDefault();
							}
						}

						function keypressEvent(e) {
							if (input.prop("readonly")) {
								return;
							}
							var k = e.which || e.keyCode,
								pos = input.caret(),
								p, c, next;
							if (e.ctrlKey || e.altKey || e.metaKey || k < 32) {
								return;
							} else if (k && k !== 13) {
								if (pos.end - pos.begin !== 0) {
									clearBuffer(pos.begin, pos.end);
									shiftL(pos.begin, pos.end - 1);
								}
								p = seekNext(pos.begin - 1);
								if (p < len) {
									c = String.fromCharCode(k);
									if (tests[p].test(c)) {
										shiftR(p);
										buffer[p] = c;
										writeBuffer();
										next = seekNext(p);
										if (android) {
											var proxy = function proxy() {
												$.proxy($.fn.caret, input, next)();
											};
											setTimeout(proxy, 0);
										} else {
											input.caret(next);
										}
										if (pos.begin <= lastRequiredNonMaskPos) {
											tryFireCompleted();
										}
									}
								}
								e.preventDefault();
							}
						}

						function clearBuffer(start, end) {
							var i;
							for (i = start; i < end && i < len; i++) {
								if (tests[i]) {
									buffer[i] = getPlaceholder(i);
								}
							}
						}

						function writeBuffer() {
							input.val(buffer.join(''));
						}

						function checkVal(allow) {
							var test = input.val(),
								lastMatch = -1,
								i, c, pos;
							for (i = 0, pos = 0; i < len; i++) {
								if (tests[i]) {
									buffer[i] = getPlaceholder(i);
									while (pos++ < test.length) {
										c = test.charAt(pos - 1);
										if (tests[i].test(c)) {
											buffer[i] = c;
											lastMatch = i;
											break;
										}
									}
									if (pos > test.length) {
										clearBuffer(i + 1, len);
										break;
									}
								} else {
									if (buffer[i] === test.charAt(pos)) {
										pos++;
									}
									if (i < partialPosition) {
										lastMatch = i;
									}
								}
							}
							if (allow) {
								writeBuffer();
							} else if (lastMatch + 1 < partialPosition) {
								if (settings.autoclear || buffer.join('') === defaultBuffer) {
									if (input.val()) input.val("");
									clearBuffer(0, len);
								} else {
									writeBuffer();
								}
							} else {
								writeBuffer();
								input.val(input.val().substring(0, lastMatch + 1));
							}
							return partialPosition ? i : firstNonMaskPos;
						}
						input.data($.mask.dataName, function () {
							return $.map(buffer, function (c, i) {
								return tests[i] && c != getPlaceholder(i) ? c : null;
							}).join('');
						});
						input.one("unmask", function () {
							input.off(".mask").removeData($.mask.dataName);
						}).on("focus.mask", function () {
							if (input.prop("readonly")) {
								return;
							}
							clearTimeout(caretTimeoutId);
							var pos;
							focusText = input.val();
							pos = checkVal();
							caretTimeoutId = setTimeout(function () {
								if (input.get(0) !== document.activeElement) {
									return;
								}
								writeBuffer();
								if (pos == _mask.replace("?", "").length) {
									input.caret(0, pos);
								} else {
									input.caret(pos);
								}
							}, 10);
						}).on("blur.mask", blurEvent).on("keydown.mask", keydownEvent).on("keypress.mask", keypressEvent).on("input.mask paste.mask", function () {
							if (input.prop("readonly")) {
								return;
							}
							setTimeout(function () {
								var pos = checkVal(true);
								input.caret(pos);
								tryFireCompleted();
							}, 0);
						});
						if (chrome && android) {
							input.off('input.mask').on('input.mask', androidInputEvent);
						}
						checkVal();
					});
				}
			});
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var _TweenMax = __webpack_require__(3);
			var _TweenMax2 = _interopRequireDefault(_TweenMax);
			var _ScrollMagic = __webpack_require__(2);
			var _ScrollMagic2 = _interopRequireDefault(_ScrollMagic);
			__webpack_require__(23);
			__webpack_require__(25);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : {
					default: obj
				};
			}
			exports.default = function () {
				$(window).on('scroll', function () {
					var top = $(window).scrollTop();
					if (top > 0) {
						$('.header').addClass('fixed');
					} else {
						$('.header').removeClass('fixed');
					}
				});

				function parallaxIt(e, target, movement) {
					var $this = $("body");
					var relX = e.pageX - $this.offset().left;
					var relY = e.pageY - $this.offset().top;
					_TweenMax2.default.to(target, 1, {
						x: (relX - $this.width() / 2) / $this.width() * movement,
						y: (relY - $this.height() / 2) / $this.height() * movement
					});
				}
				$(".form-section").mousemove(function (e) {
					parallaxIt(e, ".form-section__border", -20);
				});
				$(".top-section").mousemove(function (e) {
					parallaxIt(e, ".heading", 25);
				});
				var dashVal = 100;
				var dash = setInterval(function () {
					$('.heading__title').css('opacity', '1');
					dashVal += 25;
					$('.lemon-w').css('stroke-dasharray', '' + dashVal);
					$('.school-w').css('stroke-dasharray', '' + dashVal);
					if (dashVal >= 700) {
						clearInterval(dash);
						$('.lemon-w').css('fill', '#f8e015');
						$('.school-w').css('fill', '#fff');
					}
				}, 100);
				var ctrl = new _ScrollMagic2.default.Controller({
					globalSceneOptions: {
						triggerHook: 'onLeave'
					}
				});
				var instructorVideo = new _TweenMax2.default.from('.instructor-video', .8, {
					'transform': 'translateY(120px)',
					'opacity': 0
				});
				var course = new _TweenMax2.default.staggerFrom('.courses-list-item', .7, {
					'transform': 'translateY(80%)',
					'opacity': 0
				}, .4);
				var partner = new _TweenMax2.default.staggerFrom('.partner__box img', .2, {
					'transform': 'scale(0)',
					'opacity': 0
				}, .1);
				var letter = new _TweenMax2.default.staggerFrom('.letter-box span', 1.3, {
					'top': '0',
					'left': '0',
					'opacity': '0'
				}, .2);
				var programm = new _TweenMax2.default.staggerTo('.programm__col .programm__list-item', .2, {
					css: {
						className: "+=active"
					}
				}, .1);
				var value = new _TweenMax2.default.staggerTo('.our-values__list .our-values__box', 1.2, {
					css: {
						className: "+=active"
					}
				}, .4);
				var vacancie = new _TweenMax2.default.staggerFrom('.vacancies-item__thumb', .6, {
					'transform': 'translateY(120px)'
				}, .2);
				var mission = new _TweenMax2.default.from('.mission', .8, {
					'transform': 'translateY(120px)',
					'opacity': 0
				});
				var instructor = new _TweenMax2.default.staggerTo('.instructor .instructor__box', 1.2, {
					css: {
						className: "+=normal"
					}
				}, .4);
				var triggers = new _TweenMax2.default.staggerTo('.triggers .triggers__box', 1.2, {
					css: {
						className: "+=active"
					}
				}, .4);
				var courseTools = new _TweenMax2.default.staggerTo('.course-tools__box', 1.2, {
					css: {
						className: "+=active"
					}
				}, .2);
				if ($('.courses-list').length > 0) {
					var scene = new _ScrollMagic2.default.Scene({
						triggerElement: '.courses-list',
						offset: -600
					}).setTween(course);
					scene.addTo(ctrl);
				}
				if ($('.instructor-video').length > 0) {
					var iVideo = new _ScrollMagic2.default.Scene({
						triggerElement: '.instructor-video',
						offset: -600
					}).setTween(instructorVideo);
					iVideo.addTo(ctrl);
				}
				if ($('.form-section').length > 0) {
					var sceneForm = new _ScrollMagic2.default.Scene({
						triggerElement: '.form-section',
						offset: -500
					}).setClassToggle('.form-section', 'active');
					sceneForm.addTo(ctrl);
				}
				if ($('.vacancies-list').length > 0) {
					var sceneVacancie = new _ScrollMagic2.default.Scene({
						triggerElement: '.vacancies-list',
						offset: -500
					}).setTween(vacancie);
					sceneVacancie.addTo(ctrl);
				}
				if ($('.mission').length > 0) {
					var sceneMission = new _ScrollMagic2.default.Scene({
						triggerElement: '.mission',
						offset: -800
					}).setTween(mission);
					sceneMission.addTo(ctrl);
				}
				if ($('.partner').length > 0) {
					var scenePartner = new _ScrollMagic2.default.Scene({
						triggerElement: '.partner',
						offset: -500
					}).setTween(partner);
					scenePartner.addTo(ctrl);
				}
				$('.title').each(function () {
					var sceneTitle = new _ScrollMagic2.default.Scene({
						triggerElement: this,
						offset: -350
					}).setClassToggle(this, 'active');
					sceneTitle.addTo(ctrl);
				});
				if ($('.letter-box').length > 0) {
					var sceneLetter = new _ScrollMagic2.default.Scene({
						triggerElement: '.letter-box',
						offset: -650,
						duration: '40%'
					}).setTween(letter);
					sceneLetter.addTo(ctrl);
				}
				if ($('.programm__columns').length > 0) {
					var sceneProgramm = new _ScrollMagic2.default.Scene({
						triggerElement: '.programm__col',
						offset: -400
					}).setTween(programm);
					sceneProgramm.addTo(ctrl);
				}
				if ($('.our-values__list').length > 0) {
					var sceneValue = new _ScrollMagic2.default.Scene({
						triggerElement: '.our-values__box',
						offset: -1200
					}).setTween(value);
					sceneValue.addTo(ctrl);
				}
				if ($('.instructor').length > 0) {
					var sceneInstructor = new _ScrollMagic2.default.Scene({
						triggerElement: '.instructor__box',
						offset: -400
					}).setTween(instructor);
					sceneInstructor.addTo(ctrl);
				}
				if ($('.triggers').length > 0) {
					var sceneTriggers = new _ScrollMagic2.default.Scene({
						triggerElement: '.triggers__box',
						offset: -600
					}).setTween(triggers);
					sceneTriggers.addTo(ctrl);
				}
				if ($('.course-tools__box').length > 0) {
					var sceneTools = new _ScrollMagic2.default.Scene({
						triggerElement: '.course-tools__box',
						offset: -600
					}).setTween(courseTools);
					sceneTools.addTo(ctrl);
				}
				$('.menu-handler').on('click', function () {
					_TweenMax2.default.staggerFrom('.navigation__list > ul > li', .7, {
						'transform': 'translateX(220%)',
						'opacity': '0',
						ease: Back.easeOut.config(1.7)
					}, .2);
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		/*!
		 * ScrollMagic v2.0.5 (2015-04-29)
		 * The javascript library for magical scroll interactions.
		 * (c) 2015 Jan Paepke (@janpaepke)
		 * Project Website: http://scrollmagic.io
		 * 
		 * @version 2.0.5
		 * @license Dual licensed under MIT license and GPL.
		 * @author Jan Paepke - e-mail@janpaepke.de
		 *
		 * @file ScrollMagic GSAP Animation Plugin.
		 *
		 * requires: GSAP ~1.14
		 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
		 * Greensock License info at http://www.greensock.com/licensing/
		 */
		(function (root, factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(3), __webpack_require__(24)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				require('gsap');
				factory(require('scrollmagic'), TweenMax, TimelineMax);
			} else {
				factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic, root.TweenMax || root.TweenLite, root.TimelineMax || root.TimelineLite);
			}
		})(undefined, function (ScrollMagic, Tween, Timeline) {
			"use strict";
			var NAMESPACE = "animation.gsap";
			var console = window.console || {},
				err = Function.prototype.bind.call(console.error || console.log || function () { }, console);
			if (!ScrollMagic) {
				err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
			}
			if (!Tween) {
				err("(" + NAMESPACE + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs.");
			}
			ScrollMagic.Scene.addOption("tweenChanges", false, function (val) {
				return !!val;
			});
			ScrollMagic.Scene.extend(function () {
				var Scene = this,
					_tween;
				var log = function log() {
					if (Scene._log) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
						Scene._log.apply(this, arguments);
					}
				};
				Scene.on("progress.plugin_gsap", function () {
					updateTweenProgress();
				});
				Scene.on("destroy.plugin_gsap", function (e) {
					Scene.removeTween(e.reset);
				});
				var updateTweenProgress = function updateTweenProgress() {
					if (_tween) {
						var progress = Scene.progress(),
							state = Scene.state();
						if (_tween.repeat && _tween.repeat() === -1) {
							if (state === 'DURING' && _tween.paused()) {
								_tween.play();
							} else if (state !== 'DURING' && !_tween.paused()) {
								_tween.pause();
							}
						} else if (progress != _tween.progress()) {
							if (Scene.duration() === 0) {
								if (progress > 0) {
									_tween.play();
								} else {
									_tween.reverse();
								}
							} else {
								if (Scene.tweenChanges() && _tween.tweenTo) {
									_tween.tweenTo(progress * _tween.duration());
								} else {
									_tween.progress(progress).pause();
								}
							}
						}
					}
				};
				Scene.setTween = function (TweenObject, duration, params) {
					var newTween;
					if (arguments.length > 1) {
						if (arguments.length < 3) {
							params = duration;
							duration = 1;
						}
						TweenObject = Tween.to(TweenObject, duration, params);
					}
					try {
						if (Timeline) {
							newTween = new Timeline({
								smoothChildTiming: true
							}).add(TweenObject);
						} else {
							newTween = TweenObject;
						}
						newTween.pause();
					} catch (e) {
						log(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject");
						return Scene;
					}
					if (_tween) {
						Scene.removeTween();
					}
					_tween = newTween;
					if (TweenObject.repeat && TweenObject.repeat() === -1) {
						_tween.repeat(-1);
						_tween.yoyo(TweenObject.yoyo());
					}
					if (Scene.tweenChanges() && !_tween.tweenTo) {
						log(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic.");
					}
					if (_tween && Scene.controller() && Scene.triggerElement() && Scene.loglevel() >= 2) {
						var triggerTweens = Tween.getTweensOf(Scene.triggerElement()),
							vertical = Scene.controller().info("vertical");
						triggerTweens.forEach(function (value, index) {
							var tweenvars = value.vars.css || value.vars,
								condition = vertical ? tweenvars.top !== undefined || tweenvars.bottom !== undefined : tweenvars.left !== undefined || tweenvars.right !== undefined;
							if (condition) {
								log(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!");
								return false;
							}
						});
					}
					if (parseFloat(TweenLite.version) >= 1.14) {
						var list = _tween.getChildren ? _tween.getChildren(true, true, false) : [_tween],
							newCallback = function newCallback() {
								log();
							};
						for (var i = 0, thisTween, oldCallback; i < list.length; i++) {
							thisTween = list[i];
							if (oldCallback !== newCallback) {
								oldCallback = thisTween.vars.onOverwrite;
								thisTween.vars.onOverwrite = function () {
									if (oldCallback) {
										oldCallback.apply(this, arguments);
									}
									newCallback.apply(this, arguments);
								};
							}
						}
					}
					log(3, "added tween");
					updateTweenProgress();
					return Scene;
				};
				Scene.removeTween = function (reset) {
					if (_tween) {
						if (reset) {
							_tween.progress(0).pause();
						}
						_tween.kill();
						_tween = undefined;
						log(3, "removed tween (reset: " + (reset ? "true" : "false") + ")");
					}
					return Scene;
				};
			});
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function (global) {
			var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
			/*!
			 * VERSION: 2.0.1
			 * DATE: 2018-05-30
			 * UPDATES AND DOCS AT: http://greensock.com
			 *
			 * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
			 * This work is subject to the terms at http://greensock.com/standard-license or for
			 * Club GreenSock members, the software agreement that was issued with your membership.
			 * 
			 * @author: Jack Doyle, jack@greensock.com
			 */
			var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : undefined || window;
			(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
				"use strict";
				_gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {
					var TimelineMax = function TimelineMax(vars) {
						TimelineLite.call(this, vars);
						this._repeat = this.vars.repeat || 0;
						this._repeatDelay = this.vars.repeatDelay || 0;
						this._cycle = 0;
						this._yoyo = this.vars.yoyo === true;
						this._dirty = true;
					},
						_tinyNum = 0.0000000001,
						TweenLiteInternals = TweenLite._internals,
						_lazyTweens = TweenLiteInternals.lazyTweens,
						_lazyRender = TweenLiteInternals.lazyRender,
						_globals = _gsScope._gsDefine.globals,
						_easeNone = new Ease(null, null, 1, 0),
						p = TimelineMax.prototype = new TimelineLite();
					p.constructor = TimelineMax;
					p.kill()._gc = false;
					TimelineMax.version = "2.0.1";
					p.invalidate = function () {
						this._yoyo = this.vars.yoyo === true;
						this._repeat = this.vars.repeat || 0;
						this._repeatDelay = this.vars.repeatDelay || 0;
						this._uncache(true);
						return TimelineLite.prototype.invalidate.call(this);
					};
					p.addCallback = function (callback, position, params, scope) {
						return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
					};
					p.removeCallback = function (callback, position) {
						if (callback) {
							if (position == null) {
								this._kill(null, callback);
							} else {
								var a = this.getTweensOf(callback, false),
									i = a.length,
									time = this._parseTimeOrLabel(position);
								while (--i > -1) {
									if (a[i]._startTime === time) {
										a[i]._enabled(false, false);
									}
								}
							}
						}
						return this;
					};
					p.removePause = function (position) {
						return this.removeCallback(TimelineLite._internals.pauseCallback, position);
					};
					p.tweenTo = function (position, vars) {
						vars = vars || {};
						var copy = {
							ease: _easeNone,
							useFrames: this.usesFrames(),
							immediateRender: false,
							lazy: false
						},
							Engine = vars.repeat && _globals.TweenMax || TweenLite,
							duration, p, t;
						for (p in vars) {
							copy[p] = vars[p];
						}
						copy.time = this._parseTimeOrLabel(position);
						duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001;
						t = new Engine(this, duration, copy);
						copy.onStart = function () {
							t.target.paused(true);
							if (t.vars.time !== t.target.time() && duration === t.duration() && !t.isFromTo) {
								t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale).render(t.time(), true, true);
							}
							if (vars.onStart) {
								vars.onStart.apply(vars.onStartScope || vars.callbackScope || t, vars.onStartParams || []);
							}
						};
						return t;
					};
					p.tweenFromTo = function (fromPosition, toPosition, vars) {
						vars = vars || {};
						fromPosition = this._parseTimeOrLabel(fromPosition);
						vars.startAt = {
							onComplete: this.seek,
							onCompleteParams: [fromPosition],
							callbackScope: this
						};
						vars.immediateRender = vars.immediateRender !== false;
						var t = this.tweenTo(toPosition, vars);
						t.isFromTo = 1;
						return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
					};
					p.render = function (time, suppressEvents, force) {
						if (this._gc) {
							this._enabled(true, false);
						}
						var prevTime = this._time,
							totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
							dur = this._duration,
							prevTotalTime = this._totalTime,
							prevStart = this._startTime,
							prevTimeScale = this._timeScale,
							prevRawPrevTime = this._rawPrevTime,
							prevPaused = this._paused,
							prevCycle = this._cycle,
							tween, isComplete, next, callback, internalForce, cycleDuration, pauseTween, curTime;
						if (prevTime !== this._time) {
							time += this._time - prevTime;
						}
						if (time >= totalDur - 0.0000001 && time >= 0) {
							if (!this._locked) {
								this._totalTime = totalDur;
								this._cycle = this._repeat;
							}
							if (!this._reversed)
								if (!this._hasPausedChild()) {
									isComplete = true;
									callback = "onComplete";
									internalForce = !!this._timeline.autoRemoveChildren;
									if (this._duration === 0)
										if (time <= 0 && time >= -0.0000001 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)
											if (prevRawPrevTime !== time && this._first) {
												internalForce = true;
												if (prevRawPrevTime > _tinyNum) {
													callback = "onReverseComplete";
												}
											}
								}
							this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
							if (this._yoyo && (this._cycle & 1) !== 0) {
								this._time = time = 0;
							} else {
								this._time = dur;
								time = dur + 0.0001;
							}
						} else if (time < 0.0000001) {
							if (!this._locked) {
								this._totalTime = this._cycle = 0;
							}
							this._time = 0;
							if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
								callback = "onReverseComplete";
								isComplete = this._reversed;
							}
							if (time < 0) {
								this._active = false;
								if (this._timeline.autoRemoveChildren && this._reversed) {
									internalForce = isComplete = true;
									callback = "onReverseComplete";
								} else if (prevRawPrevTime >= 0 && this._first) {
									internalForce = true;
								}
								this._rawPrevTime = time;
							} else {
								this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
								if (time === 0 && isComplete) {
									tween = this._first;
									while (tween && tween._startTime === 0) {
										if (!tween._duration) {
											isComplete = false;
										}
										tween = tween._next;
									}
								}
								time = 0;
								if (!this._initted) {
									internalForce = true;
								}
							}
						} else {
							if (dur === 0 && prevRawPrevTime < 0) {
								internalForce = true;
							}
							this._time = this._rawPrevTime = time;
							if (!this._locked) {
								this._totalTime = time;
								if (this._repeat !== 0) {
									cycleDuration = dur + this._repeatDelay;
									this._cycle = this._totalTime / cycleDuration >> 0;
									if (this._cycle !== 0)
										if (this._cycle === this._totalTime / cycleDuration && prevTotalTime <= time) {
											this._cycle--;
										}
									this._time = this._totalTime - this._cycle * cycleDuration;
									if (this._yoyo)
										if ((this._cycle & 1) !== 0) {
											this._time = dur - this._time;
										}
									if (this._time > dur) {
										this._time = dur;
										time = dur + 0.0001;
									} else if (this._time < 0) {
										this._time = time = 0;
									} else {
										time = this._time;
									}
								}
							}
							if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
								time = this._time;
								if (time >= prevTime || this._repeat && prevCycle !== this._cycle) {
									tween = this._first;
									while (tween && tween._startTime <= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
												pauseTween = tween;
											}
										tween = tween._next;
									}
								} else {
									tween = this._last;
									while (tween && tween._startTime >= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && tween._rawPrevTime > 0) {
												pauseTween = tween;
											}
										tween = tween._prev;
									}
								}
								if (pauseTween && pauseTween._startTime < dur) {
									this._time = time = pauseTween._startTime;
									this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
								}
							}
						}
						if (this._cycle !== prevCycle)
							if (!this._locked) {
								var backwards = this._yoyo && (prevCycle & 1) !== 0,
									wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
									recTotalTime = this._totalTime,
									recCycle = this._cycle,
									recRawPrevTime = this._rawPrevTime,
									recTime = this._time;
								this._totalTime = prevCycle * dur;
								if (this._cycle < prevCycle) {
									backwards = !backwards;
								} else {
									this._totalTime += dur;
								}
								this._time = prevTime;
								this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.0001 : prevRawPrevTime;
								this._cycle = prevCycle;
								this._locked = true;
								prevTime = backwards ? 0 : dur;
								this.render(prevTime, suppressEvents, dur === 0);
								if (!suppressEvents)
									if (!this._gc) {
										if (this.vars.onRepeat) {
											this._cycle = recCycle;
											this._locked = false;
											this._callback("onRepeat");
										}
									}
								if (prevTime !== this._time) {
									return;
								}
								if (wrap) {
									this._cycle = prevCycle;
									this._locked = true;
									prevTime = backwards ? dur + 0.0001 : -0.0001;
									this.render(prevTime, true, false);
								}
								this._locked = false;
								if (this._paused && !prevPaused) {
									return;
								}
								this._time = recTime;
								this._totalTime = recTotalTime;
								this._cycle = recCycle;
								this._rawPrevTime = recRawPrevTime;
							}
						if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
							if (prevTotalTime !== this._totalTime)
								if (this._onUpdate)
									if (!suppressEvents) {
										this._callback("onUpdate");
									}
							return;
						} else if (!this._initted) {
							this._initted = true;
						}
						if (!this._active)
							if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
								this._active = true;
							}
						if (prevTotalTime === 0)
							if (this.vars.onStart)
								if (this._totalTime !== 0 || !this._totalDuration)
									if (!suppressEvents) {
										this._callback("onStart");
									}
						curTime = this._time;
						if (curTime >= prevTime) {
							tween = this._first;
							while (tween) {
								next = tween._next;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						} else {
							tween = this._last;
							while (tween) {
								next = tween._prev;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										pauseTween = tween._prev;
										while (pauseTween && pauseTween.endTime() > this._time) {
											pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
											pauseTween = pauseTween._prev;
										}
										pauseTween = null;
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						}
						if (this._onUpdate)
							if (!suppressEvents) {
								if (_lazyTweens.length) {
									_lazyRender();
								}
								this._callback("onUpdate");
							}
						if (callback)
							if (!this._locked)
								if (!this._gc)
									if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
										if (this._time === 0 || totalDur >= this.totalDuration()) {
											if (isComplete) {
												if (_lazyTweens.length) {
													_lazyRender();
												}
												if (this._timeline.autoRemoveChildren) {
													this._enabled(false, false);
												}
												this._active = false;
											}
											if (!suppressEvents && this.vars[callback]) {
												this._callback(callback);
											}
										}
					};
					p.getActive = function (nested, tweens, timelines) {
						if (nested == null) {
							nested = true;
						}
						if (tweens == null) {
							tweens = true;
						}
						if (timelines == null) {
							timelines = false;
						}
						var a = [],
							all = this.getChildren(nested, tweens, timelines),
							cnt = 0,
							l = all.length,
							i, tween;
						for (i = 0; i < l; i++) {
							tween = all[i];
							if (tween.isActive()) {
								a[cnt++] = tween;
							}
						}
						return a;
					};
					p.getLabelAfter = function (time) {
						if (!time)
							if (time !== 0) {
								time = this._time;
							}
						var labels = this.getLabelsArray(),
							l = labels.length,
							i;
						for (i = 0; i < l; i++) {
							if (labels[i].time > time) {
								return labels[i].name;
							}
						}
						return null;
					};
					p.getLabelBefore = function (time) {
						if (time == null) {
							time = this._time;
						}
						var labels = this.getLabelsArray(),
							i = labels.length;
						while (--i > -1) {
							if (labels[i].time < time) {
								return labels[i].name;
							}
						}
						return null;
					};
					p.getLabelsArray = function () {
						var a = [],
							cnt = 0,
							p;
						for (p in this._labels) {
							a[cnt++] = {
								time: this._labels[p],
								name: p
							};
						}
						a.sort(function (a, b) {
							return a.time - b.time;
						});
						return a;
					};
					p.invalidate = function () {
						this._locked = false;
						return TimelineLite.prototype.invalidate.call(this);
					};
					p.progress = function (value, suppressEvents) {
						return !arguments.length ? this._time / this.duration() || 0 : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents);
					};
					p.totalProgress = function (value, suppressEvents) {
						return !arguments.length ? this._totalTime / this.totalDuration() || 0 : this.totalTime(this.totalDuration() * value, suppressEvents);
					};
					p.totalDuration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								TimelineLite.prototype.totalDuration.call(this);
								this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
							}
							return this._totalDuration;
						}
						return this._repeat === -1 || !value ? this : this.timeScale(this.totalDuration() / value);
					};
					p.time = function (value, suppressEvents) {
						if (!arguments.length) {
							return this._time;
						}
						if (this._dirty) {
							this.totalDuration();
						}
						if (value > this._duration) {
							value = this._duration;
						}
						if (this._yoyo && (this._cycle & 1) !== 0) {
							value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
						} else if (this._repeat !== 0) {
							value += this._cycle * (this._duration + this._repeatDelay);
						}
						return this.totalTime(value, suppressEvents);
					};
					p.repeat = function (value) {
						if (!arguments.length) {
							return this._repeat;
						}
						this._repeat = value;
						return this._uncache(true);
					};
					p.repeatDelay = function (value) {
						if (!arguments.length) {
							return this._repeatDelay;
						}
						this._repeatDelay = value;
						return this._uncache(true);
					};
					p.yoyo = function (value) {
						if (!arguments.length) {
							return this._yoyo;
						}
						this._yoyo = value;
						return this;
					};
					p.currentLabel = function (value) {
						if (!arguments.length) {
							return this.getLabelBefore(this._time + 0.00000001);
						}
						return this.seek(value, true);
					};
					return TimelineMax;
				}, true);
				_gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
					var TimelineLite = function TimelineLite(vars) {
						SimpleTimeline.call(this, vars);
						this._labels = {};
						this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
						this.smoothChildTiming = this.vars.smoothChildTiming === true;
						this._sortChildren = true;
						this._onUpdate = this.vars.onUpdate;
						var v = this.vars,
							val, p;
						for (p in v) {
							val = v[p];
							if (_isArray(val))
								if (val.join("").indexOf("{self}") !== -1) {
									v[p] = this._swapSelfInParams(val);
								}
						}
						if (_isArray(v.tweens)) {
							this.add(v.tweens, 0, v.align, v.stagger);
						}
					},
						_tinyNum = 0.0000000001,
						TweenLiteInternals = TweenLite._internals,
						_internals = TimelineLite._internals = {},
						_isSelector = TweenLiteInternals.isSelector,
						_isArray = TweenLiteInternals.isArray,
						_lazyTweens = TweenLiteInternals.lazyTweens,
						_lazyRender = TweenLiteInternals.lazyRender,
						_globals = _gsScope._gsDefine.globals,
						_copy = function _copy(vars) {
							var copy = {},
								p;
							for (p in vars) {
								copy[p] = vars[p];
							}
							return copy;
						},
						_applyCycle = function _applyCycle(vars, targets, i) {
							var alt = vars.cycle,
								p, val;
							for (p in alt) {
								val = alt[p];
								vars[p] = typeof val === "function" ? val(i, targets[i]) : val[i % val.length];
							}
							delete vars.cycle;
						},
						_pauseCallback = _internals.pauseCallback = function () { },
						_slice = function _slice(a) {
							var b = [],
								l = a.length,
								i;
							for (i = 0; i !== l; b.push(a[i++])) { }
							return b;
						},
						p = TimelineLite.prototype = new SimpleTimeline();
					TimelineLite.version = "2.0.1";
					p.constructor = TimelineLite;
					p.kill()._gc = p._forcingPlayhead = p._hasPause = false;
					p.to = function (target, duration, vars, position) {
						var Engine = vars.repeat && _globals.TweenMax || TweenLite;
						return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position);
					};
					p.from = function (target, duration, vars, position) {
						return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position);
					};
					p.fromTo = function (target, duration, fromVars, toVars, position) {
						var Engine = toVars.repeat && _globals.TweenMax || TweenLite;
						return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
					};
					p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						var tl = new TimelineLite({
							onComplete: onCompleteAll,
							onCompleteParams: onCompleteAllParams,
							callbackScope: onCompleteAllScope,
							smoothChildTiming: this.smoothChildTiming
						}),
							cycle = vars.cycle,
							copy, i;
						if (typeof targets === "string") {
							targets = TweenLite.selector(targets) || targets;
						}
						targets = targets || [];
						if (_isSelector(targets)) {
							targets = _slice(targets);
						}
						stagger = stagger || 0;
						if (stagger < 0) {
							targets = _slice(targets);
							targets.reverse();
							stagger *= -1;
						}
						for (i = 0; i < targets.length; i++) {
							copy = _copy(vars);
							if (copy.startAt) {
								copy.startAt = _copy(copy.startAt);
								if (copy.startAt.cycle) {
									_applyCycle(copy.startAt, targets, i);
								}
							}
							if (cycle) {
								_applyCycle(copy, targets, i);
								if (copy.duration != null) {
									duration = copy.duration;
									delete copy.duration;
								}
							}
							tl.to(targets[i], duration, copy, i * stagger);
						}
						return this.add(tl, position);
					};
					p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						vars.immediateRender = vars.immediateRender != false;
						vars.runBackwards = true;
						return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
						toVars.startAt = fromVars;
						toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
						return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
					};
					p.call = function (callback, params, scope, position) {
						return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
					};
					p.set = function (target, vars, position) {
						position = this._parseTimeOrLabel(position, 0, true);
						if (vars.immediateRender == null) {
							vars.immediateRender = position === this._time && !this._paused;
						}
						return this.add(new TweenLite(target, 0, vars), position);
					};
					TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
						vars = vars || {};
						if (vars.smoothChildTiming == null) {
							vars.smoothChildTiming = true;
						}
						var tl = new TimelineLite(vars),
							root = tl._timeline,
							hasNegativeStart, time, tween, next;
						if (ignoreDelayedCalls == null) {
							ignoreDelayedCalls = true;
						}
						root._remove(tl, true);
						tl._startTime = 0;
						tl._rawPrevTime = tl._time = tl._totalTime = root._time;
						tween = root._first;
						while (tween) {
							next = tween._next;
							if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
								time = tween._startTime - tween._delay;
								if (time < 0) {
									hasNegativeStart = 1;
								}
								tl.add(tween, time);
							}
							tween = next;
						}
						root.add(tl, 0);
						if (hasNegativeStart) {
							tl.totalDuration();
						}
						return tl;
					};
					p.add = function (value, position, align, stagger) {
						var curTime, l, i, child, tl, beforeRawTime;
						if (typeof position !== "number") {
							position = this._parseTimeOrLabel(position, 0, true, value);
						}
						if (!(value instanceof Animation)) {
							if (value instanceof Array || value && value.push && _isArray(value)) {
								align = align || "normal";
								stagger = stagger || 0;
								curTime = position;
								l = value.length;
								for (i = 0; i < l; i++) {
									if (_isArray(child = value[i])) {
										child = new TimelineLite({
											tweens: child
										});
									}
									this.add(child, curTime);
									if (typeof child !== "string" && typeof child !== "function") {
										if (align === "sequence") {
											curTime = child._startTime + child.totalDuration() / child._timeScale;
										} else if (align === "start") {
											child._startTime -= child.delay();
										}
									}
									curTime += stagger;
								}
								return this._uncache(true);
							} else if (typeof value === "string") {
								return this.addLabel(value, position);
							} else if (typeof value === "function") {
								value = TweenLite.delayedCall(0, value);
							} else {
								throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
							}
						}
						SimpleTimeline.prototype.add.call(this, value, position);
						if (value._time) {
							value.render((this.rawTime() - value._startTime) * value._timeScale, false, false);
						}
						if (this._gc || this._time === this._duration)
							if (!this._paused)
								if (this._duration < this.duration()) {
									tl = this;
									beforeRawTime = tl.rawTime() > value._startTime;
									while (tl._timeline) {
										if (beforeRawTime && tl._timeline.smoothChildTiming) {
											tl.totalTime(tl._totalTime, true);
										} else if (tl._gc) {
											tl._enabled(true, false);
										}
										tl = tl._timeline;
									}
								}
						return this;
					};
					p.remove = function (value) {
						if (value instanceof Animation) {
							this._remove(value, false);
							var tl = value._timeline = value.vars.useFrames ? Animation._rootFramesTimeline : Animation._rootTimeline;
							value._startTime = (value._paused ? value._pauseTime : tl._time) - (!value._reversed ? value._totalTime : value.totalDuration() - value._totalTime) / value._timeScale;
							return this;
						} else if (value instanceof Array || value && value.push && _isArray(value)) {
							var i = value.length;
							while (--i > -1) {
								this.remove(value[i]);
							}
							return this;
						} else if (typeof value === "string") {
							return this.removeLabel(value);
						}
						return this.kill(null, value);
					};
					p._remove = function (tween, skipDisable) {
						SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
						var last = this._last;
						if (!last) {
							this._time = this._totalTime = this._duration = this._totalDuration = 0;
						} else if (this._time > this.duration()) {
							this._time = this._duration;
							this._totalTime = this._totalDuration;
						}
						return this;
					};
					p.append = function (value, offsetOrLabel) {
						return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
					};
					p.insert = p.insertMultiple = function (value, position, align, stagger) {
						return this.add(value, position || 0, align, stagger);
					};
					p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
						return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
					};
					p.addLabel = function (label, position) {
						this._labels[label] = this._parseTimeOrLabel(position);
						return this;
					};
					p.addPause = function (position, callback, params, scope) {
						var t = TweenLite.delayedCall(0, _pauseCallback, params, scope || this);
						t.vars.onComplete = t.vars.onReverseComplete = callback;
						t.data = "isPause";
						this._hasPause = true;
						return this.add(t, position);
					};
					p.removeLabel = function (label) {
						delete this._labels[label];
						return this;
					};
					p.getLabelTime = function (label) {
						return this._labels[label] != null ? this._labels[label] : -1;
					};
					p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
						var clippedDuration, i;
						if (ignore instanceof Animation && ignore.timeline === this) {
							this.remove(ignore);
						} else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
							i = ignore.length;
							while (--i > -1) {
								if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
									this.remove(ignore[i]);
								}
							}
						}
						clippedDuration = typeof timeOrLabel === "number" && !offsetOrLabel ? 0 : this.duration() > 99999999999 ? this.recent().endTime(false) : this._duration;
						if (typeof offsetOrLabel === "string") {
							return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - clippedDuration : 0, appendIfAbsent);
						}
						offsetOrLabel = offsetOrLabel || 0;
						if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
							i = timeOrLabel.indexOf("=");
							if (i === -1) {
								if (this._labels[timeOrLabel] == null) {
									return appendIfAbsent ? this._labels[timeOrLabel] = clippedDuration + offsetOrLabel : offsetOrLabel;
								}
								return this._labels[timeOrLabel] + offsetOrLabel;
							}
							offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
							timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : clippedDuration;
						} else if (timeOrLabel == null) {
							timeOrLabel = clippedDuration;
						}
						return Number(timeOrLabel) + offsetOrLabel;
					};
					p.seek = function (position, suppressEvents) {
						return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
					};
					p.stop = function () {
						return this.paused(true);
					};
					p.gotoAndPlay = function (position, suppressEvents) {
						return this.play(position, suppressEvents);
					};
					p.gotoAndStop = function (position, suppressEvents) {
						return this.pause(position, suppressEvents);
					};
					p.render = function (time, suppressEvents, force) {
						if (this._gc) {
							this._enabled(true, false);
						}
						var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
							prevTime = this._time,
							prevStart = this._startTime,
							prevTimeScale = this._timeScale,
							prevPaused = this._paused,
							tween, isComplete, next, callback, internalForce, pauseTween, curTime;
						if (time >= totalDur - 0.0000001 && time >= 0) {
							this._totalTime = this._time = totalDur;
							if (!this._reversed)
								if (!this._hasPausedChild()) {
									isComplete = true;
									callback = "onComplete";
									internalForce = !!this._timeline.autoRemoveChildren;
									if (this._duration === 0)
										if (time <= 0 && time >= -0.0000001 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)
											if (this._rawPrevTime !== time && this._first) {
												internalForce = true;
												if (this._rawPrevTime > _tinyNum) {
													callback = "onReverseComplete";
												}
											}
								}
							this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
							time = totalDur + 0.0001;
						} else if (time < 0.0000001) {
							this._totalTime = this._time = 0;
							if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
								callback = "onReverseComplete";
								isComplete = this._reversed;
							}
							if (time < 0) {
								this._active = false;
								if (this._timeline.autoRemoveChildren && this._reversed) {
									internalForce = isComplete = true;
									callback = "onReverseComplete";
								} else if (this._rawPrevTime >= 0 && this._first) {
									internalForce = true;
								}
								this._rawPrevTime = time;
							} else {
								this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum;
								if (time === 0 && isComplete) {
									tween = this._first;
									while (tween && tween._startTime === 0) {
										if (!tween._duration) {
											isComplete = false;
										}
										tween = tween._next;
									}
								}
								time = 0;
								if (!this._initted) {
									internalForce = true;
								}
							}
						} else {
							if (this._hasPause && !this._forcingPlayhead && !suppressEvents) {
								if (time >= prevTime) {
									tween = this._first;
									while (tween && tween._startTime <= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && !tween.ratio && !(tween._startTime === 0 && this._rawPrevTime === 0)) {
												pauseTween = tween;
											}
										tween = tween._next;
									}
								} else {
									tween = this._last;
									while (tween && tween._startTime >= time && !pauseTween) {
										if (!tween._duration)
											if (tween.data === "isPause" && tween._rawPrevTime > 0) {
												pauseTween = tween;
											}
										tween = tween._prev;
									}
								}
								if (pauseTween) {
									this._time = time = pauseTween._startTime;
									this._totalTime = time + this._cycle * (this._totalDuration + this._repeatDelay);
								}
							}
							this._totalTime = this._time = this._rawPrevTime = time;
						}
						if ((this._time === prevTime || !this._first) && !force && !internalForce && !pauseTween) {
							return;
						} else if (!this._initted) {
							this._initted = true;
						}
						if (!this._active)
							if (!this._paused && this._time !== prevTime && time > 0) {
								this._active = true;
							}
						if (prevTime === 0)
							if (this.vars.onStart)
								if (this._time !== 0 || !this._duration)
									if (!suppressEvents) {
										this._callback("onStart");
									}
						curTime = this._time;
						if (curTime >= prevTime) {
							tween = this._first;
							while (tween) {
								next = tween._next;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= curTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						} else {
							tween = this._last;
							while (tween) {
								next = tween._prev;
								if (curTime !== this._time || this._paused && !prevPaused) {
									break;
								} else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
									if (pauseTween === tween) {
										pauseTween = tween._prev;
										while (pauseTween && pauseTween.endTime() > this._time) {
											pauseTween.render(pauseTween._reversed ? pauseTween.totalDuration() - (time - pauseTween._startTime) * pauseTween._timeScale : (time - pauseTween._startTime) * pauseTween._timeScale, suppressEvents, force);
											pauseTween = pauseTween._prev;
										}
										pauseTween = null;
										this.pause();
									}
									if (!tween._reversed) {
										tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
									} else {
										tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
									}
								}
								tween = next;
							}
						}
						if (this._onUpdate)
							if (!suppressEvents) {
								if (_lazyTweens.length) {
									_lazyRender();
								}
								this._callback("onUpdate");
							}
						if (callback)
							if (!this._gc)
								if (prevStart === this._startTime || prevTimeScale !== this._timeScale)
									if (this._time === 0 || totalDur >= this.totalDuration()) {
										if (isComplete) {
											if (_lazyTweens.length) {
												_lazyRender();
											}
											if (this._timeline.autoRemoveChildren) {
												this._enabled(false, false);
											}
											this._active = false;
										}
										if (!suppressEvents && this.vars[callback]) {
											this._callback(callback);
										}
									}
					};
					p._hasPausedChild = function () {
						var tween = this._first;
						while (tween) {
							if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
								return true;
							}
							tween = tween._next;
						}
						return false;
					};
					p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
						ignoreBeforeTime = ignoreBeforeTime || -9999999999;
						var a = [],
							tween = this._first,
							cnt = 0;
						while (tween) {
							if (tween._startTime < ignoreBeforeTime) { } else if (tween instanceof TweenLite) {
								if (tweens !== false) {
									a[cnt++] = tween;
								}
							} else {
								if (timelines !== false) {
									a[cnt++] = tween;
								}
								if (nested !== false) {
									a = a.concat(tween.getChildren(true, tweens, timelines));
									cnt = a.length;
								}
							}
							tween = tween._next;
						}
						return a;
					};
					p.getTweensOf = function (target, nested) {
						var disabled = this._gc,
							a = [],
							cnt = 0,
							tweens, i;
						if (disabled) {
							this._enabled(true, true);
						}
						tweens = TweenLite.getTweensOf(target);
						i = tweens.length;
						while (--i > -1) {
							if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
								a[cnt++] = tweens[i];
							}
						}
						if (disabled) {
							this._enabled(false, true);
						}
						return a;
					};
					p.recent = function () {
						return this._recent;
					};
					p._contains = function (tween) {
						var tl = tween.timeline;
						while (tl) {
							if (tl === this) {
								return true;
							}
							tl = tl.timeline;
						}
						return false;
					};
					p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
						ignoreBeforeTime = ignoreBeforeTime || 0;
						var tween = this._first,
							labels = this._labels,
							p;
						while (tween) {
							if (tween._startTime >= ignoreBeforeTime) {
								tween._startTime += amount;
							}
							tween = tween._next;
						}
						if (adjustLabels) {
							for (p in labels) {
								if (labels[p] >= ignoreBeforeTime) {
									labels[p] += amount;
								}
							}
						}
						return this._uncache(true);
					};
					p._kill = function (vars, target) {
						if (!vars && !target) {
							return this._enabled(false, false);
						}
						var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
							i = tweens.length,
							changed = false;
						while (--i > -1) {
							if (tweens[i]._kill(vars, target)) {
								changed = true;
							}
						}
						return changed;
					};
					p.clear = function (labels) {
						var tweens = this.getChildren(false, true, true),
							i = tweens.length;
						this._time = this._totalTime = 0;
						while (--i > -1) {
							tweens[i]._enabled(false, false);
						}
						if (labels !== false) {
							this._labels = {};
						}
						return this._uncache(true);
					};
					p.invalidate = function () {
						var tween = this._first;
						while (tween) {
							tween.invalidate();
							tween = tween._next;
						}
						return Animation.prototype.invalidate.call(this);;
					};
					p._enabled = function (enabled, ignoreTimeline) {
						if (enabled === this._gc) {
							var tween = this._first;
							while (tween) {
								tween._enabled(enabled, true);
								tween = tween._next;
							}
						}
						return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
					};
					p.totalTime = function (time, suppressEvents, uncapped) {
						this._forcingPlayhead = true;
						var val = Animation.prototype.totalTime.apply(this, arguments);
						this._forcingPlayhead = false;
						return val;
					};
					p.duration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								this.totalDuration();
							}
							return this._duration;
						}
						if (this.duration() !== 0 && value !== 0) {
							this.timeScale(this._duration / value);
						}
						return this;
					};
					p.totalDuration = function (value) {
						if (!arguments.length) {
							if (this._dirty) {
								var max = 0,
									tween = this._last,
									prevStart = 999999999999,
									prev, end;
								while (tween) {
									prev = tween._prev;
									if (tween._dirty) {
										tween.totalDuration();
									}
									if (tween._startTime > prevStart && this._sortChildren && !tween._paused && !this._calculatingDuration) {
										this._calculatingDuration = 1;
										this.add(tween, tween._startTime - tween._delay);
										this._calculatingDuration = 0;
									} else {
										prevStart = tween._startTime;
									}
									if (tween._startTime < 0 && !tween._paused) {
										max -= tween._startTime;
										if (this._timeline.smoothChildTiming) {
											this._startTime += tween._startTime / this._timeScale;
											this._time -= tween._startTime;
											this._totalTime -= tween._startTime;
											this._rawPrevTime -= tween._startTime;
										}
										this.shiftChildren(-tween._startTime, false, -9999999999);
										prevStart = 0;
									}
									end = tween._startTime + tween._totalDuration / tween._timeScale;
									if (end > max) {
										max = end;
									}
									tween = prev;
								}
								this._duration = this._totalDuration = max;
								this._dirty = false;
							}
							return this._totalDuration;
						}
						return value && this.totalDuration() ? this.timeScale(this._totalDuration / value) : this;
					};
					p.paused = function (value) {
						if (!value) {
							var tween = this._first,
								time = this._time;
							while (tween) {
								if (tween._startTime === time && tween.data === "isPause") {
									tween._rawPrevTime = 0;
								}
								tween = tween._next;
							}
						}
						return Animation.prototype.paused.apply(this, arguments);
					};
					p.usesFrames = function () {
						var tl = this._timeline;
						while (tl._timeline) {
							tl = tl._timeline;
						}
						return tl === Animation._rootFramesTimeline;
					};
					p.rawTime = function (wrapRepeats) {
						return wrapRepeats && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(wrapRepeats) - this._startTime) * this._timeScale;
					};
					return TimelineLite;
				}, true);
			});
			if (_gsScope._gsDefine) {
				_gsScope._gsQueue.pop()();
			}
			(function (name) {
				"use strict";
				var getGlobal = function getGlobal() {
					return (_gsScope.GreenSockGlobals || _gsScope)[name];
				};
				if (typeof module !== "undefined" && module.exports) {
					__webpack_require__(4);
					module.exports = getGlobal();
				} else if (true) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (getGlobal), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				}
			})("TimelineMax");
		}.call(exports, __webpack_require__(1)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		/*!
		 * ScrollMagic v2.0.5 (2015-04-29)
		 * The javascript library for magical scroll interactions.
		 * (c) 2015 Jan Paepke (@janpaepke)
		 * Project Website: http://scrollmagic.io
		 * 
		 * @version 2.0.5
		 * @license Dual licensed under MIT license and GPL.
		 * @author Jan Paepke - e-mail@janpaepke.de
		 *
		 * @file Debug Extension for ScrollMagic.
		 */
		(function (root, factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {
				factory(require('scrollmagic'));
			} else {
				factory(root.ScrollMagic || root.jQuery && root.jQuery.ScrollMagic);
			}
		})(undefined, function (ScrollMagic) {
			"use strict";
			var NAMESPACE = "debug.addIndicators";
			var console = window.console || {},
				err = Function.prototype.bind.call(console.error || console.log || function () { }, console);
			if (!ScrollMagic) {
				err("(" + NAMESPACE + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs.");
			}
			var FONT_SIZE = "0.85em",
				ZINDEX = "9999",
				EDGE_OFFSET = 15;
			var _util = ScrollMagic._util,
				_autoindex = 0;
			ScrollMagic.Scene.extend(function () {
				var Scene = this,
					_indicator;
				var log = function log() {
					if (Scene._log) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
						Scene._log.apply(this, arguments);
					}
				};
				Scene.addIndicators = function (options) {
					if (!_indicator) {
						var DEFAULT_OPTIONS = {
							name: "",
							indent: 0,
							parent: undefined,
							colorStart: "green",
							colorEnd: "red",
							colorTrigger: "blue"
						};
						options = _util.extend({}, DEFAULT_OPTIONS, options);
						_autoindex++;
						_indicator = new Indicator(Scene, options);
						Scene.on("add.plugin_addIndicators", _indicator.add);
						Scene.on("remove.plugin_addIndicators", _indicator.remove);
						Scene.on("destroy.plugin_addIndicators", Scene.removeIndicators);
						if (Scene.controller()) {
							_indicator.add();
						}
					}
					return Scene;
				};
				Scene.removeIndicators = function () {
					if (_indicator) {
						_indicator.remove();
						this.off("*.plugin_addIndicators");
						_indicator = undefined;
					}
					return Scene;
				};
			});
			ScrollMagic.Controller.addOption("addIndicators", false);
			ScrollMagic.Controller.extend(function () {
				var Controller = this,
					_info = Controller.info(),
					_container = _info.container,
					_isDocument = _info.isDocument,
					_vertical = _info.vertical,
					_indicators = {
						groups: []
					};
				var log = function log() {
					if (Controller._log) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
						Controller._log.apply(this, arguments);
					}
				};
				if (Controller._indicators) {
					log(2, "WARNING: Scene already has a property '_indicators', which will be overwritten by plugin.");
				}
				this._indicators = _indicators;
				var handleBoundsPositionChange = function handleBoundsPositionChange() {
					_indicators.updateBoundsPositions();
				};
				var handleTriggerPositionChange = function handleTriggerPositionChange() {
					_indicators.updateTriggerGroupPositions();
				};
				_container.addEventListener("resize", handleTriggerPositionChange);
				if (!_isDocument) {
					window.addEventListener("resize", handleTriggerPositionChange);
					window.addEventListener("scroll", handleTriggerPositionChange);
				}
				_container.addEventListener("resize", handleBoundsPositionChange);
				_container.addEventListener("scroll", handleBoundsPositionChange);
				this._indicators.updateBoundsPositions = function (specificIndicator) {
					var
						groups = specificIndicator ? [_util.extend({}, specificIndicator.triggerGroup, {
							members: [specificIndicator]
						})] : _indicators.groups,
						g = groups.length,
						css = {},
						paramPos = _vertical ? "left" : "top",
						paramDimension = _vertical ? "width" : "height",
						edge = _vertical ? _util.get.scrollLeft(_container) + _util.get.width(_container) - EDGE_OFFSET : _util.get.scrollTop(_container) + _util.get.height(_container) - EDGE_OFFSET,
						b, triggerSize, group;
					while (g--) {
						group = groups[g];
						b = group.members.length;
						triggerSize = _util.get[paramDimension](group.element.firstChild);
						while (b--) {
							css[paramPos] = edge - triggerSize;
							_util.css(group.members[b].bounds, css);
						}
					}
				};
				this._indicators.updateTriggerGroupPositions = function (specificGroup) {
					var
						groups = specificGroup ? [specificGroup] : _indicators.groups,
						i = groups.length,
						container = _isDocument ? document.body : _container,
						containerOffset = _isDocument ? {
							top: 0,
							left: 0
						} : _util.get.offset(container, true),
						edge = _vertical ? _util.get.width(_container) - EDGE_OFFSET : _util.get.height(_container) - EDGE_OFFSET,
						paramDimension = _vertical ? "width" : "height",
						paramTransform = _vertical ? "Y" : "X";
					var
						group, elem, pos, elemSize, transform;
					while (i--) {
						group = groups[i];
						elem = group.element;
						pos = group.triggerHook * Controller.info("size");
						elemSize = _util.get[paramDimension](elem.firstChild.firstChild);
						transform = pos > elemSize ? "translate" + paramTransform + "(-100%)" : "";
						_util.css(elem, {
							top: containerOffset.top + (_vertical ? pos : edge - group.members[0].options.indent),
							left: containerOffset.left + (_vertical ? edge - group.members[0].options.indent : pos)
						});
						_util.css(elem.firstChild.firstChild, {
							"-ms-transform": transform,
							"-webkit-transform": transform,
							"transform": transform
						});
					}
				};
				this._indicators.updateTriggerGroupLabel = function (group) {
					var text = "trigger" + (group.members.length > 1 ? "" : " " + group.members[0].options.name),
						elem = group.element.firstChild.firstChild,
						doUpdate = elem.textContent !== text;
					if (doUpdate) {
						elem.textContent = text;
						if (_vertical) {
							_indicators.updateBoundsPositions();
						}
					}
				};
				this.addScene = function (newScene) {
					if (this._options.addIndicators && newScene instanceof ScrollMagic.Scene && newScene.controller() === Controller) {
						newScene.addIndicators();
					}
					this.$super.addScene.apply(this, arguments);
				};
				this.destroy = function () {
					_container.removeEventListener("resize", handleTriggerPositionChange);
					if (!_isDocument) {
						window.removeEventListener("resize", handleTriggerPositionChange);
						window.removeEventListener("scroll", handleTriggerPositionChange);
					}
					_container.removeEventListener("resize", handleBoundsPositionChange);
					_container.removeEventListener("scroll", handleBoundsPositionChange);
					this.$super.destroy.apply(this, arguments);
				};
				return Controller;
			});
			var Indicator = function Indicator(Scene, options) {
				var Indicator = this,
					_elemBounds = TPL.bounds(),
					_elemStart = TPL.start(options.colorStart),
					_elemEnd = TPL.end(options.colorEnd),
					_boundsContainer = options.parent && _util.get.elements(options.parent)[0],
					_vertical, _ctrl;
				var log = function log() {
					if (Scene._log) {
						Array.prototype.splice.call(arguments, 1, 0, "(" + NAMESPACE + ")", "->");
						Scene._log.apply(this, arguments);
					}
				};
				options.name = options.name || _autoindex;
				_elemStart.firstChild.textContent += " " + options.name;
				_elemEnd.textContent += " " + options.name;
				_elemBounds.appendChild(_elemStart);
				_elemBounds.appendChild(_elemEnd);
				Indicator.options = options;
				Indicator.bounds = _elemBounds;
				Indicator.triggerGroup = undefined;
				this.add = function () {
					_ctrl = Scene.controller();
					_vertical = _ctrl.info("vertical");
					var isDocument = _ctrl.info("isDocument");
					if (!_boundsContainer) {
						_boundsContainer = isDocument ? document.body : _ctrl.info("container");
					}
					if (!isDocument && _util.css(_boundsContainer, "position") === 'static') {
						_util.css(_boundsContainer, {
							position: "relative"
						});
					}
					Scene.on("change.plugin_addIndicators", handleTriggerParamsChange);
					Scene.on("shift.plugin_addIndicators", handleBoundsParamsChange);
					updateTriggerGroup();
					updateBounds();
					setTimeout(function () {
						_ctrl._indicators.updateBoundsPositions(Indicator);
					}, 0);
					log(3, "added indicators");
				};
				this.remove = function () {
					if (Indicator.triggerGroup) {
						Scene.off("change.plugin_addIndicators", handleTriggerParamsChange);
						Scene.off("shift.plugin_addIndicators", handleBoundsParamsChange);
						if (Indicator.triggerGroup.members.length > 1) {
							var group = Indicator.triggerGroup;
							group.members.splice(group.members.indexOf(Indicator), 1);
							_ctrl._indicators.updateTriggerGroupLabel(group);
							_ctrl._indicators.updateTriggerGroupPositions(group);
							Indicator.triggerGroup = undefined;
						} else {
							removeTriggerGroup();
						}
						removeBounds();
						log(3, "removed indicators");
					}
				};
				var handleBoundsParamsChange = function handleBoundsParamsChange() {
					updateBounds();
				};
				var handleTriggerParamsChange = function handleTriggerParamsChange(e) {
					if (e.what === "triggerHook") {
						updateTriggerGroup();
					}
				};
				var addBounds = function addBounds() {
					var v = _ctrl.info("vertical");
					_util.css(_elemStart.firstChild, {
						"border-bottom-width": v ? 1 : 0,
						"border-right-width": v ? 0 : 1,
						"bottom": v ? -1 : options.indent,
						"right": v ? options.indent : -1,
						"padding": v ? "0 8px" : "2px 4px"
					});
					_util.css(_elemEnd, {
						"border-top-width": v ? 1 : 0,
						"border-left-width": v ? 0 : 1,
						"top": v ? "100%" : "",
						"right": v ? options.indent : "",
						"bottom": v ? "" : options.indent,
						"left": v ? "" : "100%",
						"padding": v ? "0 8px" : "2px 4px"
					});
					_boundsContainer.appendChild(_elemBounds);
				};
				var removeBounds = function removeBounds() {
					_elemBounds.parentNode.removeChild(_elemBounds);
				};
				var updateBounds = function updateBounds() {
					if (_elemBounds.parentNode !== _boundsContainer) {
						addBounds();
					}
					var css = {};
					css[_vertical ? "top" : "left"] = Scene.triggerPosition();
					css[_vertical ? "height" : "width"] = Scene.duration();
					_util.css(_elemBounds, css);
					_util.css(_elemEnd, {
						display: Scene.duration() > 0 ? "" : "none"
					});
				};
				var addTriggerGroup = function addTriggerGroup() {
					var triggerElem = TPL.trigger(options.colorTrigger);
					var css = {};
					css[_vertical ? "right" : "bottom"] = 0;
					css[_vertical ? "border-top-width" : "border-left-width"] = 1;
					_util.css(triggerElem.firstChild, css);
					_util.css(triggerElem.firstChild.firstChild, {
						padding: _vertical ? "0 8px 3px 8px" : "3px 4px"
					});
					document.body.appendChild(triggerElem);
					var newGroup = {
						triggerHook: Scene.triggerHook(),
						element: triggerElem,
						members: [Indicator]
					};
					_ctrl._indicators.groups.push(newGroup);
					Indicator.triggerGroup = newGroup;
					_ctrl._indicators.updateTriggerGroupLabel(newGroup);
					_ctrl._indicators.updateTriggerGroupPositions(newGroup);
				};
				var removeTriggerGroup = function removeTriggerGroup() {
					_ctrl._indicators.groups.splice(_ctrl._indicators.groups.indexOf(Indicator.triggerGroup), 1);
					Indicator.triggerGroup.element.parentNode.removeChild(Indicator.triggerGroup.element);
					Indicator.triggerGroup = undefined;
				};
				var updateTriggerGroup = function updateTriggerGroup() {
					var triggerHook = Scene.triggerHook(),
						closeEnough = 0.0001;
					if (Indicator.triggerGroup) {
						if (Math.abs(Indicator.triggerGroup.triggerHook - triggerHook) < closeEnough) {
							return;
						}
					}
					var groups = _ctrl._indicators.groups,
						group, i = groups.length;
					while (i--) {
						group = groups[i];
						if (Math.abs(group.triggerHook - triggerHook) < closeEnough) {
							if (Indicator.triggerGroup) {
								if (Indicator.triggerGroup.members.length === 1) {
									removeTriggerGroup();
								} else {
									Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1);
									_ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);
									_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
								}
							}
							group.members.push(Indicator);
							Indicator.triggerGroup = group;
							_ctrl._indicators.updateTriggerGroupLabel(group);
							return;
						}
					}
					if (Indicator.triggerGroup) {
						if (Indicator.triggerGroup.members.length === 1) {
							Indicator.triggerGroup.triggerHook = triggerHook;
							_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
							return;
						} else {
							Indicator.triggerGroup.members.splice(Indicator.triggerGroup.members.indexOf(Indicator), 1);
							_ctrl._indicators.updateTriggerGroupLabel(Indicator.triggerGroup);
							_ctrl._indicators.updateTriggerGroupPositions(Indicator.triggerGroup);
							Indicator.triggerGroup = undefined;
						}
					}
					addTriggerGroup();
				};
			};
			var TPL = {
				start: function start(color) {
					var inner = document.createElement("div");
					inner.textContent = "start";
					_util.css(inner, {
						position: "absolute",
						overflow: "visible",
						"border-width": 0,
						"border-style": "solid",
						color: color,
						"border-color": color
					});
					var e = document.createElement('div');
					_util.css(e, {
						position: "absolute",
						overflow: "visible",
						width: 0,
						height: 0
					});
					e.appendChild(inner);
					return e;
				},
				end: function end(color) {
					var e = document.createElement('div');
					e.textContent = "end";
					_util.css(e, {
						position: "absolute",
						overflow: "visible",
						"border-width": 0,
						"border-style": "solid",
						color: color,
						"border-color": color
					});
					return e;
				},
				bounds: function bounds() {
					var e = document.createElement('div');
					_util.css(e, {
						position: "absolute",
						overflow: "visible",
						"white-space": "nowrap",
						"pointer-events": "none",
						"font-size": FONT_SIZE
					});
					e.style.zIndex = ZINDEX;
					return e;
				},
				trigger: function trigger(color) {
					var inner = document.createElement('div');
					inner.textContent = "trigger";
					_util.css(inner, {
						position: "relative"
					});
					var w = document.createElement('div');
					_util.css(w, {
						position: "absolute",
						overflow: "visible",
						"border-width": 0,
						"border-style": "solid",
						color: color,
						"border-color": color
					});
					w.appendChild(inner);
					var e = document.createElement('div');
					_util.css(e, {
						position: "fixed",
						overflow: "visible",
						"white-space": "nowrap",
						"pointer-events": "none",
						"font-size": FONT_SIZE
					});
					e.style.zIndex = ZINDEX;
					e.appendChild(w);
					return e;
				}
			};
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		(function ($) {
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = function () {
				var popupVideo = '';
				$('.modal').on('click', function () {
					var modal = $(this).data('modal');
					$('body').addClass('fixCaret');
					$('.pop-up').removeClass('active');
					$(modal).addClass('active');
					if ($(window).width() > 1250) {
						$('.wrapper').css('margin-top', '100vh');
					}
				});
				$('.close-handler, .pop-up__overlay').on('click', function () {
					$(this).parents('.pop-up').removeClass('active');
					$(this).parents('.pop-up').find('iframe').attr('src', popupVideo);
					$('body').removeClass('fixCaret');
					$('.wrapper').css('margin-top', '0');
				});
				$('.course-video .heading-video__btn').on('click', function () {
					popupVideo = $('#video-pop-up').find('iframe').attr('src');
					$('#video-pop-up').addClass('active');
				});
			};
		}.call(exports, __webpack_require__(0)))
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		(function (factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else {
				factory(jQuery);
			}
		})(function ($, undefined) {
			'use strict';
			var prefix = 'social-likes';
			var classPrefix = prefix + '__';
			var openClass = prefix + '_opened';
			var protocol = location.protocol === 'https:' ? 'https:' : 'http:';
			var services = {
				facebook: {
					counterUrl: '',
					convertNumber: function convertNumber(data) {
						return data.share.share_count;
					},
					popupUrl: '',
					popupWidth: 600,
					popupHeight: 359
				},
				twitter: {
					counters: false,
					popupUrl: '',
					popupWidth: 600,
					popupHeight: 250,
					click: function click() {
						if (!/[.?:\-–—]\s*$/.test(this.options.title)) {
							this.options.title += ':';
						}
						return true;
					}
				},
				mailru: {
					counterUrl: protocol + '',
					convertNumber: function convertNumber(data) {
						for (var url in data) {
							if (data.hasOwnProperty(url)) {
								return data[url].shares;
							}
						}
					},
					popupUrl: '',
					popupWidth: 492,
					popupHeight: 500
				},
				vkontakte: {
					counterUrl: '',
					counter: function counter(jsonUrl, deferred) {
						var options = services.vkontakte;
						if (!options._) {
							options._ = [];
							if (!window.VK) {
								window.VK = {};
							}
							window.VK.Share = {
								count: function count(idx, number) {
									options._[idx].resolve(number);
								}
							};
						}
						var index = options._.length;
						options._.push(deferred);
						$.getScript(makeUrl(jsonUrl, {
							index: index
						})).fail(deferred.reject);
					},
					popupUrl: '',
					popupWidth: 655,
					popupHeight: 450
				},
				odnoklassniki: {
					counterUrl: protocol + '',
					counter: function counter(jsonUrl, deferred) {
						var options = services.odnoklassniki;
						if (!options._) {
							options._ = [];
							if (!window.ODKL) {
								window.ODKL = {};
							}
							window.ODKL.updateCount = function (idx, number) {
								options._[idx].resolve(number);
							};
						}
						var index = options._.length;
						options._.push(deferred);
						$.getScript(makeUrl(jsonUrl, {
							index: index
						})).fail(deferred.reject);
					},
					popupUrl: '',
					popupWidth: 580,
					popupHeight: 336
				},
				plusone: {
					counters: false,
					popupUrl: '',
					popupWidth: 500,
					popupHeight: 550
				},
				pinterest: {
					counterUrl: protocol + '',
					convertNumber: function convertNumber(data) {
						return data.count;
					},
					popupUrl: '',
					popupWidth: 740,
					popupHeight: 550
				}
			};
			var counters = {
				promises: {},
				fetch: function fetch(service, url, extraOptions) {
					if (!counters.promises[service]) {
						counters.promises[service] = {};
					}
					var servicePromises = counters.promises[service];
					if (!extraOptions.forceUpdate && servicePromises[url]) {
						return servicePromises[url];
					}
					var options = $.extend({}, services[service], extraOptions);
					var deferred = $.Deferred();
					var jsonUrl = options.counterUrl && makeUrl(options.counterUrl, {
						url: url
					});
					if (jsonUrl && $.isFunction(options.counter)) {
						options.counter(jsonUrl, deferred);
					} else if (options.counterUrl) {
						$.getJSON(jsonUrl).done(function (data) {
							try {
								var number = data;
								if ($.isFunction(options.convertNumber)) {
									number = options.convertNumber(data);
								}
								deferred.resolve(number);
							} catch (e) {
								deferred.reject();
							}
						}).fail(deferred.reject);
					} else {
						deferred.reject();
					}
					servicePromises[url] = deferred.promise();
					return servicePromises[url];
				}
			};
			$.fn.socialLikes = function (options) {
				return this.each(function () {
					var elem = $(this);
					var instance = elem.data(prefix);
					if (instance) {
						if ($.isPlainObject(options)) {
							instance.update(options);
						}
					} else {
						instance = new SocialLikes(elem, $.extend({}, $.fn.socialLikes.defaults, options, dataToOptions(elem)));
						elem.data(prefix, instance);
					}
				});
			};
			$.fn.socialLikes.defaults = {
				url: window.location.href.replace(window.location.hash, ''),
				title: document.title,
				counters: true,
				zeroes: false,
				wait: 500,
				timeout: 10000,
				popupCheckInterval: 500,
				singleTitle: 'Share'
			};

			function SocialLikes(container, options) {
				this.container = container;
				this.options = options;
				this.init();
			}
			SocialLikes.prototype = {
				init: function init() {
					this.container.addClass(prefix);
					this.single = this.container.hasClass(prefix + '_single');
					this.initUserButtons();
					this.countersLeft = 0;
					this.number = 0;
					this.container.on('counter.' + prefix, $.proxy(this.updateCounter, this));
					var buttons = this.container.children();
					this.makeSingleButton();
					this.buttons = [];
					buttons.each($.proxy(function (idx, elem) {
						var button = new Button($(elem), this.options);
						this.buttons.push(button);
						if (button.options.counterUrl) {
							this.countersLeft++;
						}
					}, this));
					if (this.options.counters) {
						this.timer = setTimeout($.proxy(this.appear, this), this.options.wait);
						this.timeout = setTimeout($.proxy(this.ready, this, true), this.options.timeout);
					} else {
						this.appear();
					}
				},
				initUserButtons: function initUserButtons() {
					if (!this.userButtonInited && window.socialLikesButtons) {
						$.extend(true, services, socialLikesButtons);
					}
					this.userButtonInited = true;
				},
				makeSingleButton: function makeSingleButton() {
					if (!this.single) {
						return;
					}
					var container = this.container;
					container.addClass(prefix + '_vertical');
					container.wrap($('<div>', {
						class: prefix + '_single-w'
					}));
					container.wrapInner($('<div>', {
						class: prefix + '__single-container'
					}));
					var wrapper = container.parent();
					var widget = $('<div>', {
						class: _getElementClassNames('widget', 'single')
					});
					var button = $(template('<div class="{buttonCls}">' + '<span class="{iconCls}"></span>' + '{title}' + '</div>', {
						buttonCls: _getElementClassNames('button', 'single'),
						iconCls: _getElementClassNames('icon', 'single'),
						title: this.options.singleTitle
					}));
					widget.append(button);
					wrapper.append(widget);
					widget.on('click', function () {
						var activeClass = prefix + '__widget_active';
						widget.toggleClass(activeClass);
						if (widget.hasClass(activeClass)) {
							container.css({
								left: -(container.width() - widget.width()) / 2,
								top: -container.height()
							});
							showInViewport(container);
							closeOnClick(container, function () {
								widget.removeClass(activeClass);
							});
						} else {
							container.removeClass(openClass);
						}
						return false;
					});
					this.widget = widget;
				},
				update: function update(options) {
					if (!options.forceUpdate && options.url === this.options.url) {
						return;
					}
					this.number = 0;
					this.countersLeft = this.buttons.length;
					if (this.widget) {
						this.widget.find('.' + prefix + '__counter').remove();
					}
					$.extend(this.options, options);
					for (var buttonIdx = 0; buttonIdx < this.buttons.length; buttonIdx++) {
						this.buttons[buttonIdx].update(options);
					}
				},
				updateCounter: function updateCounter(e, service, number) {
					number = number || 0;
					if (number || this.options.zeroes) {
						this.number += number;
						if (this.single) {
							this.getCounterElem().text(this.number);
						}
					}
					this.countersLeft--;
					if (this.countersLeft === 0) {
						this.appear();
						this.ready();
					}
				},
				appear: function appear() {
					this.container.addClass(prefix + '_visible');
				},
				ready: function ready(silent) {
					if (this.timeout) {
						clearTimeout(this.timeout);
					}
					this.container.addClass(prefix + '_ready');
					if (!silent) {
						this.container.trigger('ready.' + prefix, this.number);
					}
				},
				getCounterElem: function getCounterElem() {
					var counterElem = this.widget.find('.' + classPrefix + 'counter_single');
					if (!counterElem.length) {
						counterElem = $('<span>', {
							class: _getElementClassNames('counter', 'single')
						});
						this.widget.append(counterElem);
					}
					return counterElem;
				}
			};

			function Button(widget, options) {
				this.widget = widget;
				this.options = $.extend({}, options);
				this.detectService();
				if (this.service) {
					this.init();
				}
			}
			Button.prototype = {
				init: function init() {
					this.detectParams();
					this.initHtml();
					setTimeout($.proxy(this.initCounter, this), 0);
				},
				update: function update(options) {
					$.extend(this.options, {
						forceUpdate: false
					}, options);
					this.widget.find('.' + prefix + '__counter').remove();
					this.initCounter();
				},
				detectService: function detectService() {
					var service = this.widget.data('service');
					if (!service) {
						var node = this.widget[0];
						var classes = node.classList || node.className.split(' ');
						for (var classIdx = 0; classIdx < classes.length; classIdx++) {
							var cls = classes[classIdx];
							if (services[cls]) {
								service = cls;
								break;
							}
						}
						if (!service) {
							return;
						}
					}
					this.service = service;
					$.extend(this.options, services[service]);
				},
				detectParams: function detectParams() {
					var data = this.widget.data();
					if (data.counter) {
						var number = parseInt(data.counter, 10);
						if (isNaN(number)) {
							this.options.counterUrl = data.counter;
						} else {
							this.options.counterNumber = number;
						}
					}
					if (data.title) {
						this.options.title = data.title;
					}
					if (data.url) {
						this.options.url = data.url;
					}
				},
				initHtml: function initHtml() {
					var options = this.options;
					var widget = this.widget;
					var a = widget.find('a');
					if (a.length) {
						this.cloneDataAttrs(a, widget);
					}
					var button = $('<span>', {
						class: this.getElementClassNames('button'),
						html: widget.html()
					});
					if (options.clickUrl) {
						var url = makeUrl(options.clickUrl, {
							url: options.url,
							title: options.title
						});
						var link = $('<a>', {
							href: url
						});
						this.cloneDataAttrs(widget, link);
						widget.replaceWith(link);
						this.widget = link;
						widget = link;
					} else {
						widget.on('click', $.proxy(this.click, this));
					}
					widget.removeClass(this.service);
					widget.addClass(this.getElementClassNames('widget'));
					button.prepend($('<span>', {
						class: this.getElementClassNames('icon')
					}));
					widget.empty().append(button);
					this.button = button;
				},
				initCounter: function initCounter() {
					if (this.options.counters) {
						if (this.options.counterNumber) {
							this.updateCounter(this.options.counterNumber);
						} else {
							var extraOptions = {
								counterUrl: this.options.counterUrl,
								forceUpdate: this.options.forceUpdate
							};
							counters.fetch(this.service, this.options.url, extraOptions).always($.proxy(this.updateCounter, this));
						}
					}
				},
				cloneDataAttrs: function cloneDataAttrs(source, destination) {
					var data = source.data();
					for (var key in data) {
						if (data.hasOwnProperty(key)) {
							destination.data(key, data[key]);
						}
					}
				},
				getElementClassNames: function getElementClassNames(elem) {
					return _getElementClassNames(elem, this.service);
				},
				updateCounter: function updateCounter(number) {
					number = parseInt(number, 10) || 0;
					var params = {
						class: this.getElementClassNames('counter'),
						text: number
					};
					if (!number && !this.options.zeroes) {
						params.class += ' ' + prefix + '__counter_empty';
						params.text = '';
					}
					var counterElem = this.widget.find('.' + classPrefix + 'counter_' + this.service);
					if (!counterElem.length) {
						counterElem = $('<span>', params);
						this.widget.append(counterElem);
					}
					this.widget.trigger('counter.' + prefix, [this.service, number]);
				},
				click: function click(e) {
					var options = this.options;
					var process = true;
					if ($.isFunction(options.click)) {
						process = options.click.call(this, e);
					}
					if (process) {
						var url = makeUrl(options.popupUrl, {
							url: options.url,
							title: options.title
						});
						url = this.addAdditionalParamsToUrl(url);
						this.openPopup(url, {
							width: options.popupWidth,
							height: options.popupHeight
						});
					}
					return false;
				},
				addAdditionalParamsToUrl: function addAdditionalParamsToUrl(url) {
					var params = $.param($.extend(this.widget.data(), this.options.data));
					if ($.isEmptyObject(params)) {
						return url;
					}
					var glue = url.indexOf('?') === -1 ? '?' : '&';
					return url + glue + params;
				},
				openPopup: function openPopup(url, params) {
					var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;
					var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;
					var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
					var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
					var left = Math.round(width / 2 - params.width / 2) + dualScreenLeft;
					var top = 0;
					if (height > params.height) {
						top = Math.round(height / 3 - params.height / 2) + dualScreenTop;
					}
					var win = window.open(url, 'sl_' + this.service, 'left=' + left + ',top=' + top + ',' + 'width=' + params.width + ',height=' + params.height + ',personalbar=0,toolbar=0,scrollbars=1,resizable=1');
					if (win) {
						win.focus();
						this.widget.trigger('popup_opened.' + prefix, [this.service, win]);
						var timer = setInterval($.proxy(function () {
							if (!win.closed) {
								return;
							}
							clearInterval(timer);
							this.widget.trigger('popup_closed.' + prefix, this.service);
						}, this), this.options.popupCheckInterval);
					} else {
						location.href = url;
					}
				}
			};

			function dataToOptions(elem) {
				function upper(m, l) {
					return l.toUpper();
				}
				var options = {};
				var data = elem.data();
				for (var key in data) {
					var value = data[key];
					if (value === 'yes') {
						value = true;
					} else if (value === 'no') {
						value = false;
					}
					options[key.replace(/-(\w)/g, upper)] = value;
				}
				return options;
			}

			function makeUrl(url, context) {
				return template(url, context, encodeURIComponent);
			}

			function template(tmpl, context, filter) {
				return tmpl.replace(/\{([^}]+)\}/g, function (m, key) {
					return key in context ? filter ? filter(context[key]) : context[key] : m;
				});
			}

			function _getElementClassNames(elem, mod) {
				var cls = classPrefix + elem;
				return cls + ' ' + cls + '_' + mod;
			}

			function closeOnClick(elem, callback) {
				function handler(e) {
					if (e.type === 'keydown' && e.which !== 27 || $(e.target).closest(elem).length) {
						return;
					}
					elem.removeClass(openClass);
					doc.off(events, handler);
					if ($.isFunction(callback)) {
						callback();
					}
				}
				var doc = $(document);
				var events = 'click touchstart keydown';
				doc.on(events, handler);
			}

			function showInViewport(elem) {
				var offset = 10;
				if (document.documentElement.getBoundingClientRect) {
					var left = parseInt(elem.css('left'), 10);
					var top = parseInt(elem.css('top'), 10);
					var rect = elem[0].getBoundingClientRect();
					if (rect.left < offset) {
						elem.css('left', offset - rect.left + left);
					} else if (rect.right > window.innerWidth - offset) {
						elem.css('left', window.innerWidth - rect.right - offset + left);
					}
					if (rect.top < offset) {
						elem.css('top', offset - rect.top + top);
					} else if (rect.bottom > window.innerHeight - offset) {
						elem.css('top', window.innerHeight - rect.bottom - offset + top);
					}
				}
				elem.addClass(openClass);
			}
			$(function () {
				$('.' + prefix).socialLikes();
			});
		});
	}), (function (module, exports, __webpack_require__) {
		"use strict";
		var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
			return typeof obj;
		} : function (obj) {
			return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
		};
		(function (factory) {
			if (true) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			} else if (typeof module !== "undefined" && module.exports) {
				module.exports = factory;
			} else {
				factory(jQuery, window, document);
			}
		})(function ($) {
			(function (init) {
				var _rjs = "function" === "function" && __webpack_require__(29),
					_njs = typeof module !== "undefined" && module.exports,
					_dlp = "https:" == document.location.protocol ? "https:" : "http:",
					_url = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
				if (!_rjs) {
					if (_njs) {
						__webpack_require__(5)($);
					} else {
						$.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src=" + _dlp + _url + "%3E%3C/script%3E"));
					}
				}
				init();
			})(function () {
				var pluginNS = "mCustomScrollbar",
					pluginPfx = "mCS",
					defaultSelector = ".mCustomScrollbar",
					defaults = {
						setTop: 0,
						setLeft: 0,
						axis: "y",
						scrollbarPosition: "inside",
						scrollInertia: 950,
						autoDraggerLength: true,
						alwaysShowScrollbar: 0,
						snapOffset: 0,
						mouseWheel: {
							enable: true,
							scrollAmount: "auto",
							axis: "y",
							deltaFactor: "auto",
							disableOver: ["select", "option", "keygen", "datalist", "textarea"]
						},
						scrollButtons: {
							scrollType: "stepless",
							scrollAmount: "auto"
						},
						keyboard: {
							enable: true,
							scrollType: "stepless",
							scrollAmount: "auto"
						},
						contentTouchScroll: 25,
						documentTouchScroll: true,
						advanced: {
							autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
							updateOnContentResize: true,
							updateOnImageLoad: "auto",
							autoUpdateTimeout: 60
						},
						theme: "light",
						callbacks: {
							onTotalScrollOffset: 0,
							onTotalScrollBackOffset: 0,
							alwaysTriggerOffsets: true
						}
					},
					totalInstances = 0,
					liveTimers = {},
					oldIE = window.attachEvent && !window.addEventListener ? 1 : 0,
					touchActive = false,
					touchable, classes = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
					methods = {
						init: function init(options) {
							var options = $.extend(true, {}, defaults, options),
								selector = _selector.call(this);
							if (options.live) {
								var liveSelector = options.liveSelector || this.selector || defaultSelector,
									$liveSelector = $(liveSelector);
								if (options.live === "off") {
									removeLiveTimers(liveSelector);
									return;
								}
								liveTimers[liveSelector] = setTimeout(function () {
									$liveSelector.mCustomScrollbar(options);
									if (options.live === "once" && $liveSelector.length) {
										removeLiveTimers(liveSelector);
									}
								}, 500);
							} else {
								removeLiveTimers(liveSelector);
							}
							options.setWidth = options.set_width ? options.set_width : options.setWidth;
							options.setHeight = options.set_height ? options.set_height : options.setHeight;
							options.axis = options.horizontalScroll ? "x" : _findAxis(options.axis);
							options.scrollInertia = options.scrollInertia > 0 && options.scrollInertia < 17 ? 17 : options.scrollInertia;
							if (_typeof(options.mouseWheel) !== "object" && options.mouseWheel == true) {
								options.mouseWheel = {
									enable: true,
									scrollAmount: "auto",
									axis: "y",
									preventDefault: false,
									deltaFactor: "auto",
									normalizeDelta: false,
									invert: false
								};
							}
							options.mouseWheel.scrollAmount = !options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
							options.mouseWheel.normalizeDelta = !options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
							options.scrollButtons.scrollType = _findScrollButtonsType(options.scrollButtons.scrollType);
							_theme(options);
							return $(selector).each(function () {
								var $this = $(this);
								if (!$this.data(pluginPfx)) {
									$this.data(pluginPfx, {
										idx: ++totalInstances,
										opt: options,
										scrollRatio: {
											y: null,
											x: null
										},
										overflowed: null,
										contentReset: {
											y: null,
											x: null
										},
										bindEvents: false,
										tweenRunning: false,
										sequential: {},
										langDir: $this.css("direction"),
										cbOffsets: null,
										trigger: null,
										poll: {
											size: {
												o: 0,
												n: 0
											},
											img: {
												o: 0,
												n: 0
											},
											change: {
												o: 0,
												n: 0
											}
										}
									});
									var d = $this.data(pluginPfx),
										o = d.opt,
										htmlDataAxis = $this.data("mcs-axis"),
										htmlDataSbPos = $this.data("mcs-scrollbar-position"),
										htmlDataTheme = $this.data("mcs-theme");
									if (htmlDataAxis) {
										o.axis = htmlDataAxis;
									}
									if (htmlDataSbPos) {
										o.scrollbarPosition = htmlDataSbPos;
									}
									if (htmlDataTheme) {
										o.theme = htmlDataTheme;
										_theme(o);
									}
									_pluginMarkup.call(this);
									if (d && o.callbacks.onCreate && typeof o.callbacks.onCreate === "function") {
										o.callbacks.onCreate.call(this);
									}
									$("#mCSB_" + d.idx + "_container img:not(." + classes[2] + ")").addClass(classes[2]);
									methods.update.call(null, $this);
								}
							});
						},
						update: function update(el, cb) {
							var selector = el || _selector.call(this);
							return $(selector).each(function () {
								var $this = $(this);
								if ($this.data(pluginPfx)) {
									var d = $this.data(pluginPfx),
										o = d.opt,
										mCSB_container = $("#mCSB_" + d.idx + "_container"),
										mCustomScrollBox = $("#mCSB_" + d.idx),
										mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
									if (!mCSB_container.length) {
										return;
									}
									if (d.tweenRunning) {
										_stop($this);
									}
									if (cb && d && o.callbacks.onBeforeUpdate && typeof o.callbacks.onBeforeUpdate === "function") {
										o.callbacks.onBeforeUpdate.call(this);
									}
									if ($this.hasClass(classes[3])) {
										$this.removeClass(classes[3]);
									}
									if ($this.hasClass(classes[4])) {
										$this.removeClass(classes[4]);
									}
									mCustomScrollBox.css("max-height", "none");
									if (mCustomScrollBox.height() !== $this.height()) {
										mCustomScrollBox.css("max-height", $this.height());
									}
									_expandContentHorizontally.call(this);
									if (o.axis !== "y" && !o.advanced.autoExpandHorizontalScroll) {
										mCSB_container.css("width", _contentWidth(mCSB_container));
									}
									d.overflowed = _overflowed.call(this);
									_scrollbarVisibility.call(this);
									if (o.autoDraggerLength) {
										_setDraggerLength.call(this);
									}
									_scrollRatio.call(this);
									_bindEvents.call(this);
									var to = [Math.abs(mCSB_container[0].offsetTop), Math.abs(mCSB_container[0].offsetLeft)];
									if (o.axis !== "x") {
										if (!d.overflowed[0]) {
											_resetContentPosition.call(this);
											if (o.axis === "y") {
												_unbindEvents.call(this);
											} else if (o.axis === "yx" && d.overflowed[1]) {
												_scrollTo($this, to[1].toString(), {
													dir: "x",
													dur: 0,
													overwrite: "none"
												});
											}
										} else if (mCSB_dragger[0].height() > mCSB_dragger[0].parent().height()) {
											_resetContentPosition.call(this);
										} else {
											_scrollTo($this, to[0].toString(), {
												dir: "y",
												dur: 0,
												overwrite: "none"
											});
											d.contentReset.y = null;
										}
									}
									if (o.axis !== "y") {
										if (!d.overflowed[1]) {
											_resetContentPosition.call(this);
											if (o.axis === "x") {
												_unbindEvents.call(this);
											} else if (o.axis === "yx" && d.overflowed[0]) {
												_scrollTo($this, to[0].toString(), {
													dir: "y",
													dur: 0,
													overwrite: "none"
												});
											}
										} else if (mCSB_dragger[1].width() > mCSB_dragger[1].parent().width()) {
											_resetContentPosition.call(this);
										} else {
											_scrollTo($this, to[1].toString(), {
												dir: "x",
												dur: 0,
												overwrite: "none"
											});
											d.contentReset.x = null;
										}
									}
									if (cb && d) {
										if (cb === 2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad === "function") {
											o.callbacks.onImageLoad.call(this);
										} else if (cb === 3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange === "function") {
											o.callbacks.onSelectorChange.call(this);
										} else if (o.callbacks.onUpdate && typeof o.callbacks.onUpdate === "function") {
											o.callbacks.onUpdate.call(this);
										}
									}
									_autoUpdate.call(this);
								}
							});
						},
						scrollTo: function scrollTo(val, options) {
							if (typeof val == "undefined" || val == null) {
								return;
							}
							var selector = _selector.call(this);
							return $(selector).each(function () {
								var $this = $(this);
								if ($this.data(pluginPfx)) {
									var d = $this.data(pluginPfx),
										o = d.opt,
										methodDefaults = {
											trigger: "external",
											scrollInertia: o.scrollInertia,
											scrollEasing: "mcsEaseInOut",
											moveDragger: false,
											timeout: 60,
											callbacks: true,
											onStart: true,
											onUpdate: true,
											onComplete: true
										},
										methodOptions = $.extend(true, {}, methodDefaults, options),
										to = _arr.call(this, val),
										dur = methodOptions.scrollInertia > 0 && methodOptions.scrollInertia < 17 ? 17 : methodOptions.scrollInertia;
									to[0] = _to.call(this, to[0], "y");
									to[1] = _to.call(this, to[1], "x");
									if (methodOptions.moveDragger) {
										to[0] *= d.scrollRatio.y;
										to[1] *= d.scrollRatio.x;
									}
									methodOptions.dur = _isTabHidden() ? 0 : dur;
									setTimeout(function () {
										if (to[0] !== null && typeof to[0] !== "undefined" && o.axis !== "x" && d.overflowed[0]) {
											methodOptions.dir = "y";
											methodOptions.overwrite = "all";
											_scrollTo($this, to[0].toString(), methodOptions);
										}
										if (to[1] !== null && typeof to[1] !== "undefined" && o.axis !== "y" && d.overflowed[1]) {
											methodOptions.dir = "x";
											methodOptions.overwrite = "none";
											_scrollTo($this, to[1].toString(), methodOptions);
										}
									}, methodOptions.timeout);
								}
							});
						},
						stop: function stop() {
							var selector = _selector.call(this);
							return $(selector).each(function () {
								var $this = $(this);
								if ($this.data(pluginPfx)) {
									_stop($this);
								}
							});
						},
						disable: function disable(r) {
							var selector = _selector.call(this);
							return $(selector).each(function () {
								var $this = $(this);
								if ($this.data(pluginPfx)) {
									var d = $this.data(pluginPfx);
									_autoUpdate.call(this, "remove");
									_unbindEvents.call(this);
									if (r) {
										_resetContentPosition.call(this);
									}
									_scrollbarVisibility.call(this, true);
									$this.addClass(classes[3]);
								}
							});
						},
						destroy: function destroy() {
							var selector = _selector.call(this);
							return $(selector).each(function () {
								var $this = $(this);
								if ($this.data(pluginPfx)) {
									var d = $this.data(pluginPfx),
										o = d.opt,
										mCustomScrollBox = $("#mCSB_" + d.idx),
										mCSB_container = $("#mCSB_" + d.idx + "_container"),
										scrollbar = $(".mCSB_" + d.idx + "_scrollbar");
									if (o.live) {
										removeLiveTimers(o.liveSelector || $(selector).selector);
									}
									_autoUpdate.call(this, "remove");
									_unbindEvents.call(this);
									_resetContentPosition.call(this);
									$this.removeData(pluginPfx);
									_delete(this, "mcs");
									scrollbar.remove();
									mCSB_container.find("img." + classes[2]).removeClass(classes[2]);
									mCustomScrollBox.replaceWith(mCSB_container.contents());
									$this.removeClass(pluginNS + " _" + pluginPfx + "_" + d.idx + " " + classes[6] + " " + classes[7] + " " + classes[5] + " " + classes[3]).addClass(classes[4]);
								}
							});
						}
					},
					_selector = function _selector() {
						return _typeof($(this)) !== "object" || $(this).length < 1 ? defaultSelector : this;
					},
					_theme = function _theme(obj) {
						var fixedSizeScrollbarThemes = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
							nonExpandedScrollbarThemes = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
							disabledScrollButtonsThemes = ["minimal", "minimal-dark"],
							enabledAutoHideScrollbarThemes = ["minimal", "minimal-dark"],
							scrollbarPositionOutsideThemes = ["minimal", "minimal-dark"];
						obj.autoDraggerLength = $.inArray(obj.theme, fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
						obj.autoExpandScrollbar = $.inArray(obj.theme, nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
						obj.scrollButtons.enable = $.inArray(obj.theme, disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
						obj.autoHideScrollbar = $.inArray(obj.theme, enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
						obj.scrollbarPosition = $.inArray(obj.theme, scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
					},
					removeLiveTimers = function removeLiveTimers(selector) {
						if (liveTimers[selector]) {
							clearTimeout(liveTimers[selector]);
							_delete(liveTimers, selector);
						}
					},
					_findAxis = function _findAxis(val) {
						return val === "yx" || val === "xy" || val === "auto" ? "yx" : val === "x" || val === "horizontal" ? "x" : "y";
					},
					_findScrollButtonsType = function _findScrollButtonsType(val) {
						return val === "stepped" || val === "pixels" || val === "step" || val === "click" ? "stepped" : "stepless";
					},
					_pluginMarkup = function _pluginMarkup() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							expandClass = o.autoExpandScrollbar ? " " + classes[1] + "_expand" : "",
							scrollbar = ["<div id='mCSB_" + d.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + d.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_vertical" + expandClass + "'><div class='" + classes[12] + "'><div id='mCSB_" + d.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + d.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + d.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_horizontal" + expandClass + "'><div class='" + classes[12] + "'><div id='mCSB_" + d.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
							wrapperClass = o.axis === "yx" ? "mCSB_vertical_horizontal" : o.axis === "x" ? "mCSB_horizontal" : "mCSB_vertical",
							scrollbars = o.axis === "yx" ? scrollbar[0] + scrollbar[1] : o.axis === "x" ? scrollbar[1] : scrollbar[0],
							contentWrapper = o.axis === "yx" ? "<div id='mCSB_" + d.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
							autoHideClass = o.autoHideScrollbar ? " " + classes[6] : "",
							scrollbarDirClass = o.axis !== "x" && d.langDir === "rtl" ? " " + classes[7] : "";
						if (o.setWidth) {
							$this.css("width", o.setWidth);
						}
						if (o.setHeight) {
							$this.css("height", o.setHeight);
						}
						o.setLeft = o.axis !== "y" && d.langDir === "rtl" ? "989999px" : o.setLeft;
						$this.addClass(pluginNS + " _" + pluginPfx + "_" + d.idx + autoHideClass + scrollbarDirClass).wrapInner("<div id='mCSB_" + d.idx + "' class='mCustomScrollBox mCS-" + o.theme + " " + wrapperClass + "'><div id='mCSB_" + d.idx + "_container' class='mCSB_container' style='position:relative; top:" + o.setTop + "; left:" + o.setLeft + ";' dir='" + d.langDir + "' /></div>");
						var mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container");
						if (o.axis !== "y" && !o.advanced.autoExpandHorizontalScroll) {
							mCSB_container.css("width", _contentWidth(mCSB_container));
						}
						if (o.scrollbarPosition === "outside") {
							if ($this.css("position") === "static") {
								$this.css("position", "relative");
							}
							$this.css("overflow", "visible");
							mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
						} else {
							mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
							mCSB_container.wrap(contentWrapper);
						}
						_scrollButtons.call(this);
						var mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
						mCSB_dragger[0].css("min-height", mCSB_dragger[0].height());
						mCSB_dragger[1].css("min-width", mCSB_dragger[1].width());
					},
					_contentWidth = function _contentWidth(el) {
						var val = [el[0].scrollWidth, Math.max.apply(Math, el.children().map(function () {
							return $(this).outerWidth(true);
						}).get())],
							w = el.parent().width();
						return val[0] > w ? val[0] : val[1] > w ? val[1] : "100%";
					},
					_expandContentHorizontally = function _expandContentHorizontally() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							mCSB_container = $("#mCSB_" + d.idx + "_container");
						if (o.advanced.autoExpandHorizontalScroll && o.axis !== "y") {
							mCSB_container.css({
								"width": "auto",
								"min-width": 0,
								"overflow-x": "scroll"
							});
							var w = Math.ceil(mCSB_container[0].scrollWidth);
							if (o.advanced.autoExpandHorizontalScroll === 3 || o.advanced.autoExpandHorizontalScroll !== 2 && w > mCSB_container.parent().width()) {
								mCSB_container.css({
									"width": w,
									"min-width": "100%",
									"overflow-x": "inherit"
								});
							} else {
								mCSB_container.css({
									"overflow-x": "inherit",
									"position": "absolute"
								}).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
									"width": Math.ceil(mCSB_container[0].getBoundingClientRect().right + 0.4) - Math.floor(mCSB_container[0].getBoundingClientRect().left),
									"min-width": "100%",
									"position": "relative"
								}).unwrap();
							}
						}
					},
					_scrollButtons = function _scrollButtons() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							mCSB_scrollTools = $(".mCSB_" + d.idx + "_scrollbar:first"),
							tabindex = !_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='" + o.scrollButtons.tabindex + "'",
							btnHTML = ["<a href='#' class='" + classes[13] + "' " + tabindex + " />", "<a href='#' class='" + classes[14] + "' " + tabindex + " />", "<a href='#' class='" + classes[15] + "' " + tabindex + " />", "<a href='#' class='" + classes[16] + "' " + tabindex + " />"],
							btn = [o.axis === "x" ? btnHTML[2] : btnHTML[0], o.axis === "x" ? btnHTML[3] : btnHTML[1], btnHTML[2], btnHTML[3]];
						if (o.scrollButtons.enable) {
							mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
						}
					},
					_setDraggerLength = function _setDraggerLength() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
							ratio = [mCustomScrollBox.height() / mCSB_container.outerHeight(false), mCustomScrollBox.width() / mCSB_container.outerWidth(false)],
							l = [parseInt(mCSB_dragger[0].css("min-height")), Math.round(ratio[0] * mCSB_dragger[0].parent().height()), parseInt(mCSB_dragger[1].css("min-width")), Math.round(ratio[1] * mCSB_dragger[1].parent().width())],
							h = oldIE && l[1] < l[0] ? l[0] : l[1],
							w = oldIE && l[3] < l[2] ? l[2] : l[3];
						mCSB_dragger[0].css({
							"height": h,
							"max-height": mCSB_dragger[0].parent().height() - 10
						}).find(".mCSB_dragger_bar").css({
							"line-height": l[0] + "px"
						});
						mCSB_dragger[1].css({
							"width": w,
							"max-width": mCSB_dragger[1].parent().width() - 10
						});
					},
					_scrollRatio = function _scrollRatio() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
							scrollAmount = [mCSB_container.outerHeight(false) - mCustomScrollBox.height(), mCSB_container.outerWidth(false) - mCustomScrollBox.width()],
							ratio = [scrollAmount[0] / (mCSB_dragger[0].parent().height() - mCSB_dragger[0].height()), scrollAmount[1] / (mCSB_dragger[1].parent().width() - mCSB_dragger[1].width())];
						d.scrollRatio = {
							y: ratio[0],
							x: ratio[1]
						};
					},
					_onDragClasses = function _onDragClasses(el, action, xpnd) {
						var expandClass = xpnd ? classes[0] + "_expanded" : "",
							scrollbar = el.closest(".mCSB_scrollTools");
						if (action === "active") {
							el.toggleClass(classes[0] + " " + expandClass);
							scrollbar.toggleClass(classes[1]);
							el[0]._draggable = el[0]._draggable ? 0 : 1;
						} else {
							if (!el[0]._draggable) {
								if (action === "hide") {
									el.removeClass(classes[0]);
									scrollbar.removeClass(classes[1]);
								} else {
									el.addClass(classes[0]);
									scrollbar.addClass(classes[1]);
								}
							}
						}
					},
					_overflowed = function _overflowed() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							contentHeight = d.overflowed == null ? mCSB_container.height() : mCSB_container.outerHeight(false),
							contentWidth = d.overflowed == null ? mCSB_container.width() : mCSB_container.outerWidth(false),
							h = mCSB_container[0].scrollHeight,
							w = mCSB_container[0].scrollWidth;
						if (h > contentHeight) {
							contentHeight = h;
						}
						if (w > contentWidth) {
							contentWidth = w;
						}
						return [contentHeight > mCustomScrollBox.height(), contentWidth > mCustomScrollBox.width()];
					},
					_resetContentPosition = function _resetContentPosition() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
						_stop($this);
						if (o.axis !== "x" && !d.overflowed[0] || o.axis === "y" && d.overflowed[0]) {
							mCSB_dragger[0].add(mCSB_container).css("top", 0);
							_scrollTo($this, "_resetY");
						}
						if (o.axis !== "y" && !d.overflowed[1] || o.axis === "x" && d.overflowed[1]) {
							var cx = dx = 0;
							if (d.langDir === "rtl") {
								cx = mCustomScrollBox.width() - mCSB_container.outerWidth(false);
								dx = Math.abs(cx / d.scrollRatio.x);
							}
							mCSB_container.css("left", cx);
							mCSB_dragger[1].css("left", dx);
							_scrollTo($this, "_resetX");
						}
					},
					_bindEvents = function _bindEvents() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt;
						if (!d.bindEvents) {
							_draggable.call(this);
							if (o.contentTouchScroll) {
								_contentDraggable.call(this);
							}
							_selectable.call(this);
							if (o.mouseWheel.enable) {
								var _mwt = function _mwt() {
									mousewheelTimeout = setTimeout(function () {
										if (!$.event.special.mousewheel) {
											_mwt();
										} else {
											clearTimeout(mousewheelTimeout);
											_mousewheel.call($this[0]);
										}
									}, 100);
								};
								var mousewheelTimeout;
								_mwt();
							}
							_draggerRail.call(this);
							_wrapperScroll.call(this);
							if (o.advanced.autoScrollOnFocus) {
								_focus.call(this);
							}
							if (o.scrollButtons.enable) {
								_buttons.call(this);
							}
							if (o.keyboard.enable) {
								_keyboard.call(this);
							}
							d.bindEvents = true;
						}
					},
					_unbindEvents = function _unbindEvents() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							namespace = pluginPfx + "_" + d.idx,
							sb = ".mCSB_" + d.idx + "_scrollbar",
							sel = $("#mCSB_" + d.idx + ",#mCSB_" + d.idx + "_container,#mCSB_" + d.idx + "_container_wrapper," + sb + " ." + classes[12] + ",#mCSB_" + d.idx + "_dragger_vertical,#mCSB_" + d.idx + "_dragger_horizontal," + sb + ">a"),
							mCSB_container = $("#mCSB_" + d.idx + "_container");
						if (o.advanced.releaseDraggableSelectors) {
							sel.add($(o.advanced.releaseDraggableSelectors));
						}
						if (o.advanced.extraDraggableSelectors) {
							sel.add($(o.advanced.extraDraggableSelectors));
						}
						if (d.bindEvents) {
							$(document).add($(!_canAccessIFrame() || top.document)).unbind("." + namespace);
							sel.each(function () {
								$(this).unbind("." + namespace);
							});
							clearTimeout($this[0]._focusTimeout);
							_delete($this[0], "_focusTimeout");
							clearTimeout(d.sequential.step);
							_delete(d.sequential, "step");
							clearTimeout(mCSB_container[0].onCompleteTimeout);
							_delete(mCSB_container[0], "onCompleteTimeout");
							d.bindEvents = false;
						}
					},
					_scrollbarVisibility = function _scrollbarVisibility(disabled) {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							contentWrapper = $("#mCSB_" + d.idx + "_container_wrapper"),
							content = contentWrapper.length ? contentWrapper : $("#mCSB_" + d.idx + "_container"),
							scrollbar = [$("#mCSB_" + d.idx + "_scrollbar_vertical"), $("#mCSB_" + d.idx + "_scrollbar_horizontal")],
							mCSB_dragger = [scrollbar[0].find(".mCSB_dragger"), scrollbar[1].find(".mCSB_dragger")];
						if (o.axis !== "x") {
							if (d.overflowed[0] && !disabled) {
								scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display", "block");
								content.removeClass(classes[8] + " " + classes[10]);
							} else {
								if (o.alwaysShowScrollbar) {
									if (o.alwaysShowScrollbar !== 2) {
										mCSB_dragger[0].css("display", "none");
									}
									content.removeClass(classes[10]);
								} else {
									scrollbar[0].css("display", "none");
									content.addClass(classes[10]);
								}
								content.addClass(classes[8]);
							}
						}
						if (o.axis !== "y") {
							if (d.overflowed[1] && !disabled) {
								scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display", "block");
								content.removeClass(classes[9] + " " + classes[11]);
							} else {
								if (o.alwaysShowScrollbar) {
									if (o.alwaysShowScrollbar !== 2) {
										mCSB_dragger[1].css("display", "none");
									}
									content.removeClass(classes[11]);
								} else {
									scrollbar[1].css("display", "none");
									content.addClass(classes[11]);
								}
								content.addClass(classes[9]);
							}
						}
						if (!d.overflowed[0] && !d.overflowed[1]) {
							$this.addClass(classes[5]);
						} else {
							$this.removeClass(classes[5]);
						}
					},
					_coordinates = function _coordinates(e) {
						var t = e.type,
							o = e.target.ownerDocument !== document && frameElement !== null ? [$(frameElement).offset().top, $(frameElement).offset().left] : null,
							io = _canAccessIFrame() && e.target.ownerDocument !== top.document && frameElement !== null ? [$(e.view.frameElement).offset().top, $(e.view.frameElement).offset().left] : [0, 0];
						switch (t) {
							case "pointerdown":
							case "MSPointerDown":
							case "pointermove":
							case "MSPointerMove":
							case "pointerup":
							case "MSPointerUp":
								return o ? [e.originalEvent.pageY - o[0] + io[0], e.originalEvent.pageX - o[1] + io[1], false] : [e.originalEvent.pageY, e.originalEvent.pageX, false];
								break;
							case "touchstart":
							case "touchmove":
							case "touchend":
								var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
									touches = e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
								return e.target.ownerDocument !== document ? [touch.screenY, touch.screenX, touches > 1] : [touch.pageY, touch.pageX, touches > 1];
								break;
							default:
								return o ? [e.pageY - o[0] + io[0], e.pageX - o[1] + io[1], false] : [e.pageY, e.pageX, false];
						}
					},
					_draggable = function _draggable() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							namespace = pluginPfx + "_" + d.idx,
							draggerId = ["mCSB_" + d.idx + "_dragger_vertical", "mCSB_" + d.idx + "_dragger_horizontal"],
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							mCSB_dragger = $("#" + draggerId[0] + ",#" + draggerId[1]),
							draggable, dragY, dragX, rds = o.advanced.releaseDraggableSelectors ? mCSB_dragger.add($(o.advanced.releaseDraggableSelectors)) : mCSB_dragger,
							eds = o.advanced.extraDraggableSelectors ? $(!_canAccessIFrame() || top.document).add($(o.advanced.extraDraggableSelectors)) : $(!_canAccessIFrame() || top.document);
						mCSB_dragger.bind("contextmenu." + namespace, function (e) {
							e.preventDefault();
						}).bind("mousedown." + namespace + " touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function (e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							if (!_mouseBtnLeft(e)) {
								return;
							}
							touchActive = true;
							if (oldIE) {
								document.onselectstart = function () {
									return false;
								};
							}
							_iframe.call(mCSB_container, false);
							_stop($this);
							draggable = $(this);
							var offset = draggable.offset(),
								y = _coordinates(e)[0] - offset.top,
								x = _coordinates(e)[1] - offset.left,
								h = draggable.height() + offset.top,
								w = draggable.width() + offset.left;
							if (y < h && y > 0 && x < w && x > 0) {
								dragY = y;
								dragX = x;
							}
							_onDragClasses(draggable, "active", o.autoExpandScrollbar);
						}).bind("touchmove." + namespace, function (e) {
							e.stopImmediatePropagation();
							e.preventDefault();
							var offset = draggable.offset(),
								y = _coordinates(e)[0] - offset.top,
								x = _coordinates(e)[1] - offset.left;
							_drag(dragY, dragX, y, x);
						});
						$(document).add(eds).bind("mousemove." + namespace + " pointermove." + namespace + " MSPointerMove." + namespace, function (e) {
							if (draggable) {
								var offset = draggable.offset(),
									y = _coordinates(e)[0] - offset.top,
									x = _coordinates(e)[1] - offset.left;
								if (dragY === y && dragX === x) {
									return;
								}
								_drag(dragY, dragX, y, x);
							}
						}).add(rds).bind("mouseup." + namespace + " touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace, function (e) {
							if (draggable) {
								_onDragClasses(draggable, "active", o.autoExpandScrollbar);
								draggable = null;
							}
							touchActive = false;
							if (oldIE) {
								document.onselectstart = null;
							}
							_iframe.call(mCSB_container, true);
						});

						function _drag(dragY, dragX, y, x) {
							mCSB_container[0].idleTimer = o.scrollInertia < 233 ? 250 : 0;
							if (draggable.attr("id") === draggerId[1]) {
								var dir = "x",
									to = (draggable[0].offsetLeft - dragX + x) * d.scrollRatio.x;
							} else {
								var dir = "y",
									to = (draggable[0].offsetTop - dragY + y) * d.scrollRatio.y;
							}
							_scrollTo($this, to.toString(), {
								dir: dir,
								drag: true
							});
						}
					},
					_contentDraggable = function _contentDraggable() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							namespace = pluginPfx + "_" + d.idx,
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
							draggable, dragY, dragX, touchStartY, touchStartX, touchMoveY = [],
							touchMoveX = [],
							startTime, runningTime, endTime, distance, speed, amount, durA = 0,
							durB, overwrite = o.axis === "yx" ? "none" : "all",
							touchIntent = [],
							touchDrag, docDrag, iframe = mCSB_container.find("iframe"),
							events = ["touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, "touchmove." + namespace + " pointermove." + namespace + " MSPointerMove." + namespace, "touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace],
							touchAction = document.body.style.touchAction !== undefined && document.body.style.touchAction !== "";
						mCSB_container.bind(events[0], function (e) {
							_onTouchstart(e);
						}).bind(events[1], function (e) {
							_onTouchmove(e);
						});
						mCustomScrollBox.bind(events[0], function (e) {
							_onTouchstart2(e);
						}).bind(events[2], function (e) {
							_onTouchend(e);
						});
						if (iframe.length) {
							iframe.each(function () {
								$(this).bind("load", function () {
									if (_canAccessIFrame(this)) {
										$(this.contentDocument || this.contentWindow.document).bind(events[0], function (e) {
											_onTouchstart(e);
											_onTouchstart2(e);
										}).bind(events[1], function (e) {
											_onTouchmove(e);
										}).bind(events[2], function (e) {
											_onTouchend(e);
										});
									}
								});
							});
						}

						function _onTouchstart(e) {
							if (!_pointerTouch(e) || touchActive || _coordinates(e)[2]) {
								touchable = 0;
								return;
							}
							touchable = 1;
							touchDrag = 0;
							docDrag = 0;
							draggable = 1;
							$this.removeClass("mCS_touch_action");
							var offset = mCSB_container.offset();
							dragY = _coordinates(e)[0] - offset.top;
							dragX = _coordinates(e)[1] - offset.left;
							touchIntent = [_coordinates(e)[0], _coordinates(e)[1]];
						}

						function _onTouchmove(e) {
							if (!_pointerTouch(e) || touchActive || _coordinates(e)[2]) {
								return;
							}
							if (!o.documentTouchScroll) {
								e.preventDefault();
							}
							e.stopImmediatePropagation();
							if (docDrag && !touchDrag) {
								return;
							}
							if (draggable) {
								runningTime = _getTime();
								var offset = mCustomScrollBox.offset(),
									y = _coordinates(e)[0] - offset.top,
									x = _coordinates(e)[1] - offset.left,
									easing = "mcsLinearOut";
								touchMoveY.push(y);
								touchMoveX.push(x);
								touchIntent[2] = Math.abs(_coordinates(e)[0] - touchIntent[0]);
								touchIntent[3] = Math.abs(_coordinates(e)[1] - touchIntent[1]);
								if (d.overflowed[0]) {
									var limit = mCSB_dragger[0].parent().height() - mCSB_dragger[0].height(),
										prevent = dragY - y > 0 && y - dragY > -(limit * d.scrollRatio.y) && (touchIntent[3] * 2 < touchIntent[2] || o.axis === "yx");
								}
								if (d.overflowed[1]) {
									var limitX = mCSB_dragger[1].parent().width() - mCSB_dragger[1].width(),
										preventX = dragX - x > 0 && x - dragX > -(limitX * d.scrollRatio.x) && (touchIntent[2] * 2 < touchIntent[3] || o.axis === "yx");
								}
								if (prevent || preventX) {
									if (!touchAction) {
										e.preventDefault();
									}
									touchDrag = 1;
								} else {
									docDrag = 1;
									$this.addClass("mCS_touch_action");
								}
								if (touchAction) {
									e.preventDefault();
								}
								amount = o.axis === "yx" ? [dragY - y, dragX - x] : o.axis === "x" ? [null, dragX - x] : [dragY - y, null];
								mCSB_container[0].idleTimer = 250;
								if (d.overflowed[0]) {
									_drag(amount[0], durA, easing, "y", "all", true);
								}
								if (d.overflowed[1]) {
									_drag(amount[1], durA, easing, "x", overwrite, true);
								}
							}
						}

						function _onTouchstart2(e) {
							if (!_pointerTouch(e) || touchActive || _coordinates(e)[2]) {
								touchable = 0;
								return;
							}
							touchable = 1;
							e.stopImmediatePropagation();
							_stop($this);
							startTime = _getTime();
							var offset = mCustomScrollBox.offset();
							touchStartY = _coordinates(e)[0] - offset.top;
							touchStartX = _coordinates(e)[1] - offset.left;
							touchMoveY = [];
							touchMoveX = [];
						}

						function _onTouchend(e) {
							if (!_pointerTouch(e) || touchActive || _coordinates(e)[2]) {
								return;
							}
							draggable = 0;
							e.stopImmediatePropagation();
							touchDrag = 0;
							docDrag = 0;
							endTime = _getTime();
							var offset = mCustomScrollBox.offset(),
								y = _coordinates(e)[0] - offset.top,
								x = _coordinates(e)[1] - offset.left;
							if (endTime - runningTime > 30) {
								return;
							}
							speed = 1000 / (endTime - startTime);
							var easing = "mcsEaseOut",
								slow = speed < 2.5,
								diff = slow ? [touchMoveY[touchMoveY.length - 2], touchMoveX[touchMoveX.length - 2]] : [0, 0];
							distance = slow ? [y - diff[0], x - diff[1]] : [y - touchStartY, x - touchStartX];
							var absDistance = [Math.abs(distance[0]), Math.abs(distance[1])];
							speed = slow ? [Math.abs(distance[0] / 4), Math.abs(distance[1] / 4)] : [speed, speed];
							var a = [Math.abs(mCSB_container[0].offsetTop) - distance[0] * _m(absDistance[0] / speed[0], speed[0]), Math.abs(mCSB_container[0].offsetLeft) - distance[1] * _m(absDistance[1] / speed[1], speed[1])];
							amount = o.axis === "yx" ? [a[0], a[1]] : o.axis === "x" ? [null, a[1]] : [a[0], null];
							durB = [absDistance[0] * 4 + o.scrollInertia, absDistance[1] * 4 + o.scrollInertia];
							var md = parseInt(o.contentTouchScroll) || 0;
							amount[0] = absDistance[0] > md ? amount[0] : 0;
							amount[1] = absDistance[1] > md ? amount[1] : 0;
							if (d.overflowed[0]) {
								_drag(amount[0], durB[0], easing, "y", overwrite, false);
							}
							if (d.overflowed[1]) {
								_drag(amount[1], durB[1], easing, "x", overwrite, false);
							}
						}

						function _m(ds, s) {
							var r = [s * 1.5, s * 2, s / 1.5, s / 2];
							if (ds > 90) {
								return s > 4 ? r[0] : r[3];
							} else if (ds > 60) {
								return s > 3 ? r[3] : r[2];
							} else if (ds > 30) {
								return s > 8 ? r[1] : s > 6 ? r[0] : s > 4 ? s : r[2];
							} else {
								return s > 8 ? s : r[3];
							}
						}

						function _drag(amount, dur, easing, dir, overwrite, drag) {
							if (!amount) {
								return;
							}
							_scrollTo($this, amount.toString(), {
								dur: dur,
								scrollEasing: easing,
								dir: dir,
								overwrite: overwrite,
								drag: drag
							});
						}
					},
					_selectable = function _selectable() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							seq = d.sequential,
							namespace = pluginPfx + "_" + d.idx,
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent(),
							action;
						mCSB_container.bind("mousedown." + namespace, function (e) {
							if (touchable) {
								return;
							}
							if (!action) {
								action = 1;
								touchActive = true;
							}
						}).add(document).bind("mousemove." + namespace, function (e) {
							if (!touchable && action && _sel()) {
								var offset = mCSB_container.offset(),
									y = _coordinates(e)[0] - offset.top + mCSB_container[0].offsetTop,
									x = _coordinates(e)[1] - offset.left + mCSB_container[0].offsetLeft;
								if (y > 0 && y < wrapper.height() && x > 0 && x < wrapper.width()) {
									if (seq.step) {
										_seq("off", null, "stepped");
									}
								} else {
									if (o.axis !== "x" && d.overflowed[0]) {
										if (y < 0) {
											_seq("on", 38);
										} else if (y > wrapper.height()) {
											_seq("on", 40);
										}
									}
									if (o.axis !== "y" && d.overflowed[1]) {
										if (x < 0) {
											_seq("on", 37);
										} else if (x > wrapper.width()) {
											_seq("on", 39);
										}
									}
								}
							}
						}).bind("mouseup." + namespace + " dragend." + namespace, function (e) {
							if (touchable) {
								return;
							}
							if (action) {
								action = 0;
								_seq("off", null);
							}
							touchActive = false;
						});

						function _sel() {
							return window.getSelection ? window.getSelection().toString() : document.selection && document.selection.type != "Control" ? document.selection.createRange().text : 0;
						}

						function _seq(a, c, s) {
							seq.type = s && action ? "stepped" : "stepless";
							seq.scrollAmount = 10;
							_sequentialScroll($this, a, c, "mcsLinearOut", s ? 60 : null);
						}
					},
					_mousewheel = function _mousewheel() {
						if (!$(this).data(pluginPfx)) {
							return;
						}
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							namespace = pluginPfx + "_" + d.idx,
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
							iframe = $("#mCSB_" + d.idx + "_container").find("iframe");
						if (iframe.length) {
							iframe.each(function () {
								$(this).bind("load", function () {
									if (_canAccessIFrame(this)) {
										$(this.contentDocument || this.contentWindow.document).bind("mousewheel." + namespace, function (e, delta) {
											_onMousewheel(e, delta);
										});
									}
								});
							});
						}
						mCustomScrollBox.bind("mousewheel." + namespace, function (e, delta) {
							_onMousewheel(e, delta);
						});

						function _onMousewheel(e, delta) {
							_stop($this);
							if (_disableMousewheel($this, e.target)) {
								return;
							}
							var deltaFactor = o.mouseWheel.deltaFactor !== "auto" ? parseInt(o.mouseWheel.deltaFactor) : oldIE && e.deltaFactor < 100 ? 100 : e.deltaFactor || 100,
								dur = o.scrollInertia;
							if (o.axis === "x" || o.mouseWheel.axis === "x") {
								var dir = "x",
									px = [Math.round(deltaFactor * d.scrollRatio.x), parseInt(o.mouseWheel.scrollAmount)],
									amount = o.mouseWheel.scrollAmount !== "auto" ? px[1] : px[0] >= mCustomScrollBox.width() ? mCustomScrollBox.width() * 0.9 : px[0],
									contentPos = Math.abs($("#mCSB_" + d.idx + "_container")[0].offsetLeft),
									draggerPos = mCSB_dragger[1][0].offsetLeft,
									limit = mCSB_dragger[1].parent().width() - mCSB_dragger[1].width(),
									dlt = o.mouseWheel.axis === "y" ? e.deltaY || delta : e.deltaX;
							} else {
								var dir = "y",
									px = [Math.round(deltaFactor * d.scrollRatio.y), parseInt(o.mouseWheel.scrollAmount)],
									amount = o.mouseWheel.scrollAmount !== "auto" ? px[1] : px[0] >= mCustomScrollBox.height() ? mCustomScrollBox.height() * 0.9 : px[0],
									contentPos = Math.abs($("#mCSB_" + d.idx + "_container")[0].offsetTop),
									draggerPos = mCSB_dragger[0][0].offsetTop,
									limit = mCSB_dragger[0].parent().height() - mCSB_dragger[0].height(),
									dlt = e.deltaY || delta;
							}
							if (dir === "y" && !d.overflowed[0] || dir === "x" && !d.overflowed[1]) {
								return;
							}
							if (o.mouseWheel.invert || e.webkitDirectionInvertedFromDevice) {
								dlt = -dlt;
							}
							if (o.mouseWheel.normalizeDelta) {
								dlt = dlt < 0 ? -1 : 1;
							}
							if (dlt > 0 && draggerPos !== 0 || dlt < 0 && draggerPos !== limit || o.mouseWheel.preventDefault) {
								e.stopImmediatePropagation();
								e.preventDefault();
							}
							if (e.deltaFactor < 5 && !o.mouseWheel.normalizeDelta) {
								amount = e.deltaFactor;
								dur = 17;
							}
							_scrollTo($this, (contentPos - dlt * amount).toString(), {
								dir: dir,
								dur: dur
							});
						}
					},
					_canAccessIFrameCache = new Object(),
					_canAccessIFrame = function _canAccessIFrame(iframe) {
						var result = false,
							cacheKey = false,
							html = null;
						if (iframe === undefined) {
							cacheKey = "#empty";
						} else if ($(iframe).attr("id") !== undefined) {
							cacheKey = $(iframe).attr("id");
						}
						if (cacheKey !== false && _canAccessIFrameCache[cacheKey] !== undefined) {
							return _canAccessIFrameCache[cacheKey];
						}
						if (!iframe) {
							try {
								var doc = top.document;
								html = doc.body.innerHTML;
							} catch (err) { }
							result = html !== null;
						} else {
							try {
								var doc = iframe.contentDocument || iframe.contentWindow.document;
								html = doc.body.innerHTML;
							} catch (err) { }
							result = html !== null;
						}
						if (cacheKey !== false) {
							_canAccessIFrameCache[cacheKey] = result;
						}
						return result;
					},
					_iframe = function _iframe(evt) {
						var el = this.find("iframe");
						if (!el.length) {
							return;
						}
						var val = !evt ? "none" : "auto";
						el.css("pointer-events", val);
					},
					_disableMousewheel = function _disableMousewheel(el, target) {
						var tag = target.nodeName.toLowerCase(),
							tags = el.data(pluginPfx).opt.mouseWheel.disableOver,
							focusTags = ["select", "textarea"];
						return $.inArray(tag, tags) > -1 && !($.inArray(tag, focusTags) > -1 && !$(target).is(":focus"));
					},
					_draggerRail = function _draggerRail() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							namespace = pluginPfx + "_" + d.idx,
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent(),
							mCSB_draggerContainer = $(".mCSB_" + d.idx + "_scrollbar ." + classes[12]),
							clickable;
						mCSB_draggerContainer.bind("mousedown." + namespace + " touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function (e) {
							touchActive = true;
							if (!$(e.target).hasClass("mCSB_dragger")) {
								clickable = 1;
							}
						}).bind("touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace, function (e) {
							touchActive = false;
						}).bind("click." + namespace, function (e) {
							if (!clickable) {
								return;
							}
							clickable = 0;
							if ($(e.target).hasClass(classes[12]) || $(e.target).hasClass("mCSB_draggerRail")) {
								_stop($this);
								var el = $(this),
									mCSB_dragger = el.find(".mCSB_dragger");
								if (el.parent(".mCSB_scrollTools_horizontal").length > 0) {
									if (!d.overflowed[1]) {
										return;
									}
									var dir = "x",
										clickDir = e.pageX > mCSB_dragger.offset().left ? -1 : 1,
										to = Math.abs(mCSB_container[0].offsetLeft) - clickDir * (wrapper.width() * 0.9);
								} else {
									if (!d.overflowed[0]) {
										return;
									}
									var dir = "y",
										clickDir = e.pageY > mCSB_dragger.offset().top ? -1 : 1,
										to = Math.abs(mCSB_container[0].offsetTop) - clickDir * (wrapper.height() * 0.9);
								}
								_scrollTo($this, to.toString(), {
									dir: dir,
									scrollEasing: "mcsEaseInOut"
								});
							}
						});
					},
					_focus = function _focus() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							namespace = pluginPfx + "_" + d.idx,
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent();
						mCSB_container.bind("focusin." + namespace, function (e) {
							var el = $(document.activeElement),
								nested = mCSB_container.find(".mCustomScrollBox").length,
								dur = 0;
							if (!el.is(o.advanced.autoScrollOnFocus)) {
								return;
							}
							_stop($this);
							clearTimeout($this[0]._focusTimeout);
							$this[0]._focusTimer = nested ? (dur + 17) * nested : 0;
							$this[0]._focusTimeout = setTimeout(function () {
								var to = [_childPos(el)[0], _childPos(el)[1]],
									contentPos = [mCSB_container[0].offsetTop, mCSB_container[0].offsetLeft],
									isVisible = [contentPos[0] + to[0] >= 0 && contentPos[0] + to[0] < wrapper.height() - el.outerHeight(false), contentPos[1] + to[1] >= 0 && contentPos[0] + to[1] < wrapper.width() - el.outerWidth(false)],
									overwrite = o.axis === "yx" && !isVisible[0] && !isVisible[1] ? "none" : "all";
								if (o.axis !== "x" && !isVisible[0]) {
									_scrollTo($this, to[0].toString(), {
										dir: "y",
										scrollEasing: "mcsEaseInOut",
										overwrite: overwrite,
										dur: dur
									});
								}
								if (o.axis !== "y" && !isVisible[1]) {
									_scrollTo($this, to[1].toString(), {
										dir: "x",
										scrollEasing: "mcsEaseInOut",
										overwrite: overwrite,
										dur: dur
									});
								}
							}, $this[0]._focusTimer);
						});
					},
					_wrapperScroll = function _wrapperScroll() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							namespace = pluginPfx + "_" + d.idx,
							wrapper = $("#mCSB_" + d.idx + "_container").parent();
						wrapper.bind("scroll." + namespace, function (e) {
							if (wrapper.scrollTop() !== 0 || wrapper.scrollLeft() !== 0) {
								$(".mCSB_" + d.idx + "_scrollbar").css("visibility", "hidden");
							}
						});
					},
					_buttons = function _buttons() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							seq = d.sequential,
							namespace = pluginPfx + "_" + d.idx,
							sel = ".mCSB_" + d.idx + "_scrollbar",
							btn = $(sel + ">a");
						btn.bind("contextmenu." + namespace, function (e) {
							e.preventDefault();
						}).bind("mousedown." + namespace + " touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace + " mouseup." + namespace + " touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace + " mouseout." + namespace + " pointerout." + namespace + " MSPointerOut." + namespace + " click." + namespace, function (e) {
							e.preventDefault();
							if (!_mouseBtnLeft(e)) {
								return;
							}
							var btnClass = $(this).attr("class");
							seq.type = o.scrollButtons.scrollType;
							switch (e.type) {
								case "mousedown":
								case "touchstart":
								case "pointerdown":
								case "MSPointerDown":
									if (seq.type === "stepped") {
										return;
									}
									touchActive = true;
									d.tweenRunning = false;
									_seq("on", btnClass);
									break;
								case "mouseup":
								case "touchend":
								case "pointerup":
								case "MSPointerUp":
								case "mouseout":
								case "pointerout":
								case "MSPointerOut":
									if (seq.type === "stepped") {
										return;
									}
									touchActive = false;
									if (seq.dir) {
										_seq("off", btnClass);
									}
									break;
								case "click":
									if (seq.type !== "stepped" || d.tweenRunning) {
										return;
									}
									_seq("on", btnClass);
									break;
							}

							function _seq(a, c) {
								seq.scrollAmount = o.scrollButtons.scrollAmount;
								_sequentialScroll($this, a, c);
							}
						});
					},
					_keyboard = function _keyboard() {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							seq = d.sequential,
							namespace = pluginPfx + "_" + d.idx,
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent(),
							editables = "input,textarea,select,datalist,keygen,[contenteditable='true']",
							iframe = mCSB_container.find("iframe"),
							events = ["blur." + namespace + " keydown." + namespace + " keyup." + namespace];
						if (iframe.length) {
							iframe.each(function () {
								$(this).bind("load", function () {
									if (_canAccessIFrame(this)) {
										$(this.contentDocument || this.contentWindow.document).bind(events[0], function (e) {
											_onKeyboard(e);
										});
									}
								});
							});
						}
						mCustomScrollBox.attr("tabindex", "0").bind(events[0], function (e) {
							_onKeyboard(e);
						});

						function _onKeyboard(e) {
							switch (e.type) {
								case "blur":
									if (d.tweenRunning && seq.dir) {
										_seq("off", null);
									}
									break;
								case "keydown":
								case "keyup":
									var code = e.keyCode ? e.keyCode : e.which,
										action = "on";
									if (o.axis !== "x" && (code === 38 || code === 40) || o.axis !== "y" && (code === 37 || code === 39)) {
										if ((code === 38 || code === 40) && !d.overflowed[0] || (code === 37 || code === 39) && !d.overflowed[1]) {
											return;
										}
										if (e.type === "keyup") {
											action = "off";
										}
										if (!$(document.activeElement).is(editables)) {
											e.preventDefault();
											e.stopImmediatePropagation();
											_seq(action, code);
										}
									} else if (code === 33 || code === 34) {
										if (d.overflowed[0] || d.overflowed[1]) {
											e.preventDefault();
											e.stopImmediatePropagation();
										}
										if (e.type === "keyup") {
											_stop($this);
											var keyboardDir = code === 34 ? -1 : 1;
											if (o.axis === "x" || o.axis === "yx" && d.overflowed[1] && !d.overflowed[0]) {
												var dir = "x",
													to = Math.abs(mCSB_container[0].offsetLeft) - keyboardDir * (wrapper.width() * 0.9);
											} else {
												var dir = "y",
													to = Math.abs(mCSB_container[0].offsetTop) - keyboardDir * (wrapper.height() * 0.9);
											}
											_scrollTo($this, to.toString(), {
												dir: dir,
												scrollEasing: "mcsEaseInOut"
											});
										}
									} else if (code === 35 || code === 36) {
										if (!$(document.activeElement).is(editables)) {
											if (d.overflowed[0] || d.overflowed[1]) {
												e.preventDefault();
												e.stopImmediatePropagation();
											}
											if (e.type === "keyup") {
												if (o.axis === "x" || o.axis === "yx" && d.overflowed[1] && !d.overflowed[0]) {
													var dir = "x",
														to = code === 35 ? Math.abs(wrapper.width() - mCSB_container.outerWidth(false)) : 0;
												} else {
													var dir = "y",
														to = code === 35 ? Math.abs(wrapper.height() - mCSB_container.outerHeight(false)) : 0;
												}
												_scrollTo($this, to.toString(), {
													dir: dir,
													scrollEasing: "mcsEaseInOut"
												});
											}
										}
									}
									break;
							}

							function _seq(a, c) {
								seq.type = o.keyboard.scrollType;
								seq.scrollAmount = o.keyboard.scrollAmount;
								if (seq.type === "stepped" && d.tweenRunning) {
									return;
								}
								_sequentialScroll($this, a, c);
							}
						}
					},
					_sequentialScroll = function _sequentialScroll(el, action, trigger, e, s) {
						var d = el.data(pluginPfx),
							o = d.opt,
							seq = d.sequential,
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							once = seq.type === "stepped" ? true : false,
							steplessSpeed = o.scrollInertia < 26 ? 26 : o.scrollInertia,
							steppedSpeed = o.scrollInertia < 1 ? 17 : o.scrollInertia;
						switch (action) {
							case "on":
								seq.dir = [trigger === classes[16] || trigger === classes[15] || trigger === 39 || trigger === 37 ? "x" : "y", trigger === classes[13] || trigger === classes[15] || trigger === 38 || trigger === 37 ? -1 : 1];
								_stop(el);
								if (_isNumeric(trigger) && seq.type === "stepped") {
									return;
								}
								_on(once);
								break;
							case "off":
								_off();
								if (once || d.tweenRunning && seq.dir) {
									_on(true);
								}
								break;
						}

						function _on(once) {
							if (o.snapAmount) {
								seq.scrollAmount = !(o.snapAmount instanceof Array) ? o.snapAmount : seq.dir[0] === "x" ? o.snapAmount[1] : o.snapAmount[0];
							}
							var c = seq.type !== "stepped",
								t = s ? s : !once ? 1000 / 60 : c ? steplessSpeed / 1.5 : steppedSpeed,
								m = !once ? 2.5 : c ? 7.5 : 40,
								contentPos = [Math.abs(mCSB_container[0].offsetTop), Math.abs(mCSB_container[0].offsetLeft)],
								ratio = [d.scrollRatio.y > 10 ? 10 : d.scrollRatio.y, d.scrollRatio.x > 10 ? 10 : d.scrollRatio.x],
								amount = seq.dir[0] === "x" ? contentPos[1] + seq.dir[1] * (ratio[1] * m) : contentPos[0] + seq.dir[1] * (ratio[0] * m),
								px = seq.dir[0] === "x" ? contentPos[1] + seq.dir[1] * parseInt(seq.scrollAmount) : contentPos[0] + seq.dir[1] * parseInt(seq.scrollAmount),
								to = seq.scrollAmount !== "auto" ? px : amount,
								easing = e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
								onComplete = !once ? false : true;
							if (once && t < 17) {
								to = seq.dir[0] === "x" ? contentPos[1] : contentPos[0];
							}
							_scrollTo(el, to.toString(), {
								dir: seq.dir[0],
								scrollEasing: easing,
								dur: t,
								onComplete: onComplete
							});
							if (once) {
								seq.dir = false;
								return;
							}
							clearTimeout(seq.step);
							seq.step = setTimeout(function () {
								_on();
							}, t);
						}

						function _off() {
							clearTimeout(seq.step);
							_delete(seq, "step");
							_stop(el);
						}
					},
					_arr = function _arr(val) {
						var o = $(this).data(pluginPfx).opt,
							vals = [];
						if (typeof val === "function") {
							val = val();
						}
						if (!(val instanceof Array)) {
							vals[0] = val.y ? val.y : val.x || o.axis === "x" ? null : val;
							vals[1] = val.x ? val.x : val.y || o.axis === "y" ? null : val;
						} else {
							vals = val.length > 1 ? [val[0], val[1]] : o.axis === "x" ? [null, val[0]] : [val[0], null];
						}
						if (typeof vals[0] === "function") {
							vals[0] = vals[0]();
						}
						if (typeof vals[1] === "function") {
							vals[1] = vals[1]();
						}
						return vals;
					},
					_to = function _to(val, dir) {
						if (val == null || typeof val == "undefined") {
							return;
						}
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent(),
							t = typeof val === "undefined" ? "undefined" : _typeof(val);
						if (!dir) {
							dir = o.axis === "x" ? "x" : "y";
						}
						var contentLength = dir === "x" ? mCSB_container.outerWidth(false) - wrapper.width() : mCSB_container.outerHeight(false) - wrapper.height(),
							contentPos = dir === "x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
							cssProp = dir === "x" ? "left" : "top";
						switch (t) {
							case "function":
								return val();
								break;
							case "object":
								var obj = val.jquery ? val : $(val);
								if (!obj.length) {
									return;
								}
								return dir === "x" ? _childPos(obj)[1] : _childPos(obj)[0];
								break;
							case "string":
							case "number":
								if (_isNumeric(val)) {
									return Math.abs(val);
								} else if (val.indexOf("%") !== -1) {
									return Math.abs(contentLength * parseInt(val) / 100);
								} else if (val.indexOf("-=") !== -1) {
									return Math.abs(contentPos - parseInt(val.split("-=")[1]));
								} else if (val.indexOf("+=") !== -1) {
									var p = contentPos + parseInt(val.split("+=")[1]);
									return p >= 0 ? 0 : Math.abs(p);
								} else if (val.indexOf("px") !== -1 && _isNumeric(val.split("px")[0])) {
									return Math.abs(val.split("px")[0]);
								} else {
									if (val === "top" || val === "left") {
										return 0;
									} else if (val === "bottom") {
										return Math.abs(wrapper.height() - mCSB_container.outerHeight(false));
									} else if (val === "right") {
										return Math.abs(wrapper.width() - mCSB_container.outerWidth(false));
									} else if (val === "first" || val === "last") {
										var obj = mCSB_container.find(":" + val);
										return dir === "x" ? _childPos(obj)[1] : _childPos(obj)[0];
									} else {
										if ($(val).length) {
											return dir === "x" ? _childPos($(val))[1] : _childPos($(val))[0];
										} else {
											mCSB_container.css(cssProp, val);
											methods.update.call(null, $this[0]);
											return;
										}
									}
								}
								break;
						}
					},
					_autoUpdate = function _autoUpdate(rem) {
						var $this = $(this),
							d = $this.data(pluginPfx),
							o = d.opt,
							mCSB_container = $("#mCSB_" + d.idx + "_container");
						if (rem) {
							clearTimeout(mCSB_container[0].autoUpdate);
							_delete(mCSB_container[0], "autoUpdate");
							return;
						}
						upd();

						function upd() {
							clearTimeout(mCSB_container[0].autoUpdate);
							if ($this.parents("html").length === 0) {
								$this = null;
								return;
							}
							mCSB_container[0].autoUpdate = setTimeout(function () {
								if (o.advanced.updateOnSelectorChange) {
									d.poll.change.n = sizesSum();
									if (d.poll.change.n !== d.poll.change.o) {
										d.poll.change.o = d.poll.change.n;
										doUpd(3);
										return;
									}
								}
								if (o.advanced.updateOnContentResize) {
									d.poll.size.n = $this[0].scrollHeight + $this[0].scrollWidth + mCSB_container[0].offsetHeight + $this[0].offsetHeight + $this[0].offsetWidth;
									if (d.poll.size.n !== d.poll.size.o) {
										d.poll.size.o = d.poll.size.n;
										doUpd(1);
										return;
									}
								}
								if (o.advanced.updateOnImageLoad) {
									if (!(o.advanced.updateOnImageLoad === "auto" && o.axis === "y")) {
										d.poll.img.n = mCSB_container.find("img").length;
										if (d.poll.img.n !== d.poll.img.o) {
											d.poll.img.o = d.poll.img.n;
											mCSB_container.find("img").each(function () {
												imgLoader(this);
											});
											return;
										}
									}
								}
								if (o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad) {
									upd();
								}
							}, o.advanced.autoUpdateTimeout);
						}

						function imgLoader(el) {
							if ($(el).hasClass(classes[2])) {
								doUpd();
								return;
							}
							var img = new Image();

							function createDelegate(contextObject, delegateMethod) {
								return function () {
									return delegateMethod.apply(contextObject, arguments);
								};
							}

							function imgOnLoad() {
								this.onload = null;
								$(el).addClass(classes[2]);
								doUpd(2);
							}
							img.onload = createDelegate(img, imgOnLoad);
							img.src = el.src;
						}

						function sizesSum() {
							if (o.advanced.updateOnSelectorChange === true) {
								o.advanced.updateOnSelectorChange = "*";
							}
							var total = 0,
								sel = mCSB_container.find(o.advanced.updateOnSelectorChange);
							if (o.advanced.updateOnSelectorChange && sel.length > 0) {
								sel.each(function () {
									total += this.offsetHeight + this.offsetWidth;
								});
							}
							return total;
						}

						function doUpd(cb) {
							clearTimeout(mCSB_container[0].autoUpdate);
							methods.update.call(null, $this[0], cb);
						}
					},
					_snapAmount = function _snapAmount(to, amount, offset) {
						return Math.round(to / amount) * amount - offset;
					},
					_stop = function _stop(el) {
						var d = el.data(pluginPfx),
							sel = $("#mCSB_" + d.idx + "_container,#mCSB_" + d.idx + "_container_wrapper,#mCSB_" + d.idx + "_dragger_vertical,#mCSB_" + d.idx + "_dragger_horizontal");
						sel.each(function () {
							_stopTween.call(this);
						});
					},
					_scrollTo = function _scrollTo(el, to, options) {
						var d = el.data(pluginPfx),
							o = d.opt,
							defaults = {
								trigger: "internal",
								dir: "y",
								scrollEasing: "mcsEaseOut",
								drag: false,
								dur: o.scrollInertia,
								overwrite: "all",
								callbacks: true,
								onStart: true,
								onUpdate: true,
								onComplete: true
							},
							options = $.extend(defaults, options),
							dur = [options.dur, options.drag ? 0 : options.dur],
							mCustomScrollBox = $("#mCSB_" + d.idx),
							mCSB_container = $("#mCSB_" + d.idx + "_container"),
							wrapper = mCSB_container.parent(),
							totalScrollOffsets = o.callbacks.onTotalScrollOffset ? _arr.call(el, o.callbacks.onTotalScrollOffset) : [0, 0],
							totalScrollBackOffsets = o.callbacks.onTotalScrollBackOffset ? _arr.call(el, o.callbacks.onTotalScrollBackOffset) : [0, 0];
						d.trigger = options.trigger;
						if (wrapper.scrollTop() !== 0 || wrapper.scrollLeft() !== 0) {
							$(".mCSB_" + d.idx + "_scrollbar").css("visibility", "visible");
							wrapper.scrollTop(0).scrollLeft(0);
						}
						if (to === "_resetY" && !d.contentReset.y) {
							if (_cb("onOverflowYNone")) {
								o.callbacks.onOverflowYNone.call(el[0]);
							}
							d.contentReset.y = 1;
						}
						if (to === "_resetX" && !d.contentReset.x) {
							if (_cb("onOverflowXNone")) {
								o.callbacks.onOverflowXNone.call(el[0]);
							}
							d.contentReset.x = 1;
						}
						if (to === "_resetY" || to === "_resetX") {
							return;
						}
						if ((d.contentReset.y || !el[0].mcs) && d.overflowed[0]) {
							if (_cb("onOverflowY")) {
								o.callbacks.onOverflowY.call(el[0]);
							}
							d.contentReset.x = null;
						}
						if ((d.contentReset.x || !el[0].mcs) && d.overflowed[1]) {
							if (_cb("onOverflowX")) {
								o.callbacks.onOverflowX.call(el[0]);
							}
							d.contentReset.x = null;
						}
						if (o.snapAmount) {
							var snapAmount = !(o.snapAmount instanceof Array) ? o.snapAmount : options.dir === "x" ? o.snapAmount[1] : o.snapAmount[0];
							to = _snapAmount(to, snapAmount, o.snapOffset);
						}
						switch (options.dir) {
							case "x":
								var mCSB_dragger = $("#mCSB_" + d.idx + "_dragger_horizontal"),
									property = "left",
									contentPos = mCSB_container[0].offsetLeft,
									limit = [mCustomScrollBox.width() - mCSB_container.outerWidth(false), mCSB_dragger.parent().width() - mCSB_dragger.width()],
									scrollTo = [to, to === 0 ? 0 : to / d.scrollRatio.x],
									tso = totalScrollOffsets[1],
									tsbo = totalScrollBackOffsets[1],
									totalScrollOffset = tso > 0 ? tso / d.scrollRatio.x : 0,
									totalScrollBackOffset = tsbo > 0 ? tsbo / d.scrollRatio.x : 0;
								break;
							case "y":
								var mCSB_dragger = $("#mCSB_" + d.idx + "_dragger_vertical"),
									property = "top",
									contentPos = mCSB_container[0].offsetTop,
									limit = [mCustomScrollBox.height() - mCSB_container.outerHeight(false), mCSB_dragger.parent().height() - mCSB_dragger.height()],
									scrollTo = [to, to === 0 ? 0 : to / d.scrollRatio.y],
									tso = totalScrollOffsets[0],
									tsbo = totalScrollBackOffsets[0],
									totalScrollOffset = tso > 0 ? tso / d.scrollRatio.y : 0,
									totalScrollBackOffset = tsbo > 0 ? tsbo / d.scrollRatio.y : 0;
								break;
						}
						if (scrollTo[1] < 0 || scrollTo[0] === 0 && scrollTo[1] === 0) {
							scrollTo = [0, 0];
						} else if (scrollTo[1] >= limit[1]) {
							scrollTo = [limit[0], limit[1]];
						} else {
							scrollTo[0] = -scrollTo[0];
						}
						if (!el[0].mcs) {
							_mcs();
							if (_cb("onInit")) {
								o.callbacks.onInit.call(el[0]);
							}
						}
						clearTimeout(mCSB_container[0].onCompleteTimeout);
						_tweenTo(mCSB_dragger[0], property, Math.round(scrollTo[1]), dur[1], options.scrollEasing);
						if (!d.tweenRunning && (contentPos === 0 && scrollTo[0] >= 0 || contentPos === limit[0] && scrollTo[0] <= limit[0])) {
							return;
						}
						_tweenTo(mCSB_container[0], property, Math.round(scrollTo[0]), dur[0], options.scrollEasing, options.overwrite, {
							onStart: function onStart() {
								if (options.callbacks && options.onStart && !d.tweenRunning) {
									if (_cb("onScrollStart")) {
										_mcs();
										o.callbacks.onScrollStart.call(el[0]);
									}
									d.tweenRunning = true;
									_onDragClasses(mCSB_dragger);
									d.cbOffsets = _cbOffsets();
								}
							},
							onUpdate: function onUpdate() {
								if (options.callbacks && options.onUpdate) {
									if (_cb("whileScrolling")) {
										_mcs();
										o.callbacks.whileScrolling.call(el[0]);
									}
								}
							},
							onComplete: function onComplete() {
								if (options.callbacks && options.onComplete) {
									if (o.axis === "yx") {
										clearTimeout(mCSB_container[0].onCompleteTimeout);
									}
									var t = mCSB_container[0].idleTimer || 0;
									mCSB_container[0].onCompleteTimeout = setTimeout(function () {
										if (_cb("onScroll")) {
											_mcs();
											o.callbacks.onScroll.call(el[0]);
										}
										if (_cb("onTotalScroll") && scrollTo[1] >= limit[1] - totalScrollOffset && d.cbOffsets[0]) {
											_mcs();
											o.callbacks.onTotalScroll.call(el[0]);
										}
										if (_cb("onTotalScrollBack") && scrollTo[1] <= totalScrollBackOffset && d.cbOffsets[1]) {
											_mcs();
											o.callbacks.onTotalScrollBack.call(el[0]);
										}
										d.tweenRunning = false;
										mCSB_container[0].idleTimer = 0;
										_onDragClasses(mCSB_dragger, "hide");
									}, t);
								}
							}
						});

						function _cb(cb) {
							return d && o.callbacks[cb] && typeof o.callbacks[cb] === "function";
						}

						function _cbOffsets() {
							return [o.callbacks.alwaysTriggerOffsets || contentPos >= limit[0] + tso, o.callbacks.alwaysTriggerOffsets || contentPos <= -tsbo];
						}

						function _mcs() {
							var cp = [mCSB_container[0].offsetTop, mCSB_container[0].offsetLeft],
								dp = [mCSB_dragger[0].offsetTop, mCSB_dragger[0].offsetLeft],
								cl = [mCSB_container.outerHeight(false), mCSB_container.outerWidth(false)],
								pl = [mCustomScrollBox.height(), mCustomScrollBox.width()];
							el[0].mcs = {
								content: mCSB_container,
								top: cp[0],
								left: cp[1],
								draggerTop: dp[0],
								draggerLeft: dp[1],
								topPct: Math.round(100 * Math.abs(cp[0]) / (Math.abs(cl[0]) - pl[0])),
								leftPct: Math.round(100 * Math.abs(cp[1]) / (Math.abs(cl[1]) - pl[1])),
								direction: options.dir
							};
						}
					},
					_tweenTo = function _tweenTo(el, prop, to, duration, easing, overwrite, callbacks) {
						if (!el._mTween) {
							el._mTween = {
								top: {},
								left: {}
							};
						}
						var callbacks = callbacks || {},
							onStart = callbacks.onStart || function () { },
							onUpdate = callbacks.onUpdate || function () { },
							onComplete = callbacks.onComplete || function () { },
							startTime = _getTime(),
							_delay, progress = 0,
							from = el.offsetTop,
							elStyle = el.style,
							_request, tobj = el._mTween[prop];
						if (prop === "left") {
							from = el.offsetLeft;
						}
						var diff = to - from;
						tobj.stop = 0;
						if (overwrite !== "none") {
							_cancelTween();
						}
						_startTween();

						function _step() {
							if (tobj.stop) {
								return;
							}
							if (!progress) {
								onStart.call();
							}
							progress = _getTime() - startTime;
							_tween();
							if (progress >= tobj.time) {
								tobj.time = progress > tobj.time ? progress + _delay - (progress - tobj.time) : progress + _delay - 1;
								if (tobj.time < progress + 1) {
									tobj.time = progress + 1;
								}
							}
							if (tobj.time < duration) {
								tobj.id = _request(_step);
							} else {
								onComplete.call();
							}
						}

						function _tween() {
							if (duration > 0) {
								tobj.currVal = _ease(tobj.time, from, diff, duration, easing);
								elStyle[prop] = Math.round(tobj.currVal) + "px";
							} else {
								elStyle[prop] = to + "px";
							}
							onUpdate.call();
						}

						function _startTween() {
							_delay = 1000 / 60;
							tobj.time = progress + _delay;
							_request = !window.requestAnimationFrame ? function (f) {
								_tween();
								return setTimeout(f, 0.01);
							} : window.requestAnimationFrame;
							tobj.id = _request(_step);
						}

						function _cancelTween() {
							if (tobj.id == null) {
								return;
							}
							if (!window.requestAnimationFrame) {
								clearTimeout(tobj.id);
							} else {
								window.cancelAnimationFrame(tobj.id);
							}
							tobj.id = null;
						}

						function _ease(t, b, c, d, type) {
							switch (type) {
								case "linear":
								case "mcsLinear":
									return c * t / d + b;
									break;
								case "mcsLinearOut":
									t /= d;
									t--;
									return c * Math.sqrt(1 - t * t) + b;
									break;
								case "easeInOutSmooth":
									t /= d / 2;
									if (t < 1) return c / 2 * t * t + b;
									t--;
									return -c / 2 * (t * (t - 2) - 1) + b;
									break;
								case "easeInOutStrong":
									t /= d / 2;
									if (t < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
									t--;
									return c / 2 * (-Math.pow(2, -10 * t) + 2) + b;
									break;
								case "easeInOut":
								case "mcsEaseInOut":
									t /= d / 2;
									if (t < 1) return c / 2 * t * t * t + b;
									t -= 2;
									return c / 2 * (t * t * t + 2) + b;
									break;
								case "easeOutSmooth":
									t /= d;
									t--;
									return -c * (t * t * t * t - 1) + b;
									break;
								case "easeOutStrong":
									return c * (-Math.pow(2, -10 * t / d) + 1) + b;
									break;
								case "easeOut":
								case "mcsEaseOut":
								default:
									var ts = (t /= d) * t,
										tc = ts * t;
									return b + c * (0.499999999999997 * tc * ts + -2.5 * ts * ts + 5.5 * tc + -6.5 * ts + 4 * t);
							}
						}
					},
					_getTime = function _getTime() {
						if (window.performance && window.performance.now) {
							return window.performance.now();
						} else {
							if (window.performance && window.performance.webkitNow) {
								return window.performance.webkitNow();
							} else {
								if (Date.now) {
									return Date.now();
								} else {
									return new Date().getTime();
								}
							}
						}
					},
					_stopTween = function _stopTween() {
						var el = this;
						if (!el._mTween) {
							el._mTween = {
								top: {},
								left: {}
							};
						}
						var props = ["top", "left"];
						for (var i = 0; i < props.length; i++) {
							var prop = props[i];
							if (el._mTween[prop].id) {
								if (!window.requestAnimationFrame) {
									clearTimeout(el._mTween[prop].id);
								} else {
									window.cancelAnimationFrame(el._mTween[prop].id);
								}
								el._mTween[prop].id = null;
								el._mTween[prop].stop = 1;
							}
						}
					},
					_delete = function _delete(c, m) {
						try {
							delete c[m];
						} catch (e) {
							c[m] = null;
						}
					},
					_mouseBtnLeft = function _mouseBtnLeft(e) {
						return !(e.which && e.which !== 1);
					},
					_pointerTouch = function _pointerTouch(e) {
						var t = e.originalEvent.pointerType;
						return !(t && t !== "touch" && t !== 2);
					},
					_isNumeric = function _isNumeric(val) {
						return !isNaN(parseFloat(val)) && isFinite(val);
					},
					_childPos = function _childPos(el) {
						var p = el.parents(".mCSB_container");
						return [el.offset().top - p.offset().top, el.offset().left - p.offset().left];
					},
					_isTabHidden = function _isTabHidden() {
						var prop = _getHiddenProp();
						if (!prop) return false;
						return document[prop];

						function _getHiddenProp() {
							var pfx = ["webkit", "moz", "ms", "o"];
							if ("hidden" in document) return "hidden";
							for (var i = 0; i < pfx.length; i++) {
								if (pfx[i] + "Hidden" in document) return pfx[i] + "Hidden";
							}
							return null;
						}
					};
				$.fn[pluginNS] = function (method) {
					if (methods[method]) {
						return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
					} else if ((typeof method === "undefined" ? "undefined" : _typeof(method)) === "object" || !method) {
						return methods.init.apply(this, arguments);
					} else {
						$.error("Method " + method + " does not exist");
					}
				};
				$[pluginNS] = function (method) {
					if (methods[method]) {
						return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
					} else if ((typeof method === "undefined" ? "undefined" : _typeof(method)) === "object" || !method) {
						return methods.init.apply(this, arguments);
					} else {
						$.error("Method " + method + " does not exist");
					}
				};
				$[pluginNS].defaults = defaults;
				window[pluginNS] = true;
				$(window).bind("load", function () {
					$(defaultSelector)[pluginNS]();
					$.extend($.expr[":"], {
						mcsInView: $.expr[":"].mcsInView || function (el) {
							var $el = $(el),
								content = $el.parents(".mCSB_container"),
								wrapper, cPos;
							if (!content.length) {
								return;
							}
							wrapper = content.parent();
							cPos = [content[0].offsetTop, content[0].offsetLeft];
							return cPos[0] + _childPos($el)[0] >= 0 && cPos[0] + _childPos($el)[0] < wrapper.height() - $el.outerHeight(false) && cPos[1] + _childPos($el)[1] >= 0 && cPos[1] + _childPos($el)[1] < wrapper.width() - $el.outerWidth(false);
						},
						mcsInSight: $.expr[":"].mcsInSight || function (el, i, m) {
							var $el = $(el),
								elD, content = $el.parents(".mCSB_container"),
								wrapperView, pos, wrapperViewPct, pctVals = m[3] === "exact" ? [
									[1, 0],
									[1, 0]
								] : [
									[0.9, 0.1],
									[0.6, 0.4]
								];
							if (!content.length) {
								return;
							}
							elD = [$el.outerHeight(false), $el.outerWidth(false)];
							pos = [content[0].offsetTop + _childPos($el)[0], content[0].offsetLeft + _childPos($el)[1]];
							wrapperView = [content.parent()[0].offsetHeight, content.parent()[0].offsetWidth];
							wrapperViewPct = [elD[0] < wrapperView[0] ? pctVals[0] : pctVals[1], elD[1] < wrapperView[1] ? pctVals[0] : pctVals[1]];
							return pos[0] - wrapperView[0] * wrapperViewPct[0][0] < 0 && pos[0] + elD[0] - wrapperView[0] * wrapperViewPct[0][1] >= 0 && pos[1] - wrapperView[1] * wrapperViewPct[1][0] < 0 && pos[1] + elD[1] - wrapperView[1] * wrapperViewPct[1][1] >= 0;
						},
						mcsOverflow: $.expr[":"].mcsOverflow || function (el) {
							var d = $(el).data(pluginPfx);
							if (!d) {
								return;
							}
							return d.overflowed[0] || d.overflowed[1];
						}
					});
				});
			});
		});
	}), (function (module, exports) {
		(function (__webpack_amd_options__) {
			module.exports = __webpack_amd_options__;
		}.call(exports, {}))
	})]);
jQuery('#form-credit-course').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const self = jQuery(this).serialize();
	send_to_amo(self, 'form-credit-course');
});
jQuery('#want_on_course').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const want_on_course = jQuery(this).serialize();
	send_to_amo(want_on_course, 'want_on_course');
});
jQuery('#form-order-pop-up').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	console.log('pop');
	const form_order_pop_up = jQuery(this).serialize();
	send_to_amo(form_order_pop_up, 'form-order-pop-up');
});
jQuery('#form-callback-popup').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const form_order_pop_up = jQuery(this).serialize();
	send_to_amo(form_order_pop_up, 'form-callback-popup');
});
jQuery('#form-course').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const form_course = jQuery(this).serialize();
	send_to_amo(form_course, 'form-course');
});
jQuery('#form-callback').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const form_callback = jQuery(this).serialize();
	send_to_amo(form_callback, 'form-callback');
});
jQuery('#form-callback').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const form_callback = jQuery(this).serialize();
	send_to_amo(form_callback, 'form-callback');
});
jQuery('#zakaz-form').submit(function (e) {
	e.preventDefault();
	$(this).find('input[type="submit"]').css({
		'opacity': 0.3,
		'pointer-events': 'none'
	});
	const zakaz_form = jQuery(this).serialize();
	send_to_amo(zakaz_form, 'zakaz-form');
});

function send_to_amo(data, id_form) {
	data = data + '&id_form=' + id_form;
	data = data + '&action=send_to_amo';
	jQuery.ajax({
		url: wpAjax.url,
		type: 'POST',
		data: data,
		dataType: 'json',
		beforeSend: function () {
			jQuery('body').addClass('load');
		},
		success: function (json) {
			jQuery('body').removeClass('load');
			if (json['error']) {
				for (let key in json.error) {
					if (json.error.hasOwnProperty(key)) { }
				}
			}
			if (json['success']) {
				jQuery('#order-pop-up').removeClass('active');
				if (id_form == 'form-order-pop-up' || id_form == 'form-callback-popup' || id_form == 'want_on_course' || id_form == 'form-credit-course' || id_form == 'form-course' || id_form == 'form-callback' || id_form == 'form-credit-course' || id_form == 'zakaz-form') {
					document.location.href = "/spasibo";
				}
				setTimeout(function () {
					$('#' + id_form)[0].reset();
				}, 3000);
			}
			if (json['error']) {
				var output_error = "";
				if (json['error']['name']) {
					output_error += json['error']['name'] + "\n";
				}
				if (json['error']['email']) {
					output_error += json['error']['email'] + "\n";
				}
				if (json['error']['phone']) {
					output_error += json['error']['phone'] + "\n";
				}
				alert(output_error);
			}
		}
	});
};


document.querySelector(".form1").addEventListener("submit", function (e) {
	e.preventDefault();
	const notification = document.querySelector(".wpcf7-response-output");

	setTimeout(() => {
		notification.style.display = "block";
		document.querySelector("form").reset();
	}, 2000);
});

document.querySelector(".form2").addEventListener("submit", function (e) {
	e.preventDefault();
	const notification = document.querySelector(".wpcf7-response-output2");

	setTimeout(() => {
		notification.style.display = "block";
		document.querySelector(".form2").reset();
	}, 2000);
});


